-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\build.gradle.kts
treść:
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.kotlin.compose) apply false
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\settings.gradle.kts
treść:
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "Laudate"
include(":app")
 

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build.gradle.kts
treść:
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.kotlin.plugin.serialization") version "1.9.23"
}

android {
    namespace = "com.qjproject.liturgicalcalendar"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.qjproject.liturgicalcalendar"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.1")
    implementation("androidx.activity:activity-compose:1.9.0")
    implementation(platform("androidx.compose:compose-bom:2024.05.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.navigation:navigation-compose:2.7.7")
    implementation("androidx.core:core-splashscreen:1.0.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
    implementation("androidx.compose.material:material-icons-extended:1.6.7")
    implementation("com.google.accompanist:accompanist-pager:0.28.0")
    implementation("net.lingala.zip4j:zip4j:2.11.5")
    implementation("com.google.accompanist:accompanist-navigation-animation:0.32.0")

    implementation("org.burnoutcrew.composereorderable:reorderable:0.9.6")

    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2024.05.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build\intermediates\assets\debug\mergeDebugAssets\data\Triduum Paschalne\Wigilia Paschalna.json
treść:
{
  "url": "https://liturgia.wiara.pl/doc/2977736.Wigilia-Paschalna",
  "tytul_dnia": "Wigilia Paschalna",
  "czy_datowany": false,
  "czytania": [
    {
      "typ": "PIERWSZE CZYTANIE dłuższe",
      "sigla": "Rdz 1, 1 - 2, 2",
      "opis": "Stworzenie świata",
      "tekst": "Na początku Bóg stworzył niebo i ziemię. Ziemia zaś była bezładem i pustkowiem: ciemność była nad powierzchnią bezmiaru wód, a Duch Boży unosił się nad wodami.\n\nWtedy Bóg rzekł: «Niechaj się stanie światłość!» I stała się światłość. Bóg, widząc, że światłość jest dobra, oddzielił ją od ciemności. I nazwał Bóg światłość dniem, a ciemność nazwał nocą.\n\nI tak upłynął wieczór i poranek - dzień pierwszy.\n\nA potem Bóg rzekł: «Niechaj powstanie sklepienie w środku wód i niechaj oddzieli ono jedne wody od drugich! » Uczyniwszy to sklepienie, Bóg oddzielił wody pod sklepieniem od wód ponad sklepieniem; a gdy tak się stało, Bóg nazwał to sklepienie niebem.\n\nI tak upłynął wieczór i poranek - dzień drugi.\n\nA potem Bóg rzekł: «Niechaj zbiorą się wody spod nieba w jedno miejsce i niech się ukaże powierzchnia sucha!» A gdy tak się stało, Bóg nazwał tę suchą powierzchnię ziemią, a zbiorowisko wód nazwał morzem. Bóg, widząc, że były dobre, rzekł: «Niechaj ziemia wyda rośliny zielone: trawy dające nasiona, drzewa owocowe rodzące na ziemi według swego gatunku owoce, w których są nasiona». I tak się stało. Ziemia wydała rośliny zielone: trawę dającą nasienie według swego gatunku i drzewa rodzące owoce, w których było nasienie według ich gatunków. A Bóg widział, że były dobre.\n\nI tak upłynął wieczór i poranek - dzień trzeci.\n\nA potem Bóg rzekł: «Niechaj powstaną ciała niebieskie, świecące na sklepieniu nieba, aby oddzielały dzień od nocy, aby wyznaczały pory roku, dni i lata; aby były ciałami jaśniejącymi na sklepieniu nieba i aby świeciły nad ziemią». I tak się stało. Bóg uczynił dwa duże ciała jaśniejące: większe, aby rządziło dniem, i mniejsze, aby rządziło nocą, oraz gwiazdy. I umieścił je Bóg na sklepieniu nieba, aby świeciły nad ziemią; aby rządziły dniem i nocą i oddzielały światłość od ciemności. A widział Bóg, że były dobre.\n\nI tak upłynął wieczór i poranek - dzień czwarty.\n\nPotem Bóg rzekł: «Niechaj się zaroją wody od istot żywych, a ptactwo niechaj lata nad ziemią, pod sklepieniem nieba!» Tak stworzył Bóg wielkie potwory morskie i wszelkiego rodzaju pływające istoty żywe, którymi zaroiły się wody, oraz wszelkie ptactwo skrzydlate różnego rodzaju. Bóg, widząc, że były dobre, pobłogosławił je tymi słowami: «Bądźcie płodne i mnóżcie się, abyście zapełniały wody w morzach, a ptactwo niechaj się rozmnaża na ziemi».\n\nI tak upłynął wieczór i poranek - dzień piąty.\n\nPotem Bóg rzekł: «Niechaj ziemia wyda istoty żywe różnego rodzaju: bydło, zwierzęta pełzające i dzikie zwierzęta według ich rodzajów!» I stało się tak: Bóg uczynił różne rodzaje dzikich zwierząt, bydła i wszelkich zwierząt pełzających po ziemi. I widział Bóg, że były dobre.\n\nA wreszcie rzekł Bóg: «Uczyńmy człowieka na Nasz obraz, podobnego Nam. Niech panuje nad rybami morskimi, nad ptactwem podniebnym, nad bydłem, nad ziemią i nad wszystkimi zwierzętami pełzającymi po ziemi!» Stworzył więc Bóg człowieka na swój obraz, na obraz Boży go stworzył: stworzył mężczyznę i niewiastę.\n\nPo czym Bóg im błogosławił, mówiąc do nich: «Bądźcie płodni i rozmnażajcie się, abyście zaludnili ziemię i uczynili ją sobie poddaną; abyście panowali nad ptactwem podniebnym, nad rybami morskimi i nad wszystkimi zwierzętami pełzającymi po ziemi». I rzekł Bóg: «Oto wam daję wszelką roślinę przynoszącą ziarno po całej ziemi i wszelkie drzewo, którego owoc ma w sobie nasienie: dla was będą one pokarmem. A dla wszelkiego zwierzęcia polnego i dla wszelkiego ptactwa podniebnego, i dla wszystkiego, co się porusza po ziemi i ma w sobie pierwiastek życia, będzie pokarmem wszelka trawa zielona». I tak się stało. A Bóg widział, że wszystko, co uczynił, było bardzo dobre.\n\nI tak upłynął wieczór i poranek - dzień szósty.\n\nW ten sposób zostały ukończone niebo i ziemia oraz wszystkie zastępy jej stworzeń. A gdy ukończył w dniu szóstym swe dzieło, nad którym pracował, odpoczął dnia siódmego po całym swym trudzie, jaki podjął.\n\nOto słowo Boże."
    },
    {
      "typ": "PIERWSZE CZYTANIE krótsze",
      "sigla": "Rdz 1, 1. 26-31a",
      "opis": "",
      "tekst": "Na początku Bóg stworzył niebo i ziemię. Potem rzekł Bóg: «Uczyńmy człowieka na Nasz obraz, podobnego Nam. Niech panuje nad rybami morskimi, nad ptactwem podniebnym, nad bydłem, nad ziemią i nad wszystkimi zwierzętami pełzającymi po ziemi!» Stworzył więc Bóg człowieka na swój obraz, na obraz Boży go stworzył: stworzył mężczyznę i niewiastę.\n\nPo czym Bóg im błogosławił, mówiąc do nich: «Bądźcie płodni i rozmnażajcie się, abyście zaludnili ziemię i uczynili ją sobie poddaną; abyście panowali nad ptactwem podniebnym, nad rybami morskimi i nad wszystkimi zwierzętami pełzającymi po ziemi». I rzekł Bóg: «Oto wam daję wszelką roślinę przynoszącą ziarno po całej ziemi i wszelkie drzewo, którego owoc ma w sobie nasienie: dla was będą one pokarmem. A dla wszelkiego zwierzęcia polnego i dla wszelkiego ptactwa podniebnego, i dla wszystkiego, co się porusza po ziemi i ma w sobie pierwiastek życia, będzie pokarmem wszelka trawa zielona». I tak się stało. A Bóg widział, że wszystko, co uczynił, było bardzo dobre.\n\nOto słowo Boże."
    },
    {
      "typ": "1 PSALM RESPONSORYJNY",
      "sigla": "Ps 104 (103) lub Ps 33 (32)",
      "opis": "",
      "tekst": "Refren: Niech zstąpi Duch Twój i odnowi ziemię.\nBłogosław, duszo moja, Pana, *\nBoże mój, Panie, Ty jesteś bardzo wielki!\nOdziany w majestat i piękno, *\nświatłem okryty jak płaszczem.\nRefren.\nUmocniłeś fundamenty ziemi, *\nnie zachwieje się na wieki wieków.\nJak szatą okryłeś ją Wielką Głębią, *\nponad górami stanęły wody.\nRefren.\nTy zdroje kierujesz do strumieni, *\nktóre pośród gór się sączą.\nNad nimi mieszka ptactwo niebieskie *\ni śpiewa pośród gałęzi.\nRefren.\nZ Twoich komnat nawadniasz góry, *\nowocem dzieł Twoich syci się ziemia.\nKażesz rosnąć trawie dla bydła *\ni roślinom, by człowiekowi służyły.\nRefren.\nJak liczne są dzieła Twoje, Panie! *\nTy wszystko mądrze uczyniłeś,\nziemia jest pełna Twoich stworzeń. *\nBłogosław, duszo moja, Pana.\nRefren.\n\nALBO:\n\nRefren: Pełna jest ziemia łaskawości Pana.\nSłowo Pana jest prawe, *\na każde Jego dzieło godne zaufania.\nOn miłuje prawo i sprawiedliwość, *\nziemia jest pełna Jego łaski.\nRefren.\nPrzez słowo Pana powstały niebiosa, *\nwszystkie gwiazdy przez tchnienie ust Jego.\nOn morskie wody gromadzi jak w bukłaku, *\notchłanie oceanu w zbiornikach.\nRefren.\nBłogosławiony lud, którego Pan jest Bogiem, *\nnaród, który On wybrał na dziedzictwo dla siebie.\nPan spogląda z nieba, *\nwidzi wszystkich ludzi.\nRefren.\nDusza nasza oczekuje Pana, *\nOn jest naszą pomocą i tarczą.\nPanie, niech nas ogarnie Twoja łaska, *\nwedług nadziei pokładanej w Tobie.\nRefren."
    },
    {
      "typ": "DRUGIE CZYTANIE dłuższe",
      "sigla": "Rdz 22, 1-18",
      "opis": "Ofiara Abrahama",
      "tekst": "Bóg wystawił Abrahama na próbę i rzekł do niego: «Abrahamie!» A gdy on odpowiedział: «Oto jestem» - powiedział: «Weź twego syna jedynego, którego miłujesz, Izaaka, idź do kraju Moria i tam złóż go w ofierze na jednym z pagórków, jaki ci wskażę».\nNazajutrz rano Abraham osiodłał swego osła, zabrał z sobą dwóch swych ludzi i syna Izaaka, narąbał drzewa do spalenia ofiary i ruszył w drogę do miejscowości, o której mu Bóg powiedział. Na trzeci dzień Abraham, spojrzawszy, dostrzegł z daleka ową miejscowość. I wtedy rzekł do swych sług: «Zostańcie tu z osłem, ja zaś i chłopiec pójdziemy tam, aby oddać pokłon Bogu, a potem wrócimy do was».\nAbraham, zabrawszy drwa do spalenia ofiary, włożył je na syna swego, Izaaka, wziął do ręki ogień i nóż, po czym obaj się oddalili. Izaak odezwał się do swego ojca Abrahama: «Ojcze mój!» A gdy ten rzekł: «Oto jestem, mój synu» - zapytał: «Oto ogień i drwa, a gdzież jest jagnię na całopalenie?» Abraham odpowiedział: «Bóg upatrzy sobie jagnię na całopalenie, synu mój». I szli obydwaj dalej.\n\nA gdy przyszli na to miejsce, które Bóg wskazał, Abraham zbudował tam ołtarz, ułożył na nim drwa i związawszy syna swego, Izaaka, położył go na tych drwach na ołtarzu. Potem Abraham sięgnął ręką po nóż, aby zabić swego syna.\n\nAle wtedy Anioł Pański zawołał na niego z nieba i rzekł:\n\n«Abrahamie, Abrahamie!» A on rzekł: «Oto jestem». Anioł powiedział mu: «Nie podnoś ręki na chłopca i nie czyń mu nic złego! Teraz poznałem, że boisz się Boga, bo nie odmówiłeś Mi nawet twego jedynego syna». Abraham, obejrzawszy się poza siebie, spostrzegł barana uwikłanego rogami w zaroślach. Poszedł więc, wziął barana i złożył w ofierze całopalnej zamiast swego syna. I dał Abraham miejscu temu nazwę «Pan widzi». Stąd to mówi się dzisiaj: «Na wzgórzu Pan się ukazuje».\n\nPo czym Anioł Pański przemówił głośno z nieba do Abrahama po raz drugi: «Przysięgam na siebie, mówi Pan, że ponieważ uczyniłeś to, a nie odmówiłeś Mi syna twego jedynego, będę ci błogosławił i dam ci potomstwo tak liczne jak gwiazdy na niebie i jak ziarnka piasku na wybrzeżu morza; potomkowie twoi zdobędą warownie swych nieprzyjaciół. Wszystkie ludy ziemi będą sobie życzyć szczęścia takiego, jakie jest udziałem twego potomstwa, dlatego że usłuchałeś mego rozkazu».\n\nOto słowo Boże."
    },
    {
      "typ": "DRUGIE CZYTANIE krótsze",
      "sigla": "Rdz 22, 1-2. 9-13. 15-18",
      "opis": "",
      "tekst": "Bóg wystawił Abrahama na próbę i rzekł do niego: «Abrahamie!» A gdy on odpowiedział: «Oto jestem» - powiedział: «Weź twego syna jedynego, którego miłujesz, Izaaka, idź do kraju Moria i tam złóż go w ofierze na jednym z pagórków, jaki ci wskażę».\n\nA gdy przyszli na to miejsce, które Bóg wskazał, Abraham zbudował tam ołtarz, ułożył na nim drwa i związawszy syna swego, Izaaka, położył go na tych drwach na ołtarzu. Potem Abraham sięgnął ręką po nóż, aby zabić swego syna.\n\nAle wtedy Anioł Pański zawołał na niego z nieba i rzekł: «Abrahamie, Abrahamie!» A on rzekł: «Oto jestem». Anioł powiedział mu: «Nie podnoś ręki na chłopca i nie czyń mu nic złego! Teraz poznałem, że boisz się Boga, bo nie odmówiłeś Mi nawet twego jedynego syna». Abraham, obejrzawszy się poza siebie, spostrzegł barana uwikłanego rogami w zaroślach. Poszedł więc, wziął barana i złożył w ofierze całopalnej zamiast swego syna.\n\nPo czym Anioł Pański przemówił głośno z nieba do Abrahama po raz drugi: «Przysięgam na siebie, mówi Pan, że ponieważ uczyniłeś to, a nie odmówiłeś Mi syna twego jedynego, będę ci błogosławił i dam ci potomstwo tak liczne jak gwiazdy na niebie i jak ziarnka piasku na wybrzeżu morza; potomkowie twoi zdobędą warownie swych nieprzyjaciół. Wszystkie ludy ziemi będą sobie życzyć szczęścia takiego, jakie jest udziałem twego potomstwa, dlatego że usłuchałeś mego rozkazu».\n\nOto słowo Boże."
    },
    {
      "typ": "2 PSALM RESPONSORYJNY",
      "sigla": "Ps 16 (15), 5 i 8. 9-10. 11 (R.: por. 1b)",
      "opis": "",
      "tekst": "Refren: Strzeż mnie, o Boże, Tobie zaufałem.\n\nPan moim dziedzictwem i przeznaczeniem, *\nto On mój los zabezpiecza.\nZawsze stawiam sobie Pana przed oczy, *\nOn jest po mojej prawicy, nic mną nie zachwieje.\n\nRefren.\n\nDlatego cieszy się moje serce i dusza raduje, *\na ciało moje będzie spoczywać bezpiecznie,\nbo w kraju zmarłych duszy mej nie zostawisz *\ni nie dopuścisz, bym pozostał w grobie.\n\nRefren.\n\nTy ścieżkę życia mi ukażesz, *\npełnię radości przy Tobie\ni wieczne szczęście *\npo Twojej prawicy.\n\nRefren."
    },
    {
      "typ": "TRZECIE CZYTANIE",
      "sigla": "Wj 14, 15 - 15, 1a",
      "opis": "Przejście Izraela przez Morze Czerwone",
      "tekst": "Pan rzekł do Mojżesza: «Czemu głośno wołasz do Mnie? Powiedz Izraelitom, niech ruszają w drogę. Ty zaś podnieś swą laskę i wyciągnij rękę nad morze, i rozdziel je na dwoje, a wejdą Izraelici w środek morza na suchą ziemię. Ja natomiast uczynię upartymi serca Egipcjan tak, że pójdą za nimi. Wtedy okażę moją potęgę wobec faraona, całego wojska jego, rydwanów i wszystkich jego jeźdźców. A gdy okażę moją potęgę wobec faraona, jego rydwanów i jeźdźców, wtedy poznają Egipcjanie, że Ja jestem Pan».\n\nAnioł Boży, który szedł na przedzie wojsk izraelskich, zmienił miejsce i szedł na ich tyłach. Słup obłoku również przeszedł z przodu i zajął ich tyły, stając między wojskiem egipskim a wojskiem izraelskim. I tam był obłok ciemnością, tu zaś oświecał noc. I nie zbliżyli się jedni do drugich przez całą noc.\n\nMojżesz wyciągnął rękę nad morze, a Pan cofnął wody gwałtownym wiatrem wschodnim, który wiał przez całą noc, i uczynił morze suchą ziemią. Wody się rozstąpiły, a Izraelici szli przez środek morza po suchej ziemi, mając mur z wód po prawej i po lewej stronie. Egipcjanie ścigali ich. Wszystkie konie faraona, jego rydwany i jeźdźcy weszli za nimi w środek morza.\n\nO świcie spojrzał Pan ze słupa ognia i ze słupa obłoku na wojsko egipskie i zmusił je do ucieczki. I zatrzymał koła ich rydwanów, tak że z wielką trudnością mogli się naprzód posuwać. Egipcjanie krzyknęli: «Uciekajmy przed Izraelem, bo w jego obronie Pan walczy z Egipcjanami».\n\nA Pan rzekł do Mojżesza: «Wyciągnij rękę nad morze, aby wody zalały Egipcjan, ich rydwany i jeźdźców». Wyciągnął Mojżesz rękę nad morze, które o brzasku dnia wróciło na swoje miejsce. Egipcjanie, uciekając, biegli naprzeciw falom, i pogrążył ich Pan w środku morza. Powracające fale zatopiły rydwany i jeźdźców całego wojska faraona, którzy weszli w morze, ścigając tamtych; nie ocalał z nich ani jeden. Izraelici zaś szli po suchym dnie morskim, mając mur wodny po prawej i po lewej stronie.\n\nW tym to dniu wybawił Pan Izraela z rąk Egipcjan.\n\nI widzieli Izraelici martwych Egipcjan na brzegu morza. Gdy Izraelici zobaczyli wielkie dzieło, którego dokonał Pan wobec Egipcjan, ulękli się Pana i uwierzyli Jemu oraz Jego słudze Mojżeszowi. Wtedy Mojżesz i Izraelici razem z nim zaśpiewali taką oto pieśń ku czci Pana:"
    },
    {
      "typ": "3 PSALM RESPONSORYJNY",
      "sigla": "Wj 15, 1b-2c. 3-4. 5-6. 17-18 (R.: por. 1bc)",
      "opis": "",
      "tekst": "Refren: Śpiewajmy Panu, który moc okazał.\n\nZaśpiewam na cześć Pana, który okrył się sławą, *\ngdy konia i jeźdźca pogrążył w morskiej toni.\nPan jest moją mocą i źródłem męstwa, †\nJemu zawdzięczam moje ocalenie. *\nOn Bogiem moim, uwielbiać Go będę.\n\nRefren.\n\nPan wojownik potężny, *\n«Ten, który jest», brzmi Jego imię.\nRzucił w morze rydwany faraona i wojsko jego, *\nwybrani wodzowie legli w Morzu Czerwonym.\n\nRefren.\n\nPrzepaści ich ogarnęły, *\njak głaz runęli w głębinę.\nUwielbiona jest potęga prawicy Twej, Panie, *\nprawica Twa, o Panie, starła nieprzyjaciół.\n\nRefren.\n\nWprowadziłeś ich i osadziłeś *\nna górze Twojego dziedzictwa.\nW miejscu, które uczyniłeś swym mieszkaniem, †\nw świątyni zbudowanej Twoimi rękami, *\nPan jest Królem na zawsze i na wieki.\n\nRefren."
    },
    {
      "typ": "CZWARTE CZYTANIE",
      "sigla": "Iz 54, 4a. 5-14",
      "opis": "Trwałość przymierza",
      "tekst": "Nie lękaj się, Jerozolimo, bo małżonkiem twoim jest twój Stworzyciel, któremu na imię - Pan Zastępów; Odkupicielem twoim - Święty Izraela, nazywają Go Bogiem całej ziemi.\n\nZaiste, jak niewiastę porzuconą i zgnębioną na duchu, wezwał cię Pan. I jakby do porzuconej żony młodości mówi twój Bóg: Na krótką chwilę porzuciłem ciebie, ale z ogromną miłością cię przygarnę. W przystępie gniewu ukryłem przed tobą na krótko swe oblicze, ale w miłości wieczystej nad tobą się ulitowałem, mówi Pan, twój Odkupiciel.\n\nDzieje się ze Mną tak, jak za dni Noego, kiedy przysiągłem, że wody Noego nie spadną już nigdy na ziemię; tak teraz przysięgam, że się nie rozjątrzę na ciebie ani cię gromić nie będę. Bo góry mogą się poruszyć i pagórki się zachwiać, ale miłość moja nie odstąpi ciebie i nie zachwieje się moje przymierze pokoju, mówi Pan, który ma litość nad tobą.\n\nO nieszczęśliwa, wichrami smagana, niepocieszona! Oto ja osadzę twoje kamienie na malachicie i fundamenty twoje na szafirach. Uczynię blanki twych murów z rubinów, bramy twoje z górskiego kryształu, a z drogich kamieni - całe obramowanie twych murów. Wszyscy twoi synowie będą uczniami Pana, wielka będzie szczęśliwość twych dzieci. Będziesz mocno osadzona na sprawiedliwości. Daleka bądź od trwogi, bo nie masz się czego obawiać, i od przestrachu, bo nie ma on przystępu do ciebie.\n\nOto słowo Boże."
    },
    {
      "typ": "4 PSALM RESPONSORYJNY",
      "sigla": "Ps 30 (29), 2 i 4. 5-6. 11-12a i 13b (R.: 2a)",
      "opis": "",
      "tekst": "Refren: Sławię Cię, Panie, bo mnie wybawiłeś.\n\nSławię Cię, Panie, bo mnie wybawiłeś *\ni nie pozwoliłeś mym wrogom naśmiewać się ze mnie.\nPanie, mój Boże, †\nz krainy umarłych wywołałeś moją duszę *\ni ocaliłeś mi życie spośród schodzących do grobu.\n\nRefren.\n\nŚpiewajcie psalm, wszyscy miłujący Pana, *\ni pamiętajcie o Jego świętości.\nGniew Jego bowiem trwa tylko przez chwilę, †\na Jego łaska przez całe życie. *\nPłacz nadchodzi z wieczora, a rankiem wesele.\n\nRefren.\n\nWysłuchaj mnie, Panie, zmiłuj się nade mną, *\nPanie, bądź moją pomocą.\nZamieniłeś w taniec mój żałobny lament, *\nBoże mój i Panie, będę Cię sławił na wieki.\n\nRefren."
    },
    {
      "typ": "PIĄTE CZYTANIE",
      "sigla": "Iz 55, 1-11",
      "opis": "Nowe i wieczne przymierze",
      "tekst": "Tak mówi Pan:\n«Wszyscy spragnieni, przyjdźcie do wody, przyjdźcie, choć nie macie pieniędzy! Kupujcie i spożywajcie, dalejże, kupujcie bez pieniędzy i bez płacenia za wino i mleko! Czemu wydajecie pieniądze na to, co nie jest chlebem? I waszą pracę - na to, co nie nasyci? Słuchajcie Mnie, a jeść będziecie przysmaki i dusza wasza zakosztuje tłustych potraw.\n\nNakłońcie uszu i przyjdźcie do Mnie, posłuchajcie Mnie, a dusza wasza żyć będzie. Zawrę z wami wieczyste przymierze; niezawodne są łaski dla Dawida. Oto ustanowiłem go świadkiem dla ludów, dla ludów wodzem i rozkazodawcą. Oto zawezwiesz naród, którego nie znasz, i ci, którzy cię nie znają, przybiegną do ciebie ze względu na Pana, twojego Boga, przez wzgląd na Świętego Izraela, bo On ci dodał chwały.\n\nSzukajcie Pana, gdy się pozwala znaleźć, wzywajcie Go, dopóki jest blisko. Niechaj bezbożny porzuci swą drogę i człowiek nieprawy swoje knowania. Niech się nawróci do Pana, a Ten się nad nim zmiłuje, do Boga naszego, gdyż hojny jest w przebaczaniu. Bo myśli moje nie są myślami waszymi ani wasze drogi moimi drogami - mówi Pan. Bo jak niebiosa górują nad ziemią, tak drogi moje - nad waszymi drogami i myśli moje - nad myślami waszymi.\n\nZaiste, podobnie jak ulewa i śnieg spadają z nieba i tam nie powracają, dopóki nie nawodnią ziemi, nie użyźnią jej i nie zapewnią urodzaju, tak iż wydaje nasienie dla siewcy i chleb dla jedzącego, tak słowo, które wychodzi z ust moich, nie wraca do Mnie bezowocne, zanim wpierw nie dokona tego, co chciałem, i nie spełni pomyślnie swego posłannictwa».\n\nOto słowo Boże."
    },
    {
      "typ": "5 PSALM RESPONSORYJNY",
      "sigla": "Iz 12, 2. 3 i 4bcd. 5-6 (R.: por. 3)",
      "opis": "",
      "tekst": "Refren: Będziecie czerpać ze zdrojów zbawienia.\n\nOto Bóg jest moim zbawieniem! *\nJemu zaufam i bać się nie będę.\nPan jest moją pieśnią i mocą, *\ni On stał się moim zbawieniem.\n\nRefren.\n\nWy zaś z weselem czerpać będziecie wodę *\nze zdrojów zbawienia.\nChwalcie Pana, wzywajcie Jego imienia! †\nUkażcie narodom Jego dzieła, *\nprzypominajcie, że Jego imię jest chwalebne.\n\nRefren.\n\nŚpiewajcie Panu, bo czynów wspaniałych dokonał! *\nI cała ziemia niech o tym się dowie.\nWznoś okrzyki i wołaj radośnie, mieszkanko Syjonu, *\nbo wielki jest wśród ciebie Święty Izraela.\n\nRefren."
    },
    {
      "typ": "SZÓSTE CZYTANIE",
      "sigla": "Ba 3, 9-15. 32 - 4, 4",
      "opis": "Źródło mądrości",
      "tekst": "Bądź posłuszny, Izraelu, przykazaniom życiodajnym, nakłoń ucha, by poznać mądrość. Cóż się to stało, Izraelu, że jesteś w kraju nieprzyjaciół, wynędzniały w ziemi obcej, uważany za nieczystego na równi z umarłymi, zaliczony do tych, co schodzą do Otchłani? Opuściłeś źródło mądrości. Gdybyś chodził po drodze Bożej, mieszkałbyś w pokoju na wieki. Naucz się, gdzie jest mądrość, gdzie jest siła i rozum, a poznasz równocześnie, gdzie jest długie i szczęśliwe życie, gdzie jest światłość dla oczu i pokój. Lecz któż znalazł jej miejsce lub kto wszedł do jej skarbców?\n\nLecz zna ją Wszechwiedzący i zbadał ją swoim rozumem. Ten, który na czas bezkresny urządził ziemię i napełnił ją stworzeniami czworonożnymi, wysłał światło, i poszło, wezwał je, a ono posłuchało Go z drżeniem. Gwiazdy radośnie świecą na swoich strażnicach. Wezwał je. Odpowiedziały: «Jesteśmy». Z radością świecą swemu Stwórcy.\n\nOn jest Bogiem naszym. I żaden inny nie może z Nim się równać. Zbadał wszystkie drogi mądrości i dał ją słudze swemu, Jakubowi, i Izraelowi, umiłowanemu swojemu. Potem ukazała się ona na ziemi i zaczęła przebywać wśród ludzi. Tą mądrością jest księga przykazań Boga i Prawo trwające na wieki. Wszyscy, którzy się go trzymają, żyć będą. Którzy je zaniedbują, pomrą.\n\nNawróć się, Jakubie, trzymaj się go, chodź w blasku jego światła! Nie dawaj chwały swojej obcemu ani innemu narodowi twych przywilejów! Szczęśliwi jesteśmy, o Izraelu, że znane nam to, co się Bogu podoba.\n\nOto słowo Boże."
    },
    {
      "typ": "6 PSALM RESPONSORYJNY",
      "sigla": "Ps 19 (18), 8-9. 10-11 (R.: por. J 6, 68c)",
      "opis": "",
      "tekst": "Refren: Słowa Twe, Panie, dają życie wieczne.\n\nPrawo Pańskie jest doskonałe i pokrzepia duszę, *\nświadectwo Pana jest pewne, nierozważnego uczy mądrości.\nJego słuszne nakazy radują serce, *\njaśnieje przykazanie Pana i olśniewa oczy.\n\nRefren.\n\nBojaźń Pana jest szczera i trwa na wieki, *\nsądy Pana prawdziwe, wszystkie razem słuszne.\nCenniejsze nad złoto, nad złoto najczystsze, *\nsłodsze od miodu płynącego z plastra.\n\nRefren."
    },
    {
      "typ": "SIÓDME CZYTANIE",
      "sigla": "Ez 36, 16-17a. 18-28",
      "opis": "Nowe serce i nowy duch",
      "tekst": "Pan skierował do mnie te słowa:\n«Synu człowieczy, kiedy dom Izraela mieszkał na swojej ziemi, wówczas splugawili ją swym postępowaniem i swymi czynami. Wtedy wylałem na nich swe oburzenie z powodu krwi, którą w kraju przelali, i z powodu bożków, którymi go splugawili. I rozproszyłem ich pomiędzy pogańskie ludy, i rozpierzchli się po krajach, osądziłem ich według postępowania i czynów. W ten sposób przyszli do ludów pogańskich i tam, dokąd przybyli, bezcześcili święte imię moje, podczas gdy mówiono o nich: „To jest lud Pana, musieli się oni wyprowadzić ze swego kraju”. Wtedy zatroszczyłem się o święte me imię, które oni, Izraelici, zbezcześcili wśród ludów pogańskich, do których przybyli.\n\nDlatego mów do domu Izraela: Tak mówi Pan Bóg: Nie z waszego powodu to czynię, domu Izraela, ale dla świętego imienia mojego, które bezcześciliście wśród ludów pogańskich, do których przyszliście. Chcę uświęcić wielkie imię moje, które zbezczeszczone jest pośród ludów, zbezczeszczone przez was pośród nich, i poznają ludy, że Ja jestem Pan - mówi Pan Bóg - gdy okażę się Świętym względem was przed ich oczami.\n\nZabiorę was spośród ludów, zbiorę was ze wszystkich krajów i przyprowadzę was z powrotem do waszego kraju, pokropię was czystą wodą, abyście się stali czystymi, i oczyszczę was od wszelkiej zmazy i od wszystkich waszych bożków.\n\nI dam wam serca nowe i ducha nowego tchnę do waszego wnętrza, zabiorę wam serca kamienne, a dam wam serca z ciała. Ducha mojego chcę tchnąć w was i sprawić, byście żyli według mych nakazów i przestrzegali przykazań, i według nich postępowali. Wtedy będziecie mieszkać w kraju, który dałem waszym przodkom, i będziecie moim ludem, a Ja będę waszym Bogiem».\n\nOto słowo Boże."
    },
    {
      "typ": "7 PSALM RESPONSORYJNY",
      "sigla": "Ps 42 (41), 2-3. 5; Ps 43 (42), 3. 4 (R.: por. Ps 42 [41], 3ab)",
      "opis": "",
      "tekst": "Refren: Boga żywego pragnie moja dusza.\n\nJak łania pragnie wody ze strumieni, *\ntak dusza moja pragnie Ciebie, Boże.\nDusza moja Boga pragnie, Boga żywego, *\nkiedyż więc przyjdę i ujrzę oblicze Boże?\n\nRefren.\n\nRozpływa się we mnie moja dusza, *\ngdy wspominam, jak z tłumem kroczyłem\ndo Bożego domu,\nw świątecznym orszaku, *\nwśród głosów radości i chwały.\n\nRefren.\n\nZeślij światłość i wierność swoją, *\nniech one mnie wiodą,\nniech mnie zaprowadzą na Twą górę świętą *\ni do Twoich przybytków.\n\nRefren.\n\nI przystąpię do ołtarza Bożego, *\ndo Boga, który jest moim weselem i radością.\nI będę Cię chwalił przy dźwiękach lutni, *\nBoże, mój Boże!\n\nRefren."
    },
    {
      "typ": "ÓSME CZYTANIE (EPISTOŁA)",
      "sigla": "Rz 6, 3-11",
      "opis": "Nowe życie",
      "tekst": "Bracia:\nMy wszyscy, którzy otrzymaliśmy chrzest zanurzający w Chrystusa Jezusa, zostaliśmy zanurzeni w Jego śmierć. Zatem przez chrzest zanurzający nas w śmierć zostaliśmy razem z Nim pogrzebani po to, abyśmy i my postępowali w nowym życiu - jak Chrystus powstał z martwych dzięki chwale Ojca.\n\nJeżeli bowiem przez śmierć, podobną do Jego śmierci, zostaliśmy z Nim złączeni w jedno, to tak samo będziemy z Nim złączeni w jedno przez podobne zmartwychwstanie.\n\nTo wiedzcie, że dla zniszczenia ciała grzesznego dawny nasz człowiek został z Nim współukrzyżowany po to, byśmy już dłużej nie byli w niewoli grzechu. Kto bowiem umarł, został wyzwolony z grzechu.\n\nOtóż, jeżeli umarliśmy razem z Chrystusem, wierzymy, że z Nim również żyć będziemy, wiedząc, że Chrystus, powstawszy z martwych, już więcej nie umiera, śmierć nad Nim nie ma już władzy. Bo to, że umarł, umarł dla grzechu tylko raz, a że żyje, żyje dla Boga. Tak i wy rozumiejcie, że umarliście dla grzechu, żyjecie zaś dla Boga w Chrystusie Jezusie.\n\nOto słowo Boże."
    },
    {
      "typ": "8 PSALM RESPONSORYJNY",
      "sigla": "Ps 118 (117), 1b-2. 16-17. 22-23",
      "opis": "",
      "tekst": "Refren: Alleluja, alleluja, alleluja.\n\nDziękujcie Panu, bo jest dobry, *\nbo Jego łaska trwa na wieki.\nNiech dom Izraela głosi: *\n«Jego łaska na wieki».\n\nRefren.\n\nPrawica Pana wzniesiona wysoko, *\nprawica Pańska moc okazała.\nNie umrę, ale żyć będę *\ni głosić dzieła Pana.\n\nRefren.\n\nKamień odrzucony przez budujących *\nstał się kamieniem węgielnym.\nStało się to przez Pana *\ni cudem jest w naszych oczach.\n\nRefren."
    },
    {
      "typ": "EWANGELIA W ROKU A",
      "sigla": "Mt 28, 1-10",
      "opis": "Chrystus zmartwychwstał",
      "tekst": "Po upływie szabatu, o świcie pierwszego dnia tygodnia przyszła Maria Magdalena i druga Maria obejrzeć grób. A oto nastąpiło wielkie trzęsienie ziemi. Albowiem anioł Pański zstąpił z nieba, podszedł, odsunął kamień i usiadł na nim. Postać jego jaśniała jak błyskawica, a szaty jego były białe jak śnieg. Ze strachu przed nim zadrżeli strażnicy i stali się jakby martwi.\n\nAnioł zaś przemówił do niewiast: «Wy się nie bójcie! Gdyż wiem, że szukacie Jezusa Ukrzyżowanego. Nie ma Go tu, bo zmartwychwstał, jak zapowiedział. Przyjdźcie, zobaczcie miejsce, gdzie leżał. A idźcie szybko i powiedzcie Jego uczniom: „Powstał z martwych i oto udaje się przed wami do Galilei. Tam Go ujrzycie”. Oto, co wam powiedziałem».\n\nPośpiesznie więc oddaliły się od grobu, z bojaźnią i wielką radością, i pobiegły oznajmić to Jego uczniom.\n\nA oto Jezus stanął przed nimi, mówiąc: «Witajcie!» One podeszły do Niego, objęły Go za nogi i oddały Mu pokłon. A Jezus rzekł do nich: «Nie bójcie się! Idźcie i oznajmijcie moim braciom: niech udadzą się do Galilei, tam Mnie zobaczą».\n\nOto słowo Pańskie."
    },
    {
      "typ": "EWANGELIA W ROKU B",
      "sigla": "Mk 16, 1-7",
      "opis": "Ukrzyżowany Jezus z Nazaretu zmartwychwstał",
      "tekst": "Gdy minął szabat, Maria Magdalena, Maria, matka Jakuba, i Salome nakupiły wonności, żeby pójść namaścić Jezusa. Wczesnym rankiem w pierwszy dzień tygodnia przyszły do grobu, gdy słońce wzeszło. A mówiły między sobą: «Kto nam odsunie kamień z wejścia do grobu?» Gdy jednak spojrzały, zauważyły, że kamień został już odsunięty, a był bardzo duży. Weszły więc do grobu i ujrzały młodzieńca, siedzącego po prawej stronie, ubranego w białą szatę; i bardzo się przestraszyły. Lecz on rzekł do nich: «Nie bójcie się! Szukacie Jezusa z Nazaretu, ukrzyżowanego; powstał, nie ma Go tu. Oto miejsce, gdzie Go złożyli. A idźcie, powiedzcie Jego uczniom i Piotrowi: „Podąża przed wami do Galilei, tam Go ujrzycie, jak wam powiedział”».\n\nOto słowo Pańskie."
    },
    {
      "typ": "EWANGELIA W ROKU C",
      "sigla": "Łk 24, 1-12",
      "opis": "Dlaczego szukacie żyjącego wśród umarłych?",
      "tekst": "W pierwszy dzień tygodnia niewiasty poszły skoro świt do grobu, niosąc przygotowane wonności. Kamień zastały odsunięty od grobu. A skoro weszły, nie znalazły ciała Pana Jezusa. Gdy wobec tego były bezradne, nagle stanęło przed nimi dwóch mężczyzn w lśniących szatach. Przestraszone, pochyliły twarze ku ziemi, lecz tamci rzekli do nich: «Dlaczego szukacie żyjącego wśród umarłych? Nie ma Go tutaj; zmartwychwstał. Przypomnijcie sobie, jak wam mówił, będąc jeszcze w Galilei: „Syn Człowieczy musi być wydany w ręce grzeszników i ukrzyżowany, lecz trzeciego dnia zmartwychwstanie”». Wtedy przypomniały sobie Jego słowa, wróciwszy zaś od grobu, oznajmiły to wszystko Jedenastu i wszystkim pozostałym. A były to: Maria Magdalena, Joanna i Maria, matka Jakuba; i inne z nimi opowiadały to apostołom. Lecz słowa te wydały im się czczą gadaniną i nie dali im wiary.\n\nJednakże Piotr wybrał się i przybiegł do grobu; schyliwszy się, ujrzał same tylko płótna. I wrócił do siebie, dziwiąc się temu, co się stało.\n\nOto słowo Pańskie."
    }
  ],
  "piesniSugerowane": [
    {
      "numer": "179",
      "piesn": "Chrystus zmartwychwstał jest",
      "opis": "Radosny hymn wielkanocny, który po raz pierwszy rozbrzmiewa po uroczystym Gloria, ogłaszając Zmartwychwstanie Pańskie.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "193",
      "piesn": "Wesoły nam dzień dziś nastał",
      "opis": "Klasyczna i radosna pieśń wielkanocna, która w prostych słowach opiewa radość poranka Zmartwychwstania.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "174",
      "piesn": "Alleluja! Jezus żyje, już",
      "opis": "Pieśń jest radosnym ogłoszeniem prawdy o zmartwychwstaniu, co jest sercem Wigilii Paschalnej.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "197",
      "piesn": "Zmartwychpowstał Pan prawdziwie",
      "opis": "Pieśń jest uroczystym wyznaniem wiary w Zmartwychwstałego Pana, którego Ciało przyjmujemy jako zadatek naszego zmartwychwstania.",
      "moment": "komunia"
    },
    {
      "numer": "184",
      "piesn": "Nie zna śmierci Pan żywota",
      "opis": "Pieśń podkreśla zwycięstwo Chrystusa nad śmiercią, co jest źródłem nowego życia, które otrzymujemy w Komunii.",
      "moment": "komunia"
    },
    {
      "numer": "195",
      "piesn": "Wysławiajmy Chrysta Pana",
      "opis": "Pieśń wzywa do wysławiania Chrystusa, który starł śmierć i szatana, co jest owocem Jego Zmartwychwstania.",
      "moment": "komunia"
    },
    {
      "numer": "198",
      "piesn": "Zwycięzca śmierci",
      "opis": "Tryumfalny hymn o zwycięstwie Chrystusa nad śmiercią, piekłem i szatanem, idealny na dziękczynienie po Komunii Świętej.",
      "moment": "uwielbienie"
    },
    {
      "numer": "176",
      "piesn": "Alleluja... O dniu radosny",
      "opis": "Pieśń jest wyrazem radości i dziękczynienia za dar Zmartwychwstania, które jest fundamentem naszej wiary.",
      "moment": "uwielbienie"
    },
    {
      "numer": "189",
      "piesn": "Pan zmartwychwstał",
      "opis": "Radosna pieśń, w której łączymy się z aniołami w uwielbieniu Zmartwychwstałego Pana.",
      "moment": "uwielbienie"
    },
    {
      "numer": "191",
      "piesn": "Wesel się, Królowo miła",
      "opis": "Tradycyjna antyfona wielkanocna do Najświętszej Maryi Panny, która stanowi uroczyste zakończenie liturgii Wigilii Paschalnej.",
      "moment": "rozeslanie"
    },
    {
      "numer": "177",
      "piesn": "Alleluja, żyje Pan",
      "opis": "Radosna pieśń, która jest posłaniem do świata z nowiną, że Pan prawdziwie zmartwychwstał.",
      "moment": "rozeslanie"
    },
    {
      "numer": "192",
      "piesn": "Weselmy się, chrześcijanie",
      "opis": "Pieśń ta jest wezwaniem do radości ze Zmartwychwstania, które otworzyło nam bramy nieba.",
      "moment": "rozeslanie"
    },
    {
      "numer": "193",
      "piesn": "Wesoły nam dzień dziś nastał",
      "opis": "Klasyczna i radosna pieśń wielkanocna, która w prostych słowach opiewa radość poranka Zmartwychwstania.",
      "moment": "ogolne"
    },
    {
      "numer": "188",
      "piesn": "Otrzyjcie już łzy",
      "opis": "Pieśń ta bezpośrednio wzywa do porzucenia smutku Wielkiego Piątku na rzecz radości płynącej ze Zmartwychwstania.",
      "moment": "ogolne"
    },
    {
      "numer": "173",
      "piesn": "Alleluja! Biją dzwony",
      "opis": "Motyw bijących dzwonów doskonale oddaje atmosferę radości i triumfu, która wybucha w trakcie Wigilii Paschalnej.",
      "moment": "ogolne"
    },
    {
      "numer": "181",
      "piesn": "Już Zbawiciel, Jezus żyje",
      "opis": "Pieśń jest radosnym ogłoszeniem zwycięstwa Chrystusa nad śmiercią i piekłem.",
      "moment": "ogolne"
    },
    {
      "numer": "194",
      "piesn": "Wstał Pan Chrystus",
      "opis": "Prosta i radosna pieśń, która wzywa do chwalenia Syna Bożego w dzień Jego Zmartwychwstania.",
      "moment": "ogolne"
    }
  ]
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build\intermediates\assets\debug\mergeDebugAssets\Datowane\Czerwiec\11 czerwca - św. Barnaby Apostoła.json
treść:
{
  "url": "https://liturgia.wiara.pl/doc/432884.11-czerwca-sw-Barnaby-Apostola",
  "tytul_dnia": "11 czerwca - św. Barnaby Apostoła",
  "czy_datowany": true,
  "czytania": [
    {
      "typ": "PIERWSZE CZYTANIE",
      "sigla": "Dz 11,21b-26;13,1-3",
      "opis": "Barnaba, człowiek dobry i pełen Ducha Świętego",
      "tekst": "W Antiochii wielka liczba ludzi uwierzyła i nawróciła się do Pana. Wieść o tym doszła do uszu Kościoła w Jerozolimie. Wysłano do Antiochii Barnabę. Gdy on przybył i zobaczył działania łaski Bożej, ucieszył się i zachęcał, aby całym sercem wytrwali przy Panu; był bowiem człowiekiem dobrym i pełnym Ducha Świętego i wiary. Pozyskano wtedy wielką rzeszę dla Pana.\nUdał się też do Tarsu, aby odszukać Szawła. A kiedy go znalazł, przyprowadził do Antiochii i przez cały rok pracowali razem w Kościele, nauczając wielką rzeszę ludzi. W Antiochii też po raz pierwszy nazwano uczniów chrześcijanami.\nW Antiochii, w tamtejszym Kościele, byli prorokami i nauczycielami: Barnaba i Szymon zwany Niger, Lucjusz Cyrenejczyk i Manaen, który wychowywał się razem z Herodem tetrarchą, i Szaweł.\nGdy odprawiali publiczne nabożeństwo i pościli, rzekł Duch Święty: „Wyznaczcie mi już Barnabę i Szawła do dzieła, do którego ich powołałem”. Wtedy po poście i modlitwie oraz po włożeniu na nich rąk, wyprawili ich.\nOto słowo Boże."
    },
    {
      "typ": "PSALM RESPONSORYJNY",
      "sigla": "Ps 98,1.2-3ab.3c-4.5-6",
      "opis": "",
      "tekst": "Refren:\nPan Bóg objawił swoją sprawiedliwość.\nŚpiewajcie Panu pieśń nową,\nalbowiem uczynił cuda.\nZwycięstwo Mu zgotowała Jego prawica\ni święte ramię Jego.\nPan okazał swoje zbawienie,\nna oczach pogan objawił swoją sprawiedliwość.\nWspomniał na dobroć i na wierność swoją\ndla domu Izraela.\nUjrzały wszystkie krańce ziemi\nzbawienie Boga naszego.\nWołaj z radości na cześć Pana, cała ziemio,\ncieszcie się, weselcie i grajcie.\nŚpiewajcie Panu przy wtórze cytry,\nprzy wtórze cytry i przy dźwięku harfy,\nprzy trąbach i przy dźwięku rogu\nna oczach Pana, Króla, się radujcie."
    },
    {
      "typ": "AKLAMACJA",
      "sigla": "Mt 28,19a.20b",
      "opis": "Alleluja, alleluja, alleluja",
      "tekst": "Idźcie i nauczajcie wszystkie narody,\nJa jestem z wami przez wszystkie dni aż do skończenia świata."
    },
    {
      "typ": "EWANGELIA",
      "sigla": "Mt 10,7-13",
      "opis": "Wskazania na pracę apostolską",
      "tekst": "Jezus powiedział do swoich Apostołów:\n„Idźcie i głoście: Bliskie już jest królestwo niebieskie. Uzdrawiajcie chorych, wskrzeszajcie umarłych, oczyszczajcie trędowatych, wypędzajcie złe duchy. Darmo otrzymaliście, darmo dawajcie. Nie zdobywajcie złota ani srebra, ani miedzi do swych trzosów. Nie bierzcie na drogę torby ani dwóch sukien, ani sandałów, ani laski. Wart jest bowiem robotnik swej strawy.\nA gdy przyjdziecie do jakiegoś miasta albo wsi, wywiedzcie się, kto tam jest godny, i u niego zatrzymajcie się, dopóki nie wyjdziecie.\nWchodząc do domu, przywitajcie go pozdrowieniem. Jeśli dom na to zasługuje, niech zstąpi na niego pokój wasz; jeśli nie zasługuje, niech pokój wasz powróci do was”.\nOto słowo Pańskie."
    }
  ],
  "piesniSugerowane": [
    {
      "numer": "573",
      "piesn": "Chwała wam apostołowie",
      "opis": "Pieśń jest hołdem dla apostołów, głosicieli Ewangelii, co doskonale pasuje do wspomnienia św. Barnaby, nazwanego apostołem w Dziejach.",
      "moment": "wejscie"
    },
    {
      "numer": "224",
      "piesn": "Ludu kapłański",
      "opis": "Pieśń podkreśla misyjny charakter Kościoła, do którego budowania przyczynił się św. Barnaba, 'człowiek dobry i pełen Ducha Świętego'.",
      "moment": "wejscie"
    },
    {
      "numer": "591",
      "piesn": "Boże, obdarz Kościół Twój",
      "opis": "Jest to modlitwa za Kościół, do którego budowania i wzrostu w Antiochii przyczynił się św. Barnaba, co opisuje pierwsze czytanie.",
      "moment": "wejscie"
    },
    {
      "numer": "468",
      "piesn": "Sławimy dzisiaj zwycięstwo Barnaby",
      "opis": "Pieśń dedykowana patronowi dnia, która wspomina jego zapał misyjny i wierność Chrystusowi, idealnie pasuje na przygotowanie darów.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "695",
      "piesn": "Przyjmij, o Najświętszy Panie",
      "opis": "Wraz z darami chleba i wina składamy nasze życie, prosząc o łaskę wierności w głoszeniu Ewangelii na wzór św. Barnaby.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "586",
      "piesn": "Błogosław Panie nas",
      "opis": "Jest to modlitwa o błogosławieństwo w pracy głoszenia Ewangelii, do której powołany był św. Barnaba.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "242",
      "piesn": "Jeden chleb",
      "opis": "Eucharystia buduje jedność Kościoła, do którego wzrastania przyczynili się Barnaba i Szaweł, nauczając w Antiochii.",
      "moment": "komunia"
    },
    {
      "numer": "614",
      "piesn": "Panie, umocnij wiarę naszą",
      "opis": "Modlitwa o umocnienie wiary jest zawsze aktualna, a szczególnie w dniu wspomnienia tego, który 'pozyskał wielką rzeszę dla Pana'.",
      "moment": "komunia"
    },
    {
      "numer": "265",
      "piesn": "Panie, pragnienia ludzkich serc",
      "opis": "Jako Dobry Pasterz, Jezus zaspokaja głód naszych serc, karmiąc nas swoim Ciałem, byśmy mieli siłę do głoszenia Ewangelii.",
      "moment": "komunia"
    },
    {
      "numer": "622",
      "piesn": "Radośnie Panu hymn śpiewajmy",
      "opis": "Radosny hymn uwielbienia, który współbrzmi z psalmem wzywającym do głoszenia zbawienia i cudów Pana wszystkim narodom.",
      "moment": "uwielbienie"
    },
    {
      "numer": "597",
      "piesn": "Chwalcie Pana wszyscy",
      "opis": "Psalm responsoryjny wzywa do głoszenia chwały Pana, a ta pieśń jest majestatycznym hymnem uwielbienia za Jego zbawcze dzieła.",
      "moment": "uwielbienie"
    },
    {
      "numer": "604",
      "piesn": "Głoś imię Pana",
      "opis": "Pieśń jest wezwaniem do głoszenia chwały Pana, który objawił swoje zbawienie na oczach pogan, co było misją św. Barnaby.",
      "moment": "uwielbienie"
    },
    {
      "numer": "222",
      "piesn": "Idźcie na cały świat",
      "opis": "Treść pieśni jest bezpośrednim echem Ewangelii i aklamacji, w których Jezus posyła uczniów, by głosili Dobrą Nowinę.",
      "moment": "rozeslanie"
    },
    {
      "numer": "639",
      "piesn": "Nie rzucim, Chryste",
      "opis": "Pieśń jest wyznaniem wierności Chrystusowi i wierze, której świadkiem i głosicielem był św. Barnaba.",
      "moment": "rozeslanie"
    },
    {
      "numer": "311",
      "piesn": "Chrystus Wodzem",
      "opis": "Pieśń głosi królowanie Chrystusa, którego Ewangelię zaniósł poganom św. Barnaba.",
      "moment": "rozeslanie"
    },
    {
      "numer": "583",
      "piesn": "Zaśpiewajmy pieśń wdzięczności",
      "opis": "Pieśń dziękczynna za dar świętych patronów, którzy są dla nas wzorem i wstawiają się za nami u Boga.",
      "moment": "ogolne"
    },
    {
      "numer": "580",
      "piesn": "Szczęśliwi ludzie szukający Boga",
      "opis": "Pieśń o szukaniu Boga i Jego prawa, co było istotą życia i misji św. Barnaby.",
      "moment": "ogolne"
    },
    {
      "numer": "215",
      "piesn": "Duchu Najświętszy",
      "opis": "Modlitwa do Ducha Świętego, który powołał Barnabę i Szawła do dzieła, jest prośbą o Jego dary i prowadzenie.",
      "moment": "ogolne"
    },
    {
      "numer": "595",
      "piesn": "Cały świat niech śpiewa",
      "opis": "Psalm responsoryjny wzywa do radości i śpiewu na cześć Pana, a ta pieśń jest tego radosnym wykonaniem.",
      "moment": "ogolne"
    }
  ]
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build\intermediates\merged_manifest\debug\processDebugMainManifest\AndroidManifest.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.qjproject.liturgicalcalendar"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="26"
        android:targetSdkVersion="34" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />

    <permission
        android:name="com.qjproject.liturgicalcalendar.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        android:protectionLevel="signature" />

    <uses-permission android:name="com.qjproject.liturgicalcalendar.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" />

    <application
        android:name="com.qjproject.liturgicalcalendar.LiturgicalCalendarApp"
        android:allowBackup="true"
        android:appComponentFactory="androidx.core.app.CoreComponentFactory"
        android:debuggable="true"
        android:enableOnBackInvokedCallback="true"
        android:extractNativeLibs="false"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:testOnly="true"
        android:theme="@style/Theme.LiturgicalCalendar.Starting" >
        <activity
            android:name="com.qjproject.liturgicalcalendar.MainActivity"
            android:exported="true"
            android:theme="@style/Theme.LiturgicalCalendar.Starting" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="androidx.activity.ComponentActivity"
            android:exported="true" />
        <activity
            android:name="androidx.compose.ui.tooling.PreviewActivity"
            android:exported="true" />

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="com.qjproject.liturgicalcalendar.androidx-startup"
            android:exported="false" >
            <meta-data
                android:name="androidx.emoji2.text.EmojiCompatInitializer"
                android:value="androidx.startup" />
            <meta-data
                android:name="androidx.lifecycle.ProcessLifecycleInitializer"
                android:value="androidx.startup" />
            <meta-data
                android:name="androidx.profileinstaller.ProfileInstallerInitializer"
                android:value="androidx.startup" />
        </provider>

        <receiver
            android:name="androidx.profileinstaller.ProfileInstallReceiver"
            android:directBootAware="false"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.DUMP" >
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.INSTALL_PROFILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.SKIP_FILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.SAVE_PROFILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.BENCHMARK_OPERATION" />
            </intent-filter>
        </receiver>
    </application>

</manifest>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build\intermediates\merged_manifests\debug\processDebugManifest\AndroidManifest.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.qjproject.liturgicalcalendar"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="26"
        android:targetSdkVersion="34" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />

    <permission
        android:name="com.qjproject.liturgicalcalendar.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        android:protectionLevel="signature" />

    <uses-permission android:name="com.qjproject.liturgicalcalendar.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" />

    <application
        android:name="com.qjproject.liturgicalcalendar.LiturgicalCalendarApp"
        android:allowBackup="true"
        android:appComponentFactory="androidx.core.app.CoreComponentFactory"
        android:debuggable="true"
        android:enableOnBackInvokedCallback="true"
        android:extractNativeLibs="false"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:testOnly="true"
        android:theme="@style/Theme.LiturgicalCalendar.Starting" >
        <activity
            android:name="com.qjproject.liturgicalcalendar.MainActivity"
            android:exported="true"
            android:theme="@style/Theme.LiturgicalCalendar.Starting" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="androidx.activity.ComponentActivity"
            android:exported="true" />
        <activity
            android:name="androidx.compose.ui.tooling.PreviewActivity"
            android:exported="true" />

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="com.qjproject.liturgicalcalendar.androidx-startup"
            android:exported="false" >
            <meta-data
                android:name="androidx.emoji2.text.EmojiCompatInitializer"
                android:value="androidx.startup" />
            <meta-data
                android:name="androidx.lifecycle.ProcessLifecycleInitializer"
                android:value="androidx.startup" />
            <meta-data
                android:name="androidx.profileinstaller.ProfileInstallerInitializer"
                android:value="androidx.startup" />
        </provider>

        <receiver
            android:name="androidx.profileinstaller.ProfileInstallReceiver"
            android:directBootAware="false"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.DUMP" >
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.INSTALL_PROFILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.SKIP_FILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.SAVE_PROFILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.BENCHMARK_OPERATION" />
            </intent-filter>
        </receiver>
    </application>

</manifest>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build\intermediates\packaged_manifests\debug\processDebugManifestForPackage\AndroidManifest.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.qjproject.liturgicalcalendar"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="26"
        android:targetSdkVersion="34" />

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />

    <permission
        android:name="com.qjproject.liturgicalcalendar.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        android:protectionLevel="signature" />

    <uses-permission android:name="com.qjproject.liturgicalcalendar.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" />

    <application
        android:name="com.qjproject.liturgicalcalendar.LiturgicalCalendarApp"
        android:allowBackup="true"
        android:appComponentFactory="androidx.core.app.CoreComponentFactory"
        android:debuggable="true"
        android:enableOnBackInvokedCallback="true"
        android:extractNativeLibs="false"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:testOnly="true"
        android:theme="@style/Theme.LiturgicalCalendar.Starting" >
        <activity
            android:name="com.qjproject.liturgicalcalendar.MainActivity"
            android:exported="true"
            android:theme="@style/Theme.LiturgicalCalendar.Starting" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="androidx.activity.ComponentActivity"
            android:exported="true" />
        <activity
            android:name="androidx.compose.ui.tooling.PreviewActivity"
            android:exported="true" />

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="com.qjproject.liturgicalcalendar.androidx-startup"
            android:exported="false" >
            <meta-data
                android:name="androidx.emoji2.text.EmojiCompatInitializer"
                android:value="androidx.startup" />
            <meta-data
                android:name="androidx.lifecycle.ProcessLifecycleInitializer"
                android:value="androidx.startup" />
            <meta-data
                android:name="androidx.profileinstaller.ProfileInstallerInitializer"
                android:value="androidx.startup" />
        </provider>

        <receiver
            android:name="androidx.profileinstaller.ProfileInstallReceiver"
            android:directBootAware="false"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.DUMP" >
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.INSTALL_PROFILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.SKIP_FILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.SAVE_PROFILE" />
            </intent-filter>
            <intent-filter>
                <action android:name="androidx.profileinstaller.action.BENCHMARK_OPERATION" />
            </intent-filter>
        </receiver>
    </application>

</manifest>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\build\intermediates\packaged_manifests\debugAndroidTest\processDebugAndroidTestManifest\AndroidManifest.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.qjproject.liturgicalcalendar.test" >

    <uses-sdk
        android:minSdkVersion="26"
        android:targetSdkVersion="34" />

    <instrumentation
        android:name="androidx.test.runner.AndroidJUnitRunner"
        android:functionalTest="false"
        android:handleProfiling="false"
        android:label="Tests for com.qjproject.liturgicalcalendar"
        android:targetPackage="com.qjproject.liturgicalcalendar" />

    <uses-permission android:name="android.permission.REORDER_TASKS" />

    <queries>
        <package android:name="androidx.test.orchestrator" />
        <package android:name="androidx.test.services" />
        <package android:name="com.google.android.apps.common.testing.services" />
    </queries>

    <application
        android:debuggable="true"
        android:extractNativeLibs="false" >
        <uses-library android:name="android.test.runner" />

        <activity
            android:name="androidx.test.core.app.InstrumentationActivityInvoker$BootstrapActivity"
            android:exported="true"
            android:theme="@style/WhiteBackgroundTheme" >
            <intent-filter android:priority="-100" >
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="androidx.test.core.app.InstrumentationActivityInvoker$EmptyActivity"
            android:exported="true"
            android:theme="@style/WhiteBackgroundTheme" >
            <intent-filter android:priority="-100" >
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="androidx.test.core.app.InstrumentationActivityInvoker$EmptyFloatingActivity"
            android:exported="true"
            android:theme="@style/WhiteBackgroundDialogTheme" >
            <intent-filter android:priority="-100" >
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\androidTest\java\com\qjproject\liturgicalcalendar\ExampleInstrumentedTest.kt
treść:
package com.qjproject.liturgicalcalendar

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.qjproject.liturgicalcalendar", appContext.packageName)
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\AndroidManifest.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />

    <application
        android:name=".LiturgicalCalendarApp"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.LiturgicalCalendar.Starting"
        tools:targetApi="31"
        android:enableOnBackInvokedCallback="true">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.LiturgicalCalendar.Starting">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\assets\data\Triduum Paschalne\Wigilia Paschalna.json
treść:
{
  "url": "https://liturgia.wiara.pl/doc/2977736.Wigilia-Paschalna",
  "tytul_dnia": "Wigilia Paschalna",
  "czy_datowany": false,
  "czytania": [
    {
      "typ": "PIERWSZE CZYTANIE dłuższe",
      "sigla": "Rdz 1, 1 - 2, 2",
      "opis": "Stworzenie świata",
      "tekst": "Na początku Bóg stworzył niebo i ziemię. Ziemia zaś była bezładem i pustkowiem: ciemność była nad powierzchnią bezmiaru wód, a Duch Boży unosił się nad wodami.\n\nWtedy Bóg rzekł: «Niechaj się stanie światłość!» I stała się światłość. Bóg, widząc, że światłość jest dobra, oddzielił ją od ciemności. I nazwał Bóg światłość dniem, a ciemność nazwał nocą.\n\nI tak upłynął wieczór i poranek - dzień pierwszy.\n\nA potem Bóg rzekł: «Niechaj powstanie sklepienie w środku wód i niechaj oddzieli ono jedne wody od drugich! » Uczyniwszy to sklepienie, Bóg oddzielił wody pod sklepieniem od wód ponad sklepieniem; a gdy tak się stało, Bóg nazwał to sklepienie niebem.\n\nI tak upłynął wieczór i poranek - dzień drugi.\n\nA potem Bóg rzekł: «Niechaj zbiorą się wody spod nieba w jedno miejsce i niech się ukaże powierzchnia sucha!» A gdy tak się stało, Bóg nazwał tę suchą powierzchnię ziemią, a zbiorowisko wód nazwał morzem. Bóg, widząc, że były dobre, rzekł: «Niechaj ziemia wyda rośliny zielone: trawy dające nasiona, drzewa owocowe rodzące na ziemi według swego gatunku owoce, w których są nasiona». I tak się stało. Ziemia wydała rośliny zielone: trawę dającą nasienie według swego gatunku i drzewa rodzące owoce, w których było nasienie według ich gatunków. A Bóg widział, że były dobre.\n\nI tak upłynął wieczór i poranek - dzień trzeci.\n\nA potem Bóg rzekł: «Niechaj powstaną ciała niebieskie, świecące na sklepieniu nieba, aby oddzielały dzień od nocy, aby wyznaczały pory roku, dni i lata; aby były ciałami jaśniejącymi na sklepieniu nieba i aby świeciły nad ziemią». I tak się stało. Bóg uczynił dwa duże ciała jaśniejące: większe, aby rządziło dniem, i mniejsze, aby rządziło nocą, oraz gwiazdy. I umieścił je Bóg na sklepieniu nieba, aby świeciły nad ziemią; aby rządziły dniem i nocą i oddzielały światłość od ciemności. A widział Bóg, że były dobre.\n\nI tak upłynął wieczór i poranek - dzień czwarty.\n\nPotem Bóg rzekł: «Niechaj się zaroją wody od istot żywych, a ptactwo niechaj lata nad ziemią, pod sklepieniem nieba!» Tak stworzył Bóg wielkie potwory morskie i wszelkiego rodzaju pływające istoty żywe, którymi zaroiły się wody, oraz wszelkie ptactwo skrzydlate różnego rodzaju. Bóg, widząc, że były dobre, pobłogosławił je tymi słowami: «Bądźcie płodne i mnóżcie się, abyście zapełniały wody w morzach, a ptactwo niechaj się rozmnaża na ziemi».\n\nI tak upłynął wieczór i poranek - dzień piąty.\n\nPotem Bóg rzekł: «Niechaj ziemia wyda istoty żywe różnego rodzaju: bydło, zwierzęta pełzające i dzikie zwierzęta według ich rodzajów!» I stało się tak: Bóg uczynił różne rodzaje dzikich zwierząt, bydła i wszelkich zwierząt pełzających po ziemi. I widział Bóg, że były dobre.\n\nA wreszcie rzekł Bóg: «Uczyńmy człowieka na Nasz obraz, podobnego Nam. Niech panuje nad rybami morskimi, nad ptactwem podniebnym, nad bydłem, nad ziemią i nad wszystkimi zwierzętami pełzającymi po ziemi!» Stworzył więc Bóg człowieka na swój obraz, na obraz Boży go stworzył: stworzył mężczyznę i niewiastę.\n\nPo czym Bóg im błogosławił, mówiąc do nich: «Bądźcie płodni i rozmnażajcie się, abyście zaludnili ziemię i uczynili ją sobie poddaną; abyście panowali nad ptactwem podniebnym, nad rybami morskimi i nad wszystkimi zwierzętami pełzającymi po ziemi». I rzekł Bóg: «Oto wam daję wszelką roślinę przynoszącą ziarno po całej ziemi i wszelkie drzewo, którego owoc ma w sobie nasienie: dla was będą one pokarmem. A dla wszelkiego zwierzęcia polnego i dla wszelkiego ptactwa podniebnego, i dla wszystkiego, co się porusza po ziemi i ma w sobie pierwiastek życia, będzie pokarmem wszelka trawa zielona». I tak się stało. A Bóg widział, że wszystko, co uczynił, było bardzo dobre.\n\nI tak upłynął wieczór i poranek - dzień szósty.\n\nW ten sposób zostały ukończone niebo i ziemia oraz wszystkie zastępy jej stworzeń. A gdy ukończył w dniu szóstym swe dzieło, nad którym pracował, odpoczął dnia siódmego po całym swym trudzie, jaki podjął.\n\nOto słowo Boże."
    },
    {
      "typ": "PIERWSZE CZYTANIE krótsze",
      "sigla": "Rdz 1, 1. 26-31a",
      "opis": "",
      "tekst": "Na początku Bóg stworzył niebo i ziemię. Potem rzekł Bóg: «Uczyńmy człowieka na Nasz obraz, podobnego Nam. Niech panuje nad rybami morskimi, nad ptactwem podniebnym, nad bydłem, nad ziemią i nad wszystkimi zwierzętami pełzającymi po ziemi!» Stworzył więc Bóg człowieka na swój obraz, na obraz Boży go stworzył: stworzył mężczyznę i niewiastę.\n\nPo czym Bóg im błogosławił, mówiąc do nich: «Bądźcie płodni i rozmnażajcie się, abyście zaludnili ziemię i uczynili ją sobie poddaną; abyście panowali nad ptactwem podniebnym, nad rybami morskimi i nad wszystkimi zwierzętami pełzającymi po ziemi». I rzekł Bóg: «Oto wam daję wszelką roślinę przynoszącą ziarno po całej ziemi i wszelkie drzewo, którego owoc ma w sobie nasienie: dla was będą one pokarmem. A dla wszelkiego zwierzęcia polnego i dla wszelkiego ptactwa podniebnego, i dla wszystkiego, co się porusza po ziemi i ma w sobie pierwiastek życia, będzie pokarmem wszelka trawa zielona». I tak się stało. A Bóg widział, że wszystko, co uczynił, było bardzo dobre.\n\nOto słowo Boże."
    },
    {
      "typ": "1 PSALM RESPONSORYJNY",
      "sigla": "Ps 104 (103) lub Ps 33 (32)",
      "opis": "",
      "tekst": "Refren: Niech zstąpi Duch Twój i odnowi ziemię.\nBłogosław, duszo moja, Pana, *\nBoże mój, Panie, Ty jesteś bardzo wielki!\nOdziany w majestat i piękno, *\nświatłem okryty jak płaszczem.\nRefren.\nUmocniłeś fundamenty ziemi, *\nnie zachwieje się na wieki wieków.\nJak szatą okryłeś ją Wielką Głębią, *\nponad górami stanęły wody.\nRefren.\nTy zdroje kierujesz do strumieni, *\nktóre pośród gór się sączą.\nNad nimi mieszka ptactwo niebieskie *\ni śpiewa pośród gałęzi.\nRefren.\nZ Twoich komnat nawadniasz góry, *\nowocem dzieł Twoich syci się ziemia.\nKażesz rosnąć trawie dla bydła *\ni roślinom, by człowiekowi służyły.\nRefren.\nJak liczne są dzieła Twoje, Panie! *\nTy wszystko mądrze uczyniłeś,\nziemia jest pełna Twoich stworzeń. *\nBłogosław, duszo moja, Pana.\nRefren.\n\nALBO:\n\nRefren: Pełna jest ziemia łaskawości Pana.\nSłowo Pana jest prawe, *\na każde Jego dzieło godne zaufania.\nOn miłuje prawo i sprawiedliwość, *\nziemia jest pełna Jego łaski.\nRefren.\nPrzez słowo Pana powstały niebiosa, *\nwszystkie gwiazdy przez tchnienie ust Jego.\nOn morskie wody gromadzi jak w bukłaku, *\notchłanie oceanu w zbiornikach.\nRefren.\nBłogosławiony lud, którego Pan jest Bogiem, *\nnaród, który On wybrał na dziedzictwo dla siebie.\nPan spogląda z nieba, *\nwidzi wszystkich ludzi.\nRefren.\nDusza nasza oczekuje Pana, *\nOn jest naszą pomocą i tarczą.\nPanie, niech nas ogarnie Twoja łaska, *\nwedług nadziei pokładanej w Tobie.\nRefren."
    },
    {
      "typ": "DRUGIE CZYTANIE dłuższe",
      "sigla": "Rdz 22, 1-18",
      "opis": "Ofiara Abrahama",
      "tekst": "Bóg wystawił Abrahama na próbę i rzekł do niego: «Abrahamie!» A gdy on odpowiedział: «Oto jestem» - powiedział: «Weź twego syna jedynego, którego miłujesz, Izaaka, idź do kraju Moria i tam złóż go w ofierze na jednym z pagórków, jaki ci wskażę».\nNazajutrz rano Abraham osiodłał swego osła, zabrał z sobą dwóch swych ludzi i syna Izaaka, narąbał drzewa do spalenia ofiary i ruszył w drogę do miejscowości, o której mu Bóg powiedział. Na trzeci dzień Abraham, spojrzawszy, dostrzegł z daleka ową miejscowość. I wtedy rzekł do swych sług: «Zostańcie tu z osłem, ja zaś i chłopiec pójdziemy tam, aby oddać pokłon Bogu, a potem wrócimy do was».\nAbraham, zabrawszy drwa do spalenia ofiary, włożył je na syna swego, Izaaka, wziął do ręki ogień i nóż, po czym obaj się oddalili. Izaak odezwał się do swego ojca Abrahama: «Ojcze mój!» A gdy ten rzekł: «Oto jestem, mój synu» - zapytał: «Oto ogień i drwa, a gdzież jest jagnię na całopalenie?» Abraham odpowiedział: «Bóg upatrzy sobie jagnię na całopalenie, synu mój». I szli obydwaj dalej.\n\nA gdy przyszli na to miejsce, które Bóg wskazał, Abraham zbudował tam ołtarz, ułożył na nim drwa i związawszy syna swego, Izaaka, położył go na tych drwach na ołtarzu. Potem Abraham sięgnął ręką po nóż, aby zabić swego syna.\n\nAle wtedy Anioł Pański zawołał na niego z nieba i rzekł:\n\n«Abrahamie, Abrahamie!» A on rzekł: «Oto jestem». Anioł powiedział mu: «Nie podnoś ręki na chłopca i nie czyń mu nic złego! Teraz poznałem, że boisz się Boga, bo nie odmówiłeś Mi nawet twego jedynego syna». Abraham, obejrzawszy się poza siebie, spostrzegł barana uwikłanego rogami w zaroślach. Poszedł więc, wziął barana i złożył w ofierze całopalnej zamiast swego syna. I dał Abraham miejscu temu nazwę «Pan widzi». Stąd to mówi się dzisiaj: «Na wzgórzu Pan się ukazuje».\n\nPo czym Anioł Pański przemówił głośno z nieba do Abrahama po raz drugi: «Przysięgam na siebie, mówi Pan, że ponieważ uczyniłeś to, a nie odmówiłeś Mi syna twego jedynego, będę ci błogosławił i dam ci potomstwo tak liczne jak gwiazdy na niebie i jak ziarnka piasku na wybrzeżu morza; potomkowie twoi zdobędą warownie swych nieprzyjaciół. Wszystkie ludy ziemi będą sobie życzyć szczęścia takiego, jakie jest udziałem twego potomstwa, dlatego że usłuchałeś mego rozkazu».\n\nOto słowo Boże."
    },
    {
      "typ": "DRUGIE CZYTANIE krótsze",
      "sigla": "Rdz 22, 1-2. 9-13. 15-18",
      "opis": "",
      "tekst": "Bóg wystawił Abrahama na próbę i rzekł do niego: «Abrahamie!» A gdy on odpowiedział: «Oto jestem» - powiedział: «Weź twego syna jedynego, którego miłujesz, Izaaka, idź do kraju Moria i tam złóż go w ofierze na jednym z pagórków, jaki ci wskażę».\n\nA gdy przyszli na to miejsce, które Bóg wskazał, Abraham zbudował tam ołtarz, ułożył na nim drwa i związawszy syna swego, Izaaka, położył go na tych drwach na ołtarzu. Potem Abraham sięgnął ręką po nóż, aby zabić swego syna.\n\nAle wtedy Anioł Pański zawołał na niego z nieba i rzekł: «Abrahamie, Abrahamie!» A on rzekł: «Oto jestem». Anioł powiedział mu: «Nie podnoś ręki na chłopca i nie czyń mu nic złego! Teraz poznałem, że boisz się Boga, bo nie odmówiłeś Mi nawet twego jedynego syna». Abraham, obejrzawszy się poza siebie, spostrzegł barana uwikłanego rogami w zaroślach. Poszedł więc, wziął barana i złożył w ofierze całopalnej zamiast swego syna.\n\nPo czym Anioł Pański przemówił głośno z nieba do Abrahama po raz drugi: «Przysięgam na siebie, mówi Pan, że ponieważ uczyniłeś to, a nie odmówiłeś Mi syna twego jedynego, będę ci błogosławił i dam ci potomstwo tak liczne jak gwiazdy na niebie i jak ziarnka piasku na wybrzeżu morza; potomkowie twoi zdobędą warownie swych nieprzyjaciół. Wszystkie ludy ziemi będą sobie życzyć szczęścia takiego, jakie jest udziałem twego potomstwa, dlatego że usłuchałeś mego rozkazu».\n\nOto słowo Boże."
    },
    {
      "typ": "2 PSALM RESPONSORYJNY",
      "sigla": "Ps 16 (15), 5 i 8. 9-10. 11 (R.: por. 1b)",
      "opis": "",
      "tekst": "Refren: Strzeż mnie, o Boże, Tobie zaufałem.\n\nPan moim dziedzictwem i przeznaczeniem, *\nto On mój los zabezpiecza.\nZawsze stawiam sobie Pana przed oczy, *\nOn jest po mojej prawicy, nic mną nie zachwieje.\n\nRefren.\n\nDlatego cieszy się moje serce i dusza raduje, *\na ciało moje będzie spoczywać bezpiecznie,\nbo w kraju zmarłych duszy mej nie zostawisz *\ni nie dopuścisz, bym pozostał w grobie.\n\nRefren.\n\nTy ścieżkę życia mi ukażesz, *\npełnię radości przy Tobie\ni wieczne szczęście *\npo Twojej prawicy.\n\nRefren."
    },
    {
      "typ": "TRZECIE CZYTANIE",
      "sigla": "Wj 14, 15 - 15, 1a",
      "opis": "Przejście Izraela przez Morze Czerwone",
      "tekst": "Pan rzekł do Mojżesza: «Czemu głośno wołasz do Mnie? Powiedz Izraelitom, niech ruszają w drogę. Ty zaś podnieś swą laskę i wyciągnij rękę nad morze, i rozdziel je na dwoje, a wejdą Izraelici w środek morza na suchą ziemię. Ja natomiast uczynię upartymi serca Egipcjan tak, że pójdą za nimi. Wtedy okażę moją potęgę wobec faraona, całego wojska jego, rydwanów i wszystkich jego jeźdźców. A gdy okażę moją potęgę wobec faraona, jego rydwanów i jeźdźców, wtedy poznają Egipcjanie, że Ja jestem Pan».\n\nAnioł Boży, który szedł na przedzie wojsk izraelskich, zmienił miejsce i szedł na ich tyłach. Słup obłoku również przeszedł z przodu i zajął ich tyły, stając między wojskiem egipskim a wojskiem izraelskim. I tam był obłok ciemnością, tu zaś oświecał noc. I nie zbliżyli się jedni do drugich przez całą noc.\n\nMojżesz wyciągnął rękę nad morze, a Pan cofnął wody gwałtownym wiatrem wschodnim, który wiał przez całą noc, i uczynił morze suchą ziemią. Wody się rozstąpiły, a Izraelici szli przez środek morza po suchej ziemi, mając mur z wód po prawej i po lewej stronie. Egipcjanie ścigali ich. Wszystkie konie faraona, jego rydwany i jeźdźcy weszli za nimi w środek morza.\n\nO świcie spojrzał Pan ze słupa ognia i ze słupa obłoku na wojsko egipskie i zmusił je do ucieczki. I zatrzymał koła ich rydwanów, tak że z wielką trudnością mogli się naprzód posuwać. Egipcjanie krzyknęli: «Uciekajmy przed Izraelem, bo w jego obronie Pan walczy z Egipcjanami».\n\nA Pan rzekł do Mojżesza: «Wyciągnij rękę nad morze, aby wody zalały Egipcjan, ich rydwany i jeźdźców». Wyciągnął Mojżesz rękę nad morze, które o brzasku dnia wróciło na swoje miejsce. Egipcjanie, uciekając, biegli naprzeciw falom, i pogrążył ich Pan w środku morza. Powracające fale zatopiły rydwany i jeźdźców całego wojska faraona, którzy weszli w morze, ścigając tamtych; nie ocalał z nich ani jeden. Izraelici zaś szli po suchym dnie morskim, mając mur wodny po prawej i po lewej stronie.\n\nW tym to dniu wybawił Pan Izraela z rąk Egipcjan.\n\nI widzieli Izraelici martwych Egipcjan na brzegu morza. Gdy Izraelici zobaczyli wielkie dzieło, którego dokonał Pan wobec Egipcjan, ulękli się Pana i uwierzyli Jemu oraz Jego słudze Mojżeszowi. Wtedy Mojżesz i Izraelici razem z nim zaśpiewali taką oto pieśń ku czci Pana:"
    },
    {
      "typ": "3 PSALM RESPONSORYJNY",
      "sigla": "Wj 15, 1b-2c. 3-4. 5-6. 17-18 (R.: por. 1bc)",
      "opis": "",
      "tekst": "Refren: Śpiewajmy Panu, który moc okazał.\n\nZaśpiewam na cześć Pana, który okrył się sławą, *\ngdy konia i jeźdźca pogrążył w morskiej toni.\nPan jest moją mocą i źródłem męstwa, †\nJemu zawdzięczam moje ocalenie. *\nOn Bogiem moim, uwielbiać Go będę.\n\nRefren.\n\nPan wojownik potężny, *\n«Ten, który jest», brzmi Jego imię.\nRzucił w morze rydwany faraona i wojsko jego, *\nwybrani wodzowie legli w Morzu Czerwonym.\n\nRefren.\n\nPrzepaści ich ogarnęły, *\njak głaz runęli w głębinę.\nUwielbiona jest potęga prawicy Twej, Panie, *\nprawica Twa, o Panie, starła nieprzyjaciół.\n\nRefren.\n\nWprowadziłeś ich i osadziłeś *\nna górze Twojego dziedzictwa.\nW miejscu, które uczyniłeś swym mieszkaniem, †\nw świątyni zbudowanej Twoimi rękami, *\nPan jest Królem na zawsze i na wieki.\n\nRefren."
    },
    {
      "typ": "CZWARTE CZYTANIE",
      "sigla": "Iz 54, 4a. 5-14",
      "opis": "Trwałość przymierza",
      "tekst": "Nie lękaj się, Jerozolimo, bo małżonkiem twoim jest twój Stworzyciel, któremu na imię - Pan Zastępów; Odkupicielem twoim - Święty Izraela, nazywają Go Bogiem całej ziemi.\n\nZaiste, jak niewiastę porzuconą i zgnębioną na duchu, wezwał cię Pan. I jakby do porzuconej żony młodości mówi twój Bóg: Na krótką chwilę porzuciłem ciebie, ale z ogromną miłością cię przygarnę. W przystępie gniewu ukryłem przed tobą na krótko swe oblicze, ale w miłości wieczystej nad tobą się ulitowałem, mówi Pan, twój Odkupiciel.\n\nDzieje się ze Mną tak, jak za dni Noego, kiedy przysiągłem, że wody Noego nie spadną już nigdy na ziemię; tak teraz przysięgam, że się nie rozjątrzę na ciebie ani cię gromić nie będę. Bo góry mogą się poruszyć i pagórki się zachwiać, ale miłość moja nie odstąpi ciebie i nie zachwieje się moje przymierze pokoju, mówi Pan, który ma litość nad tobą.\n\nO nieszczęśliwa, wichrami smagana, niepocieszona! Oto ja osadzę twoje kamienie na malachicie i fundamenty twoje na szafirach. Uczynię blanki twych murów z rubinów, bramy twoje z górskiego kryształu, a z drogich kamieni - całe obramowanie twych murów. Wszyscy twoi synowie będą uczniami Pana, wielka będzie szczęśliwość twych dzieci. Będziesz mocno osadzona na sprawiedliwości. Daleka bądź od trwogi, bo nie masz się czego obawiać, i od przestrachu, bo nie ma on przystępu do ciebie.\n\nOto słowo Boże."
    },
    {
      "typ": "4 PSALM RESPONSORYJNY",
      "sigla": "Ps 30 (29), 2 i 4. 5-6. 11-12a i 13b (R.: 2a)",
      "opis": "",
      "tekst": "Refren: Sławię Cię, Panie, bo mnie wybawiłeś.\n\nSławię Cię, Panie, bo mnie wybawiłeś *\ni nie pozwoliłeś mym wrogom naśmiewać się ze mnie.\nPanie, mój Boże, †\nz krainy umarłych wywołałeś moją duszę *\ni ocaliłeś mi życie spośród schodzących do grobu.\n\nRefren.\n\nŚpiewajcie psalm, wszyscy miłujący Pana, *\ni pamiętajcie o Jego świętości.\nGniew Jego bowiem trwa tylko przez chwilę, †\na Jego łaska przez całe życie. *\nPłacz nadchodzi z wieczora, a rankiem wesele.\n\nRefren.\n\nWysłuchaj mnie, Panie, zmiłuj się nade mną, *\nPanie, bądź moją pomocą.\nZamieniłeś w taniec mój żałobny lament, *\nBoże mój i Panie, będę Cię sławił na wieki.\n\nRefren."
    },
    {
      "typ": "PIĄTE CZYTANIE",
      "sigla": "Iz 55, 1-11",
      "opis": "Nowe i wieczne przymierze",
      "tekst": "Tak mówi Pan:\n«Wszyscy spragnieni, przyjdźcie do wody, przyjdźcie, choć nie macie pieniędzy! Kupujcie i spożywajcie, dalejże, kupujcie bez pieniędzy i bez płacenia za wino i mleko! Czemu wydajecie pieniądze na to, co nie jest chlebem? I waszą pracę - na to, co nie nasyci? Słuchajcie Mnie, a jeść będziecie przysmaki i dusza wasza zakosztuje tłustych potraw.\n\nNakłońcie uszu i przyjdźcie do Mnie, posłuchajcie Mnie, a dusza wasza żyć będzie. Zawrę z wami wieczyste przymierze; niezawodne są łaski dla Dawida. Oto ustanowiłem go świadkiem dla ludów, dla ludów wodzem i rozkazodawcą. Oto zawezwiesz naród, którego nie znasz, i ci, którzy cię nie znają, przybiegną do ciebie ze względu na Pana, twojego Boga, przez wzgląd na Świętego Izraela, bo On ci dodał chwały.\n\nSzukajcie Pana, gdy się pozwala znaleźć, wzywajcie Go, dopóki jest blisko. Niechaj bezbożny porzuci swą drogę i człowiek nieprawy swoje knowania. Niech się nawróci do Pana, a Ten się nad nim zmiłuje, do Boga naszego, gdyż hojny jest w przebaczaniu. Bo myśli moje nie są myślami waszymi ani wasze drogi moimi drogami - mówi Pan. Bo jak niebiosa górują nad ziemią, tak drogi moje - nad waszymi drogami i myśli moje - nad myślami waszymi.\n\nZaiste, podobnie jak ulewa i śnieg spadają z nieba i tam nie powracają, dopóki nie nawodnią ziemi, nie użyźnią jej i nie zapewnią urodzaju, tak iż wydaje nasienie dla siewcy i chleb dla jedzącego, tak słowo, które wychodzi z ust moich, nie wraca do Mnie bezowocne, zanim wpierw nie dokona tego, co chciałem, i nie spełni pomyślnie swego posłannictwa».\n\nOto słowo Boże."
    },
    {
      "typ": "5 PSALM RESPONSORYJNY",
      "sigla": "Iz 12, 2. 3 i 4bcd. 5-6 (R.: por. 3)",
      "opis": "",
      "tekst": "Refren: Będziecie czerpać ze zdrojów zbawienia.\n\nOto Bóg jest moim zbawieniem! *\nJemu zaufam i bać się nie będę.\nPan jest moją pieśnią i mocą, *\ni On stał się moim zbawieniem.\n\nRefren.\n\nWy zaś z weselem czerpać będziecie wodę *\nze zdrojów zbawienia.\nChwalcie Pana, wzywajcie Jego imienia! †\nUkażcie narodom Jego dzieła, *\nprzypominajcie, że Jego imię jest chwalebne.\n\nRefren.\n\nŚpiewajcie Panu, bo czynów wspaniałych dokonał! *\nI cała ziemia niech o tym się dowie.\nWznoś okrzyki i wołaj radośnie, mieszkanko Syjonu, *\nbo wielki jest wśród ciebie Święty Izraela.\n\nRefren."
    },
    {
      "typ": "SZÓSTE CZYTANIE",
      "sigla": "Ba 3, 9-15. 32 - 4, 4",
      "opis": "Źródło mądrości",
      "tekst": "Bądź posłuszny, Izraelu, przykazaniom życiodajnym, nakłoń ucha, by poznać mądrość. Cóż się to stało, Izraelu, że jesteś w kraju nieprzyjaciół, wynędzniały w ziemi obcej, uważany za nieczystego na równi z umarłymi, zaliczony do tych, co schodzą do Otchłani? Opuściłeś źródło mądrości. Gdybyś chodził po drodze Bożej, mieszkałbyś w pokoju na wieki. Naucz się, gdzie jest mądrość, gdzie jest siła i rozum, a poznasz równocześnie, gdzie jest długie i szczęśliwe życie, gdzie jest światłość dla oczu i pokój. Lecz któż znalazł jej miejsce lub kto wszedł do jej skarbców?\n\nLecz zna ją Wszechwiedzący i zbadał ją swoim rozumem. Ten, który na czas bezkresny urządził ziemię i napełnił ją stworzeniami czworonożnymi, wysłał światło, i poszło, wezwał je, a ono posłuchało Go z drżeniem. Gwiazdy radośnie świecą na swoich strażnicach. Wezwał je. Odpowiedziały: «Jesteśmy». Z radością świecą swemu Stwórcy.\n\nOn jest Bogiem naszym. I żaden inny nie może z Nim się równać. Zbadał wszystkie drogi mądrości i dał ją słudze swemu, Jakubowi, i Izraelowi, umiłowanemu swojemu. Potem ukazała się ona na ziemi i zaczęła przebywać wśród ludzi. Tą mądrością jest księga przykazań Boga i Prawo trwające na wieki. Wszyscy, którzy się go trzymają, żyć będą. Którzy je zaniedbują, pomrą.\n\nNawróć się, Jakubie, trzymaj się go, chodź w blasku jego światła! Nie dawaj chwały swojej obcemu ani innemu narodowi twych przywilejów! Szczęśliwi jesteśmy, o Izraelu, że znane nam to, co się Bogu podoba.\n\nOto słowo Boże."
    },
    {
      "typ": "6 PSALM RESPONSORYJNY",
      "sigla": "Ps 19 (18), 8-9. 10-11 (R.: por. J 6, 68c)",
      "opis": "",
      "tekst": "Refren: Słowa Twe, Panie, dają życie wieczne.\n\nPrawo Pańskie jest doskonałe i pokrzepia duszę, *\nświadectwo Pana jest pewne, nierozważnego uczy mądrości.\nJego słuszne nakazy radują serce, *\njaśnieje przykazanie Pana i olśniewa oczy.\n\nRefren.\n\nBojaźń Pana jest szczera i trwa na wieki, *\nsądy Pana prawdziwe, wszystkie razem słuszne.\nCenniejsze nad złoto, nad złoto najczystsze, *\nsłodsze od miodu płynącego z plastra.\n\nRefren."
    },
    {
      "typ": "SIÓDME CZYTANIE",
      "sigla": "Ez 36, 16-17a. 18-28",
      "opis": "Nowe serce i nowy duch",
      "tekst": "Pan skierował do mnie te słowa:\n«Synu człowieczy, kiedy dom Izraela mieszkał na swojej ziemi, wówczas splugawili ją swym postępowaniem i swymi czynami. Wtedy wylałem na nich swe oburzenie z powodu krwi, którą w kraju przelali, i z powodu bożków, którymi go splugawili. I rozproszyłem ich pomiędzy pogańskie ludy, i rozpierzchli się po krajach, osądziłem ich według postępowania i czynów. W ten sposób przyszli do ludów pogańskich i tam, dokąd przybyli, bezcześcili święte imię moje, podczas gdy mówiono o nich: „To jest lud Pana, musieli się oni wyprowadzić ze swego kraju”. Wtedy zatroszczyłem się o święte me imię, które oni, Izraelici, zbezcześcili wśród ludów pogańskich, do których przybyli.\n\nDlatego mów do domu Izraela: Tak mówi Pan Bóg: Nie z waszego powodu to czynię, domu Izraela, ale dla świętego imienia mojego, które bezcześciliście wśród ludów pogańskich, do których przyszliście. Chcę uświęcić wielkie imię moje, które zbezczeszczone jest pośród ludów, zbezczeszczone przez was pośród nich, i poznają ludy, że Ja jestem Pan - mówi Pan Bóg - gdy okażę się Świętym względem was przed ich oczami.\n\nZabiorę was spośród ludów, zbiorę was ze wszystkich krajów i przyprowadzę was z powrotem do waszego kraju, pokropię was czystą wodą, abyście się stali czystymi, i oczyszczę was od wszelkiej zmazy i od wszystkich waszych bożków.\n\nI dam wam serca nowe i ducha nowego tchnę do waszego wnętrza, zabiorę wam serca kamienne, a dam wam serca z ciała. Ducha mojego chcę tchnąć w was i sprawić, byście żyli według mych nakazów i przestrzegali przykazań, i według nich postępowali. Wtedy będziecie mieszkać w kraju, który dałem waszym przodkom, i będziecie moim ludem, a Ja będę waszym Bogiem».\n\nOto słowo Boże."
    },
    {
      "typ": "7 PSALM RESPONSORYJNY",
      "sigla": "Ps 42 (41), 2-3. 5; Ps 43 (42), 3. 4 (R.: por. Ps 42 [41], 3ab)",
      "opis": "",
      "tekst": "Refren: Boga żywego pragnie moja dusza.\n\nJak łania pragnie wody ze strumieni, *\ntak dusza moja pragnie Ciebie, Boże.\nDusza moja Boga pragnie, Boga żywego, *\nkiedyż więc przyjdę i ujrzę oblicze Boże?\n\nRefren.\n\nRozpływa się we mnie moja dusza, *\ngdy wspominam, jak z tłumem kroczyłem\ndo Bożego domu,\nw świątecznym orszaku, *\nwśród głosów radości i chwały.\n\nRefren.\n\nZeślij światłość i wierność swoją, *\nniech one mnie wiodą,\nniech mnie zaprowadzą na Twą górę świętą *\ni do Twoich przybytków.\n\nRefren.\n\nI przystąpię do ołtarza Bożego, *\ndo Boga, który jest moim weselem i radością.\nI będę Cię chwalił przy dźwiękach lutni, *\nBoże, mój Boże!\n\nRefren."
    },
    {
      "typ": "ÓSME CZYTANIE (EPISTOŁA)",
      "sigla": "Rz 6, 3-11",
      "opis": "Nowe życie",
      "tekst": "Bracia:\nMy wszyscy, którzy otrzymaliśmy chrzest zanurzający w Chrystusa Jezusa, zostaliśmy zanurzeni w Jego śmierć. Zatem przez chrzest zanurzający nas w śmierć zostaliśmy razem z Nim pogrzebani po to, abyśmy i my postępowali w nowym życiu - jak Chrystus powstał z martwych dzięki chwale Ojca.\n\nJeżeli bowiem przez śmierć, podobną do Jego śmierci, zostaliśmy z Nim złączeni w jedno, to tak samo będziemy z Nim złączeni w jedno przez podobne zmartwychwstanie.\n\nTo wiedzcie, że dla zniszczenia ciała grzesznego dawny nasz człowiek został z Nim współukrzyżowany po to, byśmy już dłużej nie byli w niewoli grzechu. Kto bowiem umarł, został wyzwolony z grzechu.\n\nOtóż, jeżeli umarliśmy razem z Chrystusem, wierzymy, że z Nim również żyć będziemy, wiedząc, że Chrystus, powstawszy z martwych, już więcej nie umiera, śmierć nad Nim nie ma już władzy. Bo to, że umarł, umarł dla grzechu tylko raz, a że żyje, żyje dla Boga. Tak i wy rozumiejcie, że umarliście dla grzechu, żyjecie zaś dla Boga w Chrystusie Jezusie.\n\nOto słowo Boże."
    },
    {
      "typ": "8 PSALM RESPONSORYJNY",
      "sigla": "Ps 118 (117), 1b-2. 16-17. 22-23",
      "opis": "",
      "tekst": "Refren: Alleluja, alleluja, alleluja.\n\nDziękujcie Panu, bo jest dobry, *\nbo Jego łaska trwa na wieki.\nNiech dom Izraela głosi: *\n«Jego łaska na wieki».\n\nRefren.\n\nPrawica Pana wzniesiona wysoko, *\nprawica Pańska moc okazała.\nNie umrę, ale żyć będę *\ni głosić dzieła Pana.\n\nRefren.\n\nKamień odrzucony przez budujących *\nstał się kamieniem węgielnym.\nStało się to przez Pana *\ni cudem jest w naszych oczach.\n\nRefren."
    },
    {
      "typ": "EWANGELIA W ROKU A",
      "sigla": "Mt 28, 1-10",
      "opis": "Chrystus zmartwychwstał",
      "tekst": "Po upływie szabatu, o świcie pierwszego dnia tygodnia przyszła Maria Magdalena i druga Maria obejrzeć grób. A oto nastąpiło wielkie trzęsienie ziemi. Albowiem anioł Pański zstąpił z nieba, podszedł, odsunął kamień i usiadł na nim. Postać jego jaśniała jak błyskawica, a szaty jego były białe jak śnieg. Ze strachu przed nim zadrżeli strażnicy i stali się jakby martwi.\n\nAnioł zaś przemówił do niewiast: «Wy się nie bójcie! Gdyż wiem, że szukacie Jezusa Ukrzyżowanego. Nie ma Go tu, bo zmartwychwstał, jak zapowiedział. Przyjdźcie, zobaczcie miejsce, gdzie leżał. A idźcie szybko i powiedzcie Jego uczniom: „Powstał z martwych i oto udaje się przed wami do Galilei. Tam Go ujrzycie”. Oto, co wam powiedziałem».\n\nPośpiesznie więc oddaliły się od grobu, z bojaźnią i wielką radością, i pobiegły oznajmić to Jego uczniom.\n\nA oto Jezus stanął przed nimi, mówiąc: «Witajcie!» One podeszły do Niego, objęły Go za nogi i oddały Mu pokłon. A Jezus rzekł do nich: «Nie bójcie się! Idźcie i oznajmijcie moim braciom: niech udadzą się do Galilei, tam Mnie zobaczą».\n\nOto słowo Pańskie."
    },
    {
      "typ": "EWANGELIA W ROKU B",
      "sigla": "Mk 16, 1-7",
      "opis": "Ukrzyżowany Jezus z Nazaretu zmartwychwstał",
      "tekst": "Gdy minął szabat, Maria Magdalena, Maria, matka Jakuba, i Salome nakupiły wonności, żeby pójść namaścić Jezusa. Wczesnym rankiem w pierwszy dzień tygodnia przyszły do grobu, gdy słońce wzeszło. A mówiły między sobą: «Kto nam odsunie kamień z wejścia do grobu?» Gdy jednak spojrzały, zauważyły, że kamień został już odsunięty, a był bardzo duży. Weszły więc do grobu i ujrzały młodzieńca, siedzącego po prawej stronie, ubranego w białą szatę; i bardzo się przestraszyły. Lecz on rzekł do nich: «Nie bójcie się! Szukacie Jezusa z Nazaretu, ukrzyżowanego; powstał, nie ma Go tu. Oto miejsce, gdzie Go złożyli. A idźcie, powiedzcie Jego uczniom i Piotrowi: „Podąża przed wami do Galilei, tam Go ujrzycie, jak wam powiedział”».\n\nOto słowo Pańskie."
    },
    {
      "typ": "EWANGELIA W ROKU C",
      "sigla": "Łk 24, 1-12",
      "opis": "Dlaczego szukacie żyjącego wśród umarłych?",
      "tekst": "W pierwszy dzień tygodnia niewiasty poszły skoro świt do grobu, niosąc przygotowane wonności. Kamień zastały odsunięty od grobu. A skoro weszły, nie znalazły ciała Pana Jezusa. Gdy wobec tego były bezradne, nagle stanęło przed nimi dwóch mężczyzn w lśniących szatach. Przestraszone, pochyliły twarze ku ziemi, lecz tamci rzekli do nich: «Dlaczego szukacie żyjącego wśród umarłych? Nie ma Go tutaj; zmartwychwstał. Przypomnijcie sobie, jak wam mówił, będąc jeszcze w Galilei: „Syn Człowieczy musi być wydany w ręce grzeszników i ukrzyżowany, lecz trzeciego dnia zmartwychwstanie”». Wtedy przypomniały sobie Jego słowa, wróciwszy zaś od grobu, oznajmiły to wszystko Jedenastu i wszystkim pozostałym. A były to: Maria Magdalena, Joanna i Maria, matka Jakuba; i inne z nimi opowiadały to apostołom. Lecz słowa te wydały im się czczą gadaniną i nie dali im wiary.\n\nJednakże Piotr wybrał się i przybiegł do grobu; schyliwszy się, ujrzał same tylko płótna. I wrócił do siebie, dziwiąc się temu, co się stało.\n\nOto słowo Pańskie."
    }
  ],
  "piesniSugerowane": [
    {
      "numer": "179",
      "piesn": "Chrystus zmartwychwstał jest",
      "opis": "Radosny hymn wielkanocny, który po raz pierwszy rozbrzmiewa po uroczystym Gloria, ogłaszając Zmartwychwstanie Pańskie.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "193",
      "piesn": "Wesoły nam dzień dziś nastał",
      "opis": "Klasyczna i radosna pieśń wielkanocna, która w prostych słowach opiewa radość poranka Zmartwychwstania.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "174",
      "piesn": "Alleluja! Jezus żyje, już",
      "opis": "Pieśń jest radosnym ogłoszeniem prawdy o zmartwychwstaniu, co jest sercem Wigilii Paschalnej.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "197",
      "piesn": "Zmartwychpowstał Pan prawdziwie",
      "opis": "Pieśń jest uroczystym wyznaniem wiary w Zmartwychwstałego Pana, którego Ciało przyjmujemy jako zadatek naszego zmartwychwstania.",
      "moment": "komunia"
    },
    {
      "numer": "184",
      "piesn": "Nie zna śmierci Pan żywota",
      "opis": "Pieśń podkreśla zwycięstwo Chrystusa nad śmiercią, co jest źródłem nowego życia, które otrzymujemy w Komunii.",
      "moment": "komunia"
    },
    {
      "numer": "195",
      "piesn": "Wysławiajmy Chrysta Pana",
      "opis": "Pieśń wzywa do wysławiania Chrystusa, który starł śmierć i szatana, co jest owocem Jego Zmartwychwstania.",
      "moment": "komunia"
    },
    {
      "numer": "198",
      "piesn": "Zwycięzca śmierci",
      "opis": "Tryumfalny hymn o zwycięstwie Chrystusa nad śmiercią, piekłem i szatanem, idealny na dziękczynienie po Komunii Świętej.",
      "moment": "uwielbienie"
    },
    {
      "numer": "176",
      "piesn": "Alleluja... O dniu radosny",
      "opis": "Pieśń jest wyrazem radości i dziękczynienia za dar Zmartwychwstania, które jest fundamentem naszej wiary.",
      "moment": "uwielbienie"
    },
    {
      "numer": "189",
      "piesn": "Pan zmartwychwstał",
      "opis": "Radosna pieśń, w której łączymy się z aniołami w uwielbieniu Zmartwychwstałego Pana.",
      "moment": "uwielbienie"
    },
    {
      "numer": "191",
      "piesn": "Wesel się, Królowo miła",
      "opis": "Tradycyjna antyfona wielkanocna do Najświętszej Maryi Panny, która stanowi uroczyste zakończenie liturgii Wigilii Paschalnej.",
      "moment": "rozeslanie"
    },
    {
      "numer": "177",
      "piesn": "Alleluja, żyje Pan",
      "opis": "Radosna pieśń, która jest posłaniem do świata z nowiną, że Pan prawdziwie zmartwychwstał.",
      "moment": "rozeslanie"
    },
    {
      "numer": "192",
      "piesn": "Weselmy się, chrześcijanie",
      "opis": "Pieśń ta jest wezwaniem do radości ze Zmartwychwstania, które otworzyło nam bramy nieba.",
      "moment": "rozeslanie"
    },
    {
      "numer": "193",
      "piesn": "Wesoły nam dzień dziś nastał",
      "opis": "Klasyczna i radosna pieśń wielkanocna, która w prostych słowach opiewa radość poranka Zmartwychwstania.",
      "moment": "ogolne"
    },
    {
      "numer": "188",
      "piesn": "Otrzyjcie już łzy",
      "opis": "Pieśń ta bezpośrednio wzywa do porzucenia smutku Wielkiego Piątku na rzecz radości płynącej ze Zmartwychwstania.",
      "moment": "ogolne"
    },
    {
      "numer": "173",
      "piesn": "Alleluja! Biją dzwony",
      "opis": "Motyw bijących dzwonów doskonale oddaje atmosferę radości i triumfu, która wybucha w trakcie Wigilii Paschalnej.",
      "moment": "ogolne"
    },
    {
      "numer": "181",
      "piesn": "Już Zbawiciel, Jezus żyje",
      "opis": "Pieśń jest radosnym ogłoszeniem zwycięstwa Chrystusa nad śmiercią i piekłem.",
      "moment": "ogolne"
    },
    {
      "numer": "194",
      "piesn": "Wstał Pan Chrystus",
      "opis": "Prosta i radosna pieśń, która wzywa do chwalenia Syna Bożego w dzień Jego Zmartwychwstania.",
      "moment": "ogolne"
    }
  ]
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\assets\Datowane\Czerwiec\11 czerwca - św. Barnaby Apostoła.json
treść:
{
  "url": "https://liturgia.wiara.pl/doc/432884.11-czerwca-sw-Barnaby-Apostola",
  "tytul_dnia": "11 czerwca - św. Barnaby Apostoła",
  "czy_datowany": true,
  "czytania": [
    {
      "typ": "PIERWSZE CZYTANIE",
      "sigla": "Dz 11,21b-26;13,1-3",
      "opis": "Barnaba, człowiek dobry i pełen Ducha Świętego",
      "tekst": "W Antiochii wielka liczba ludzi uwierzyła i nawróciła się do Pana. Wieść o tym doszła do uszu Kościoła w Jerozolimie. Wysłano do Antiochii Barnabę. Gdy on przybył i zobaczył działania łaski Bożej, ucieszył się i zachęcał, aby całym sercem wytrwali przy Panu; był bowiem człowiekiem dobrym i pełnym Ducha Świętego i wiary. Pozyskano wtedy wielką rzeszę dla Pana.\nUdał się też do Tarsu, aby odszukać Szawła. A kiedy go znalazł, przyprowadził do Antiochii i przez cały rok pracowali razem w Kościele, nauczając wielką rzeszę ludzi. W Antiochii też po raz pierwszy nazwano uczniów chrześcijanami.\nW Antiochii, w tamtejszym Kościele, byli prorokami i nauczycielami: Barnaba i Szymon zwany Niger, Lucjusz Cyrenejczyk i Manaen, który wychowywał się razem z Herodem tetrarchą, i Szaweł.\nGdy odprawiali publiczne nabożeństwo i pościli, rzekł Duch Święty: „Wyznaczcie mi już Barnabę i Szawła do dzieła, do którego ich powołałem”. Wtedy po poście i modlitwie oraz po włożeniu na nich rąk, wyprawili ich.\nOto słowo Boże."
    },
    {
      "typ": "PSALM RESPONSORYJNY",
      "sigla": "Ps 98,1.2-3ab.3c-4.5-6",
      "opis": "",
      "tekst": "Refren:\nPan Bóg objawił swoją sprawiedliwość.\nŚpiewajcie Panu pieśń nową,\nalbowiem uczynił cuda.\nZwycięstwo Mu zgotowała Jego prawica\ni święte ramię Jego.\nPan okazał swoje zbawienie,\nna oczach pogan objawił swoją sprawiedliwość.\nWspomniał na dobroć i na wierność swoją\ndla domu Izraela.\nUjrzały wszystkie krańce ziemi\nzbawienie Boga naszego.\nWołaj z radości na cześć Pana, cała ziemio,\ncieszcie się, weselcie i grajcie.\nŚpiewajcie Panu przy wtórze cytry,\nprzy wtórze cytry i przy dźwięku harfy,\nprzy trąbach i przy dźwięku rogu\nna oczach Pana, Króla, się radujcie."
    },
    {
      "typ": "AKLAMACJA",
      "sigla": "Mt 28,19a.20b",
      "opis": "Alleluja, alleluja, alleluja",
      "tekst": "Idźcie i nauczajcie wszystkie narody,\nJa jestem z wami przez wszystkie dni aż do skończenia świata."
    },
    {
      "typ": "EWANGELIA",
      "sigla": "Mt 10,7-13",
      "opis": "Wskazania na pracę apostolską",
      "tekst": "Jezus powiedział do swoich Apostołów:\n„Idźcie i głoście: Bliskie już jest królestwo niebieskie. Uzdrawiajcie chorych, wskrzeszajcie umarłych, oczyszczajcie trędowatych, wypędzajcie złe duchy. Darmo otrzymaliście, darmo dawajcie. Nie zdobywajcie złota ani srebra, ani miedzi do swych trzosów. Nie bierzcie na drogę torby ani dwóch sukien, ani sandałów, ani laski. Wart jest bowiem robotnik swej strawy.\nA gdy przyjdziecie do jakiegoś miasta albo wsi, wywiedzcie się, kto tam jest godny, i u niego zatrzymajcie się, dopóki nie wyjdziecie.\nWchodząc do domu, przywitajcie go pozdrowieniem. Jeśli dom na to zasługuje, niech zstąpi na niego pokój wasz; jeśli nie zasługuje, niech pokój wasz powróci do was”.\nOto słowo Pańskie."
    }
  ],
  "piesniSugerowane": [
    {
      "numer": "573",
      "piesn": "Chwała wam apostołowie",
      "opis": "Pieśń jest hołdem dla apostołów, głosicieli Ewangelii, co doskonale pasuje do wspomnienia św. Barnaby, nazwanego apostołem w Dziejach.",
      "moment": "wejscie"
    },
    {
      "numer": "224",
      "piesn": "Ludu kapłański",
      "opis": "Pieśń podkreśla misyjny charakter Kościoła, do którego budowania przyczynił się św. Barnaba, 'człowiek dobry i pełen Ducha Świętego'.",
      "moment": "wejscie"
    },
    {
      "numer": "591",
      "piesn": "Boże, obdarz Kościół Twój",
      "opis": "Jest to modlitwa za Kościół, do którego budowania i wzrostu w Antiochii przyczynił się św. Barnaba, co opisuje pierwsze czytanie.",
      "moment": "wejscie"
    },
    {
      "numer": "468",
      "piesn": "Sławimy dzisiaj zwycięstwo Barnaby",
      "opis": "Pieśń dedykowana patronowi dnia, która wspomina jego zapał misyjny i wierność Chrystusowi, idealnie pasuje na przygotowanie darów.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "695",
      "piesn": "Przyjmij, o Najświętszy Panie",
      "opis": "Wraz z darami chleba i wina składamy nasze życie, prosząc o łaskę wierności w głoszeniu Ewangelii na wzór św. Barnaby.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "586",
      "piesn": "Błogosław Panie nas",
      "opis": "Jest to modlitwa o błogosławieństwo w pracy głoszenia Ewangelii, do której powołany był św. Barnaba.",
      "moment": "ofiarowanie"
    },
    {
      "numer": "242",
      "piesn": "Jeden chleb",
      "opis": "Eucharystia buduje jedność Kościoła, do którego wzrastania przyczynili się Barnaba i Szaweł, nauczając w Antiochii.",
      "moment": "komunia"
    },
    {
      "numer": "614",
      "piesn": "Panie, umocnij wiarę naszą",
      "opis": "Modlitwa o umocnienie wiary jest zawsze aktualna, a szczególnie w dniu wspomnienia tego, który 'pozyskał wielką rzeszę dla Pana'.",
      "moment": "komunia"
    },
    {
      "numer": "265",
      "piesn": "Panie, pragnienia ludzkich serc",
      "opis": "Jako Dobry Pasterz, Jezus zaspokaja głód naszych serc, karmiąc nas swoim Ciałem, byśmy mieli siłę do głoszenia Ewangelii.",
      "moment": "komunia"
    },
    {
      "numer": "622",
      "piesn": "Radośnie Panu hymn śpiewajmy",
      "opis": "Radosny hymn uwielbienia, który współbrzmi z psalmem wzywającym do głoszenia zbawienia i cudów Pana wszystkim narodom.",
      "moment": "uwielbienie"
    },
    {
      "numer": "597",
      "piesn": "Chwalcie Pana wszyscy",
      "opis": "Psalm responsoryjny wzywa do głoszenia chwały Pana, a ta pieśń jest majestatycznym hymnem uwielbienia za Jego zbawcze dzieła.",
      "moment": "uwielbienie"
    },
    {
      "numer": "604",
      "piesn": "Głoś imię Pana",
      "opis": "Pieśń jest wezwaniem do głoszenia chwały Pana, który objawił swoje zbawienie na oczach pogan, co było misją św. Barnaby.",
      "moment": "uwielbienie"
    },
    {
      "numer": "222",
      "piesn": "Idźcie na cały świat",
      "opis": "Treść pieśni jest bezpośrednim echem Ewangelii i aklamacji, w których Jezus posyła uczniów, by głosili Dobrą Nowinę.",
      "moment": "rozeslanie"
    },
    {
      "numer": "639",
      "piesn": "Nie rzucim, Chryste",
      "opis": "Pieśń jest wyznaniem wierności Chrystusowi i wierze, której świadkiem i głosicielem był św. Barnaba.",
      "moment": "rozeslanie"
    },
    {
      "numer": "311",
      "piesn": "Chrystus Wodzem",
      "opis": "Pieśń głosi królowanie Chrystusa, którego Ewangelię zaniósł poganom św. Barnaba.",
      "moment": "rozeslanie"
    },
    {
      "numer": "583",
      "piesn": "Zaśpiewajmy pieśń wdzięczności",
      "opis": "Pieśń dziękczynna za dar świętych patronów, którzy są dla nas wzorem i wstawiają się za nami u Boga.",
      "moment": "ogolne"
    },
    {
      "numer": "580",
      "piesn": "Szczęśliwi ludzie szukający Boga",
      "opis": "Pieśń o szukaniu Boga i Jego prawa, co było istotą życia i misji św. Barnaby.",
      "moment": "ogolne"
    },
    {
      "numer": "215",
      "piesn": "Duchu Najświętszy",
      "opis": "Modlitwa do Ducha Świętego, który powołał Barnabę i Szawła do dzieła, jest prośbą o Jego dary i prowadzenie.",
      "moment": "ogolne"
    },
    {
      "numer": "595",
      "piesn": "Cały świat niech śpiewa",
      "opis": "Psalm responsoryjny wzywa do radości i śpiewu na cześć Pana, a ta pieśń jest tego radosnym wykonaniem.",
      "moment": "ogolne"
    }
  ]
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\LiturgicalCalendarApp.kt
treść:
package com.qjproject.liturgicalcalendar

import android.app.Application
import com.qjproject.liturgicalcalendar.data.DataManager

class LiturgicalCalendarApp : Application() {
    override fun onCreate() {
        super.onCreate()
        // Inicjalizujemy i uruchamiamy proces kopiowania danych przy starcie aplikacji
        DataManager(this).copyAssetsToInternalStorageIfNeeded()
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\MainActivity.kt
treść:
package com.qjproject.liturgicalcalendar

import android.Manifest
import android.app.Activity
import android.content.Intent
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.BackHandler
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedContentTransitionScope
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.RowScope
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.navigation.NavType
import androidx.navigation.navArgument
import com.google.accompanist.navigation.animation.AnimatedNavHost
import com.google.accompanist.navigation.animation.composable
import com.google.accompanist.navigation.animation.rememberAnimatedNavController
import com.google.accompanist.pager.ExperimentalPagerApi
import com.google.accompanist.pager.HorizontalPager
import com.google.accompanist.pager.rememberPagerState
import com.qjproject.liturgicalcalendar.navigation.Screen
import com.qjproject.liturgicalcalendar.ui.components.AutoResizingText
import com.qjproject.liturgicalcalendar.ui.screens.browse.BrowseScreen
import com.qjproject.liturgicalcalendar.ui.screens.browse.BrowseViewModel
import com.qjproject.liturgicalcalendar.ui.screens.browse.BrowseViewModelFactory
import com.qjproject.liturgicalcalendar.ui.screens.calendar.CalendarScreen
import com.qjproject.liturgicalcalendar.ui.screens.calendar.CalendarViewModel
import com.qjproject.liturgicalcalendar.ui.screens.calendar.CalendarViewModelFactory
import com.qjproject.liturgicalcalendar.ui.screens.category.CategoryManagementScreen
import com.qjproject.liturgicalcalendar.ui.screens.category.CategoryManagementViewModelFactory
import com.qjproject.liturgicalcalendar.ui.screens.dateevents.DateEventsScreen
import com.qjproject.liturgicalcalendar.ui.screens.daydetails.DayDetailsScreen
import com.qjproject.liturgicalcalendar.ui.screens.search.SearchScreen
import com.qjproject.liturgicalcalendar.ui.screens.search.SearchViewModel
import com.qjproject.liturgicalcalendar.ui.screens.search.SearchViewModelFactory
import com.qjproject.liturgicalcalendar.ui.screens.search.SongSortMode
import com.qjproject.liturgicalcalendar.ui.screens.settings.SettingsScreen
import com.qjproject.liturgicalcalendar.ui.screens.settings.SettingsViewModel
import com.qjproject.liturgicalcalendar.ui.screens.settings.SettingsViewModelFactory
import com.qjproject.liturgicalcalendar.ui.screens.songcontent.SongContentScreen
import com.qjproject.liturgicalcalendar.ui.screens.songcontent.SongContentViewModel
import com.qjproject.liturgicalcalendar.ui.screens.songcontent.SongContentViewModelFactory
import com.qjproject.liturgicalcalendar.ui.screens.songdetails.SongDetailsScreen
import com.qjproject.liturgicalcalendar.ui.screens.songdetails.SongDetailsViewModel
import com.qjproject.liturgicalcalendar.ui.screens.songdetails.SongDetailsViewModelFactory
import com.qjproject.liturgicalcalendar.ui.theme.LiturgicalCalendarTheme
import com.qjproject.liturgicalcalendar.ui.theme.NavBarBackground
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import kotlinx.coroutines.launch
import java.net.URLDecoder
import kotlin.system.exitProcess

class MainActivity : ComponentActivity() {

    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (!isGranted) {
                finish()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        installSplashScreen()
        super.onCreate(savedInstanceState)

        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.P) {
            requestPermissionLauncher.launch(Manifest.permission.WRITE_EXTERNAL_STORAGE)
        }

        setContent {
            LiturgicalCalendarTheme {
                MainAppHost()
            }
        }
    }
}

fun restartApp(activity: Activity) {
    val intent = Intent(activity, MainActivity::class.java)
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
    activity.startActivity(intent)
    activity.finish()
    exitProcess(0)
}

@OptIn(ExperimentalAnimationApi::class)
@Composable
fun MainAppHost() {
    val navController = rememberAnimatedNavController()

    val safePopBackStack: () -> Unit = {
        navController.navigateUp()
    }

    AnimatedNavHost(navController = navController, startDestination = "main_tabs") {
        composable("main_tabs") {
            MainTabsScreen(navController = navController)
        }
        composable(
            route = Screen.DayDetails.route,
            arguments = listOf(navArgument("dayId") { type = NavType.StringType }),
            enterTransition = { slideIntoContainer(AnimatedContentTransitionScope.SlideDirection.Left, animationSpec = tween(300)) },
            popExitTransition = { slideOutOfContainer(AnimatedContentTransitionScope.SlideDirection.Right, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val encodedPath = backStackEntry.arguments?.getString("dayId")
            val decodedPath = encodedPath?.let { URLDecoder.decode(it, "UTF-8") }
            DayDetailsScreen(
                dayId = decodedPath,
                onNavigateBack = safePopBackStack,
                onNavigateToSongContent = { song, startInEdit ->
                    navController.navigate(Screen.SongContent.createRoute(song, startInEdit))
                }
            )
        }
        composable(
            route = Screen.DateEvents.route,
            arguments = listOf(
                navArgument("dateTitle") { type = NavType.StringType },
                navArgument("filePaths") { type = NavType.StringType }
            ),
            enterTransition = { slideIntoContainer(AnimatedContentTransitionScope.SlideDirection.Left, animationSpec = tween(300)) },
            popExitTransition = { slideOutOfContainer(AnimatedContentTransitionScope.SlideDirection.Right, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val dateTitle = backStackEntry.arguments?.getString("dateTitle")?.let { URLDecoder.decode(it, "UTF-8") } ?: ""
            val filePathsString = backStackEntry.arguments?.getString("filePaths") ?: ""
            val filePaths = Screen.DateEvents.decodePaths(filePathsString)

            DateEventsScreen(
                dateTitle = dateTitle,
                filePaths = filePaths,
                onNavigateToDay = { dayPath ->
                    navController.navigate(Screen.DayDetails.createRoute(dayPath))
                },
                onNavigateBack = safePopBackStack
            )
        }
        composable(
            route = Screen.SongDetails.route,
            arguments = listOf(
                navArgument("songTitle") { type = NavType.StringType },
                navArgument("siedlNum") { type = NavType.StringType; nullable = true },
                navArgument("sakNum") { type = NavType.StringType; nullable = true },
                navArgument("dnNum") { type = NavType.StringType; nullable = true }
            ),
            enterTransition = { slideIntoContainer(AnimatedContentTransitionScope.SlideDirection.Left, animationSpec = tween(300)) },
            popExitTransition = { slideOutOfContainer(AnimatedContentTransitionScope.SlideDirection.Right, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val context = LocalContext.current
            val factory = SongDetailsViewModelFactory(context, SavedStateHandle.createHandle(null, backStackEntry.arguments))
            val viewModel: SongDetailsViewModel = viewModel(factory = factory)

            SongDetailsScreen(
                viewModel = viewModel,
                onNavigateBack = safePopBackStack,
                onNavigateToContent = { song, startInEdit -> navController.navigate(Screen.SongContent.createRoute(song, startInEdit)) }
            )
        }
        composable(
            route = Screen.SongContent.route,
            arguments = listOf(
                navArgument("songTitle") { type = NavType.StringType },
                navArgument("siedlNum") { type = NavType.StringType; nullable = true },
                navArgument("sakNum") { type = NavType.StringType; nullable = true },
                navArgument("dnNum") { type = NavType.StringType; nullable = true },
                navArgument("editOnStart") {
                    type = NavType.BoolType
                    defaultValue = false
                }
            ),
            enterTransition = { slideIntoContainer(AnimatedContentTransitionScope.SlideDirection.Left, animationSpec = tween(300)) },
            popExitTransition = { slideOutOfContainer(AnimatedContentTransitionScope.SlideDirection.Right, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val startInEdit = backStackEntry.arguments?.getBoolean("editOnStart") ?: false
            val context = LocalContext.current
            val factory = SongContentViewModelFactory(context, SavedStateHandle.createHandle(null, backStackEntry.arguments))
            val viewModel: SongContentViewModel = viewModel(factory = factory)

            SongContentScreen(
                viewModel = viewModel,
                onNavigateBack = safePopBackStack,
                startInEditMode = startInEdit
            )
        }
        // --- POCZĄTEK ZMIANY ---
        composable(
            route = Screen.CategoryManagement.route,
            enterTransition = { slideIntoContainer(AnimatedContentTransitionScope.SlideDirection.Left, animationSpec = tween(300)) },
            popExitTransition = { slideOutOfContainer(AnimatedContentTransitionScope.SlideDirection.Right, animationSpec = tween(300)) }
        ) {
            val context = LocalContext.current
            val factory = CategoryManagementViewModelFactory(context)
            CategoryManagementScreen(
                viewModel = viewModel(factory = factory),
                onNavigateBack = safePopBackStack
            )
        }
        // --- KONIEC ZMIANY ---
    }
}

@OptIn(ExperimentalPagerApi::class, ExperimentalMaterial3Api::class)
@Composable
fun MainTabsScreen(navController: NavController) {
    val context = LocalContext.current
    val activity = (LocalContext.current as? Activity)
    val browseViewModel = viewModel<BrowseViewModel>(factory = BrowseViewModelFactory(context))
    val calendarViewModel = viewModel<CalendarViewModel>(factory = CalendarViewModelFactory(context))
    val settingsViewModel = viewModel<SettingsViewModel>(factory = SettingsViewModelFactory(context))
    val searchViewModel = viewModel<SearchViewModel>(factory = SearchViewModelFactory(context))


    val bottomNavItems = listOf(Screen.Search, Screen.Browse, Screen.Calendar, Screen.Settings)
    val pagerState = rememberPagerState(initialPage = 1)
    val coroutineScope = rememberCoroutineScope()

    val browseUiState by browseViewModel.uiState.collectAsState()
    val searchUiState by searchViewModel.uiState.collectAsState()

    val isSearchScreenActive = pagerState.currentPage == bottomNavItems.indexOf(Screen.Search)
    val isBrowseScreenActive = pagerState.currentPage == bottomNavItems.indexOf(Screen.Browse)
    val isCalendarScreenActive = pagerState.currentPage == bottomNavItems.indexOf(Screen.Calendar)

    var isCalendarMenuExpanded by remember { mutableStateOf(false) }

    BackHandler(enabled = true) {
        when {
            // Logika dla ekranu przeglądania
            isBrowseScreenActive -> {
                if (browseUiState.isEditMode) {
                    browseViewModel.onTryExitEditMode {}
                } else {
                    browseViewModel.onBackPress()
                }
            }
            // Dla pozostałych przypadków (inne ekrany bez otwartych menu), nie rób nic,
            // aby zapobiec zamknięciu aplikacji
            else -> {}
        }
    }

    Scaffold(
        topBar = {
            val title = when (bottomNavItems.getOrNull(pagerState.currentPage)) {
                Screen.Search -> "Wyszukaj pieśń"
                Screen.Browse -> browseUiState.screenTitle
                Screen.Calendar -> "Szukaj po dacie"
                Screen.Settings -> "Ustawienia"
                else -> ""
            }
            MainTopAppBar(
                title = title,
                showBackButton = isBrowseScreenActive && browseUiState.isBackArrowVisible,
                onBackClick = { browseViewModel.onBackPress() },
                isBrowseScreenInEditMode = isBrowseScreenActive && browseUiState.isEditMode,
                showEditButton = isBrowseScreenActive,
                onEditClick = { browseViewModel.onEnterEditMode() },
                onSaveClick = { browseViewModel.onSaveEditMode() },
                onCancelClick = { browseViewModel.onTryExitEditMode {} },
                isSaveEnabled = browseUiState.hasChanges,
                isCalendarScreenActive = isCalendarScreenActive,
                isSearchScreenActive = isSearchScreenActive,
                searchActions = {
                    var showSearchOptions by remember { mutableStateOf(false) }
                    Box {
                        IconButton(onClick = { showSearchOptions = true }) {
                            Icon(Icons.Default.MoreVert, contentDescription = "Opcje wyszukiwania")
                        }
                        DropdownMenu(
                            expanded = showSearchOptions,
                            onDismissRequest = { showSearchOptions = false }
                        ) {
                            Text("Szukaj w:", modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp), style = MaterialTheme.typography.labelMedium)
                            DropdownMenuItem(
                                text = { Text("Tytuł") },
                                onClick = { searchViewModel.onSearchInTitleChange(!searchUiState.searchInTitle) },
                                leadingIcon = { Checkbox(checked = searchUiState.searchInTitle, onCheckedChange = null) }
                            )
                            DropdownMenuItem(
                                text = { Text("Treść") },
                                onClick = { searchViewModel.onSearchInContentChange(!searchUiState.searchInContent) },
                                leadingIcon = { Checkbox(checked = searchUiState.searchInContent, onCheckedChange = null) }
                            )
                            if (searchUiState.results.isNotEmpty()) {
                                Divider(modifier = Modifier.padding(vertical = 4.dp))
                                Text("Sortuj:", modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp), style = MaterialTheme.typography.labelMedium)
                                Column(Modifier.selectableGroup()) {
                                    SongSortMode.values().forEach { mode ->
                                        DropdownMenuItem(
                                            text = { Text(if (mode == SongSortMode.Kategoria) "Kategoria" else mode.name) },
                                            onClick = {
                                                searchViewModel.onSortModeChange(mode)
                                                showSearchOptions = false
                                            },
                                            leadingIcon = { RadioButton(selected = (searchUiState.sortMode == mode), onClick = null) },
                                            modifier = Modifier.selectable(
                                                selected = (searchUiState.sortMode == mode),
                                                onClick = {
                                                    searchViewModel.onSortModeChange(mode)
                                                    showSearchOptions = false
                                                },
                                                role = Role.RadioButton
                                            )
                                        )
                                    }
                                }
                            }
                        }
                    }
                },
                calendarActions = {
                    Box {
                        IconButton(onClick = { isCalendarMenuExpanded = true }) {
                            Icon(Icons.Default.MoreVert, contentDescription = "Opcje")
                        }
                        DropdownMenu(
                            expanded = isCalendarMenuExpanded,
                            onDismissRequest = { isCalendarMenuExpanded = false }
                        ) {
                            DropdownMenuItem(
                                text = { Text("Pobierz aktualne dane") },
                                onClick = {
                                    calendarViewModel.forceRefreshData()
                                    isCalendarMenuExpanded = false
                                }
                            )
                        }
                    }
                }
            )
        },
        bottomBar = {
            Column {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(1.5.dp)
                        .background(
                            brush = Brush.verticalGradient(
                                colors = listOf(
                                    Color.Black.copy(alpha = 0.2f),
                                    Color.Transparent
                                )
                            )
                        )
                )
                NavigationBar(
                    containerColor = NavBarBackground
                ) {
                    bottomNavItems.forEachIndexed { index, screen ->
                        val isSelected = pagerState.currentPage == index
                        NavigationBarItem(
                            selected = isSelected,
                            onClick = {
                                if (isSelected) {
                                    when (screen) {
                                        is Screen.Browse -> browseViewModel.onResetToRoot()
                                        is Screen.Calendar -> calendarViewModel.resetToCurrentMonth()
                                        else -> {}
                                    }
                                } else {
                                    coroutineScope.launch { pagerState.animateScrollToPage(index) }
                                }
                            },
                            icon = { Icon(imageVector = screen.icon, contentDescription = screen.label) },
                            label = { Text(screen.label) },
                            colors = NavigationBarItemDefaults.colors(
                                selectedIconColor = SaturatedNavy,
                                selectedTextColor = SaturatedNavy,
                                indicatorColor = SaturatedNavy.copy(alpha = 0.15f),
                                unselectedIconColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                                unselectedTextColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
                            )
                        )
                    }
                }
            }
        }
    ) { innerPadding ->
        HorizontalPager(
            count = bottomNavItems.size,
            state = pagerState,
            modifier = Modifier.padding(innerPadding),
            userScrollEnabled = !browseUiState.isEditMode
        ) { pageIndex ->
            when (bottomNavItems[pageIndex]) {
                is Screen.Search -> SearchScreen(
                    viewModel = searchViewModel,
                    onNavigateToSong = { song ->
                        navController.navigate(Screen.SongDetails.createRoute(song))
                    }
                )
                is Screen.Browse -> BrowseScreen(
                    viewModel = browseViewModel,
                    onNavigateToDay = { dayPath ->
                        navController.navigate(Screen.DayDetails.createRoute(dayPath))
                    }
                )
                is Screen.Calendar -> CalendarScreen(
                    onNavigateToDay = { dayPath ->
                        navController.navigate(Screen.DayDetails.createRoute(dayPath))
                    },
                    onNavigateToDateEvents = { title, paths ->
                        navController.navigate(Screen.DateEvents.createRoute(title, paths))
                    }
                )
                is Screen.Settings -> SettingsScreen(
                    viewModel = settingsViewModel,
                    onRestartApp = {
                        if (activity != null) {
                            restartApp(activity)
                        }
                    },
                    // --- POCZĄTEK ZMIANY ---
                    onNavigateToCategoryManagement = {
                        navController.navigate(Screen.CategoryManagement.route)
                    }
                    // --- KONIEC ZMIANY ---
                )
                else -> {}
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainTopAppBar(
    title: String,
    showBackButton: Boolean = false,
    onBackClick: () -> Unit = {},
    isBrowseScreenInEditMode: Boolean = false,
    showEditButton: Boolean = false,
    onEditClick: () -> Unit = {},
    onSaveClick: () -> Unit = {},
    onCancelClick: () -> Unit = {},
    isSaveEnabled: Boolean = false,
    isCalendarScreenActive: Boolean = false,
    isSearchScreenActive: Boolean = false,
    searchActions: @Composable RowScope.() -> Unit = {},
    calendarActions: @Composable RowScope.() -> Unit = {}
) {
    Column {
        CenterAlignedTopAppBar(
            title = {
                AutoResizingText(
                    text = title,
                    style = MaterialTheme.typography.titleLarge,
                    textAlign = TextAlign.Center
                )
            },
            navigationIcon = {
                if (isBrowseScreenInEditMode) {
                    IconButton(onClick = onCancelClick) {
                        Icon(Icons.Default.Close, "Anuluj edycję")
                    }
                } else if (showBackButton) {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć")
                    }
                } else {
                    Spacer(Modifier.width(48.dp))
                }
            },
            actions = {
                if (isSearchScreenActive) {
                    searchActions()
                } else if (isBrowseScreenInEditMode) {
                    IconButton(onClick = onSaveClick, enabled = isSaveEnabled) {
                        Icon(Icons.Default.Check, "Zapisz zmiany", tint = if (isSaveEnabled) MaterialTheme.colorScheme.primary else Color.Gray)
                    }
                } else if (showEditButton) {
                    IconButton(onClick = onEditClick) {
                        Icon(Icons.Default.Edit, "Edytuj")
                    }
                } else if (isCalendarScreenActive) {
                    calendarActions()
                } else {
                    Spacer(Modifier.width(48.dp))
                }
            },
            colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                containerColor = MaterialTheme.colorScheme.background,
                titleContentColor = MaterialTheme.colorScheme.primary,
                navigationIconContentColor = MaterialTheme.colorScheme.primary
            ),
            windowInsets = TopAppBarDefaults.windowInsets
        )
        Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\Category.kt
treść:
package com.qjproject.liturgicalcalendar.data

import kotlinx.serialization.Serializable

@Serializable
data class Category(
    val nazwa: String,
    val skrot: String
)

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\DataManager.kt
treść:
package com.qjproject.liturgicalcalendar.data

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

class DataManager(private val context: Context) {

    private val prefs: SharedPreferences = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
    private val dataVersionKey = "data_version"
    // --- POCZĄTEK ZMIANY ---
    // Zwiększono wersję, aby wymusić ponowne skopiowanie danych, w tym nowego pliku kategorii
    private val currentDataVersion = 4
    // --- KONIEC ZMIANY ---

    fun copyAssetsToInternalStorageIfNeeded() {
        val installedVersion = prefs.getInt(dataVersionKey, 0)
        if (installedVersion >= currentDataVersion) {
            Log.d("DataManager", "Dane są aktualne (wersja $installedVersion). Kopiowanie pominięte.")
            return
        }

        Log.d("DataManager", "Rozpoczynanie kopiowania danych z assets do pamięci wewnętrznej...")
        try {
            val internalRoot = context.filesDir
            Log.d("DataManager", "Katalog docelowy: ${internalRoot.absolutePath}")

            // Czyszczenie starych danych
            internalRoot.listFiles()?.forEach { file ->
                if (file.isDirectory && (file.name == "data" || file.name == "Datowane")) {
                    Log.d("DataManager", "Usuwanie starego katalogu: ${file.name}")
                    file.deleteRecursively()
                }
                // --- POCZĄTEK ZMIANY ---
                // Usuń także stare pliki json, jeśli istnieją
                if (file.isFile && (file.name == "piesni.json" || file.name == "kategorie.json")) {
                    Log.d("DataManager", "Usuwanie starego pliku: ${file.name}")
                    file.delete()
                }
                // --- KONIEC ZMIANY ---
            }

            // --- POCZĄTEK ZMIANY ---
            // Zaktualizowano logikę, aby kopiować zarówno katalogi, jak i pojedyncze pliki z roota
            val assetsToCopy = context.assets.list("")?.filter { it == "data" || it == "Datowane" || it == "piesni.json" || it == "kategorie.json" } ?: emptyList()
            assetsToCopy.forEach { assetName ->
                val isDirectory = try {
                    context.assets.list(assetName)?.isNotEmpty() == true
                } catch (e: IOException) {
                    false
                }

                if (isDirectory) {
                    val destDir = File(internalRoot, assetName)
                    if (!destDir.exists()) destDir.mkdirs()
                    Log.d("DataManager", "Tworzenie katalogu głównego: ${destDir.absolutePath}")
                    copyAssetDir(assetName, destDir)
                } else {
                    copyAssetFile(assetName, internalRoot)
                }
            }
            // --- KONIEC ZMIANY ---

            prefs.edit().putInt(dataVersionKey, currentDataVersion).apply()
            Log.d("DataManager", "Kopiowanie danych zakończone sukcesem. Ustawiono wersję na $currentDataVersion.")
        } catch (e: IOException) {
            Log.e("DataManager", "Błąd podczas kopiowania danych z assets.", e)
        }
    }

    private fun copyAssetDir(assetPath: String, destDir: File) {
        val assets = context.assets.list(assetPath) ?: return

        assets.forEach { assetName ->
            val currentAssetPath = "$assetPath/$assetName"
            val isDirectory = try {
                context.assets.list(currentAssetPath)?.isNotEmpty() == true
            } catch (e: IOException) {
                false
            }

            if (isDirectory) {
                val newDestDir = File(destDir, assetName)
                if (!newDestDir.exists()) newDestDir.mkdirs()
                Log.d("DataManager", "Tworzenie podkatalogu: ${newDestDir.absolutePath}")
                copyAssetDir(currentAssetPath, newDestDir)
            } else {
                copyAssetFile(currentAssetPath, destDir)
            }
        }
    }

    private fun copyAssetFile(assetPath: String, destDir: File) {
        val destFile = File(destDir, File(assetPath).name)
        Log.d("DataManager", "Kopiowanie pliku: $assetPath -> ${destFile.absolutePath}")
        try {
            context.assets.open(assetPath).use { inputStream ->
                FileOutputStream(destFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
            }
        } catch (e: IOException) {
            Log.e("DataManager", "Nie udało się skopiować pliku $assetPath", e)
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\DayData.kt
treść:
package com.qjproject.liturgicalcalendar.data

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class DayData(
    @SerialName("url") val urlCzytania: String? = null,
    @SerialName("tytul_dnia") val tytulDnia: String,
    @SerialName("czy_datowany") val czyDatowany: Boolean,
    val czytania: List<Reading>,
    @SerialName("piesniSugerowane") val piesniSugerowane: List<SuggestedSong?>? = null
)

@Serializable
data class Reading(
    val typ: String,
    val sigla: String? = "",
    val opis: String? = "",
    val tekst: String
)

@Serializable
data class SuggestedSong(
    val numer: String,
    val piesn: String,
    val opis: String,
    val moment: String
)

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\FileSystemItem.kt
treść:
package com.qjproject.liturgicalcalendar.data

data class FileSystemItem(
    val name: String,
    val isDirectory: Boolean,
    val path: String // Względna ścieżka od katalogu głównego aplikacji (filesDir)
)

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\FileSystemRepository.kt
treść:
package com.qjproject.liturgicalcalendar.data

import android.content.Context
import android.net.Uri
import android.os.Environment
import android.util.Log
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import net.lingala.zip4j.ZipFile
import java.io.File
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.io.IOException
import java.text.SimpleDateFormat
import java.time.Month
import java.time.format.TextStyle
import java.util.*
import kotlin.Result

private const val ORDER_FILE_NAME = ".directory_order.json"

@Serializable
private data class DirectoryOrder(val order: List<String>)

private data class FoundImportFiles(
    val dataDir: File,
    val datowaneDir: File,
    val songFile: File
)

private val fileSystemItemNaturalComparator = compareBy<FileSystemItem> { !it.isDirectory }
    .then(Comparator { a, b ->
        val numA = a.name.takeWhile { it.isDigit() }.toIntOrNull()
        val numB = b.name.takeWhile { it.isDigit() }.toIntOrNull()

        if (numA != null && numB != null) {
            val numCompare = numA.compareTo(numB)
            if (numCompare != 0) numCompare else a.name.compareTo(b.name, ignoreCase = true)
        } else if (numA != null) {
            -1 // Elementy z numerami na początku
        } else if (numB != null) {
            1 // Elementy z numerami na początku
        } else {
            // Brak numerów, sortowanie alfabetyczne
            a.name.compareTo(b.name, ignoreCase = true)
        }
    })


class FileSystemRepository(val context: Context) {

    private val json = Json {
        ignoreUnknownKeys = true
        prettyPrint = true
        encodeDefaults = true
        coerceInputValues = true
    }
    private val internalStorageRoot = context.filesDir

    private var songListCache: List<Song>? = null
    private var categoryListCache: List<Category>? = null

    fun invalidateSongCache() {
        songListCache = null
    }

    // --- POCZĄTEK ZMIANY ---
    fun invalidateCategoryCache() {
        categoryListCache = null
    }
    // --- KONIEC ZMIANY ---

    fun getAllDayFilePaths(): List<String> {
        val paths = mutableListOf<String>()
        val dataDir = File(internalStorageRoot, "data")
        val datowaneDir = File(internalStorageRoot, "Datowane")

        fun findJsonFiles(directory: File) {
            directory.walkTopDown().forEach { file ->
                if (file.isFile && file.extension == "json" && file.name != "piesni.json" && file.name != "kategorie.json") {
                    paths.add(file.absolutePath.removePrefix(internalStorageRoot.absolutePath + "/"))
                }
            }
        }

        if (dataDir.exists() && dataDir.isDirectory) {
            findJsonFiles(dataDir)
        }
        if (datowaneDir.exists() && datowaneDir.isDirectory) {
            findJsonFiles(datowaneDir)
        }

        return paths
    }


    fun getItems(path: String): List<FileSystemItem> {
        return try {
            val directory = File(internalStorageRoot, path)
            val allFiles = directory.listFiles() ?: return emptyList()

            val itemsOnDisk = allFiles
                .filter { it.name != ORDER_FILE_NAME }
                .map { item ->
                    val itemName = if (item.isDirectory) item.name else item.nameWithoutExtension
                    val itemPath = item.absolutePath.removePrefix(internalStorageRoot.absolutePath + "/")
                    FileSystemItem(name = itemName, isDirectory = item.isDirectory, path = itemPath)
                }.toMutableList()

            val orderFile = File(directory, ORDER_FILE_NAME)
            if (orderFile.exists()) {
                try {
                    val jsonString = orderFile.readText()
                    val storedOrder = json.decodeFromString<DirectoryOrder>(jsonString).order

                    val orderedItems = mutableListOf<FileSystemItem>()
                    val itemsOnDiskMap = itemsOnDisk.associateBy { it.name }
                    val remainingItems = itemsOnDisk.toMutableSet()

                    storedOrder.forEach { name ->
                        itemsOnDiskMap[name]?.let {
                            orderedItems.add(it)
                            remainingItems.remove(it)
                        }
                    }
                    orderedItems.addAll(remainingItems.sortedWith(fileSystemItemNaturalComparator))
                    orderedItems
                } catch (e: Exception) {
                    Log.e("FileSystemRepository", "Błąd odczytu pliku kolejności dla $path. Sortowanie alfabetyczne.", e)
                    itemsOnDisk.sortedWith(fileSystemItemNaturalComparator)
                }
            } else {
                itemsOnDisk.sortedWith(fileSystemItemNaturalComparator)
            }
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas pobierania elementów z $path", e)
            emptyList()
        }
    }

    fun getDayData(path: String): DayData? {
        try {
            val file = File(internalStorageRoot, path)
            if (!file.exists()) {
                Log.e("FileSystemRepository", "Plik nie istnieje: ${file.absolutePath}")
                return null
            }
            val jsonString = file.bufferedReader().use { it.readText() }
            if (jsonString.isBlank()) {
                Log.w("FileSystemRepository", "Pusty plik JSON, pomijanie: $path")
                return null
            }
            return json.decodeFromString<DayData>(jsonString)
        } catch (e: Exception) {
            Log.w("FileSystemRepository", "Błąd podczas odczytu lub parsowania pliku: $path. Powód: ${e.message}")
            return null
        }
    }

    fun getSongList(): List<Song> {
        songListCache?.let { return it }
        return try {
            val file = File(internalStorageRoot, "piesni.json")
            if (!file.exists()) {
                Log.e("FileSystemRepository", "Krytyczny błąd: Plik 'piesni.json' nie istnieje w pamięci wewnętrznej.")
                return emptyList()
            }
            val jsonString = file.bufferedReader().use { it.readText() }
            val songs = json.decodeFromString<List<Song>>(jsonString)
            songListCache = songs
            songs
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas wczytywania piesni.json z pamięci wewnętrznej", e)
            emptyList()
        }
    }

    fun saveSongList(songs: List<Song>): Result<Unit> {
        return try {
            val file = File(internalStorageRoot, "piesni.json")
            file.parentFile?.mkdirs()
            val jsonString = json.encodeToString(songs)
            file.writeText(jsonString)
            songListCache = songs // Zaktualizuj bufor
            Log.d("FileSystemRepository", "Zapisano pomyślnie listę pieśni do: ${file.absolutePath}")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas zapisywania listy pieśni", e)
            Result.failure(e)
        }
    }

    fun getCategoryList(): List<Category> {
        categoryListCache?.let { return it }
        return try {
            val file = File(internalStorageRoot, "kategorie.json")
            if (!file.exists()) {
                Log.e("FileSystemRepository", "Krytyczny błąd: Plik 'kategorie.json' nie istnieje w pamięci wewnętrznej.")
                return emptyList()
            }
            val jsonString = file.bufferedReader().use { it.readText() }
            val categories = json.decodeFromString<List<Category>>(jsonString)
            categoryListCache = categories
            categories
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas wczytywania kategorie.json z pamięci wewnętrznej", e)
            emptyList()
        }
    }

    fun saveCategoryList(categories: List<Category>): Result<Unit> {
        return try {
            val file = File(internalStorageRoot, "kategorie.json")
            val jsonString = json.encodeToString(categories)
            file.writeText(jsonString)
            categoryListCache = categories // Zaktualizuj bufor
            Log.d("FileSystemRepository", "Zapisano pomyślnie listę kategorii do: ${file.absolutePath}")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas zapisywania listy kategorii", e)
            Result.failure(e)
        }
    }
    // --- POCZĄTEK ZMIANY ---
    fun updateCategoryInSongs(oldCategory: Category, newCategory: Category): Result<Unit> {
        return try {
            val allSongs = getSongList()
            val updatedSongs = allSongs.map { song ->
                if (song.kategoria.equals(oldCategory.nazwa, ignoreCase = true)) {
                    song.copy(kategoria = newCategory.nazwa, kategoriaSkr = newCategory.skrot)
                } else {
                    song
                }
            }
            saveSongList(updatedSongs)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas aktualizacji kategorii w pieśniach", e)
            Result.failure(e)
        }
    }

    fun removeCategoryFromSongs(categoryToRemove: Category): Result<Unit> {
        return try {
            val allSongs = getSongList()
            val updatedSongs = allSongs.map { song ->
                if (song.kategoria.equals(categoryToRemove.nazwa, ignoreCase = true)) {
                    song.copy(kategoria = "", kategoriaSkr = "")
                } else {
                    song
                }
            }
            saveSongList(updatedSongs)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas usuwania kategorii z pieśni", e)
            Result.failure(e)
        }
    }
    // --- KONIEC ZMIANY ---

    fun getSong(title: String, siedlNum: String?, sakNum: String?, dnNum: String?): Song? {
        if (title.isBlank()) return null
        val songList = getSongList()

        val matchingSongs = songList.filter { it.tytul.equals(title, ignoreCase = true) }

        return when {
            matchingSongs.isEmpty() -> null
            matchingSongs.size == 1 -> matchingSongs.first()
            else -> {
                matchingSongs.find { song ->
                    (siedlNum?.isNotBlank() == true && song.numerSiedl.equals(siedlNum, ignoreCase = true)) ||
                            (sakNum?.isNotBlank() == true && song.numerSAK.equals(sakNum, ignoreCase = true)) ||
                            (dnNum?.isNotBlank() == true && song.numerDN.equals(dnNum, ignoreCase = true))
                } ?: matchingSongs.first() // Fallback to first match if no number matches
            }
        }
    }

    fun saveDayData(path: String, dayData: DayData): Result<Unit> {
        return try {
            val file = File(internalStorageRoot, path) // Ścieżka powinna już zawierać .json
            file.parentFile?.mkdirs()
            val jsonString = json.encodeToString(dayData)
            file.writeText(jsonString)
            Log.d("FileSystemRepository", "Zapisano pomyślnie dane do: ${file.absolutePath}")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas zapisywania danych do $path", e)
            Result.failure(e)
        }
    }

    fun saveOrder(path: String, orderedNames: List<String>): Result<Unit> {
        return try {
            val directory = File(internalStorageRoot, path)
            if (!directory.exists()) directory.mkdirs()
            val orderFile = File(directory, ORDER_FILE_NAME)
            val directoryOrder = DirectoryOrder(order = orderedNames)
            val jsonString = json.encodeToString(directoryOrder)
            orderFile.writeText(jsonString)
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd zapisu kolejności w $path", e)
            Result.failure(e)
        }
    }

    fun createFolder(path: String, folderName: String): Result<Unit> {
        return try {
            val fullPath = File(internalStorageRoot, path)
            val newFolder = File(fullPath, folderName)
            if (newFolder.exists()) {
                return Result.failure(IOException("Folder o tej nazwie już istnieje."))
            }
            if (newFolder.mkdirs()) {
                Log.d("FileSystemRepository", "Utworzono folder: ${newFolder.absolutePath}")
                Result.success(Unit)
            } else {
                Result.failure(IOException("Nie udało się utworzyć folderu."))
            }
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd tworzenia folderu '$folderName' w '$path'", e)
            Result.failure(e)
        }
    }

    fun createDayFile(path: String, fileName: String, url: String?): Result<String> {
        return try {
            val fullPath = File(internalStorageRoot, path)
            fullPath.mkdirs()
            val newFile = File(fullPath, "$fileName.json")

            if (newFile.exists()) {
                return Result.failure(IOException("Plik o tej nazwie już istnieje."))
            }

            val dayData = DayData(
                urlCzytania = url?.ifBlank { null },
                tytulDnia = fileName,
                czyDatowany = false,
                czytania = emptyList(),
                piesniSugerowane = emptyList()
            )

            val jsonString = json.encodeToString(dayData)
            newFile.writeText(jsonString)
            Log.d("FileSystemRepository", "Utworzono plik dnia: ${newFile.absolutePath}")
            Result.success(newFile.name)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd tworzenia pliku '$fileName' w '$path'", e)
            Result.failure(e)
        }
    }

    fun deleteItem(itemPath: String): Result<Unit> {
        return try {
            val fileToDelete = File(internalStorageRoot, itemPath)
            if (!fileToDelete.exists()) return Result.failure(FileNotFoundException("Element nie istnieje: $itemPath"))

            if (fileToDelete.deleteRecursively()) {
                Result.success(Unit)
            } else {
                Result.failure(IOException("Nie udało się usunąć elementu: $itemPath"))
            }
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas usuwania $itemPath", e)
            Result.failure(e)
        }
    }

    fun deleteSong(songToDelete: Song, deleteOccurrences: Boolean): Result<Unit> {
        return try {
            // 1. Usunięcie pieśni z głównego pliku `piesni.json`
            val currentSongs = getSongList().toMutableList()
            val removed = currentSongs.removeAll { it.numerSiedl == songToDelete.numerSiedl }
            if (!removed) {
                return Result.failure(FileNotFoundException("Nie znaleziono pieśni w głównym spisie."))
            }
            saveSongList(currentSongs).getOrThrow() // Rzuci wyjątek w razie błędu zapisu

            // 2. Opcjonalne usunięcie wystąpień w dniach liturgicznych
            if (deleteOccurrences) {
                val allDayPaths = getAllDayFilePaths()
                for (path in allDayPaths) {
                    val dayData = getDayData(path)
                    if (dayData?.piesniSugerowane?.any { it?.numer == songToDelete.numerSiedl } == true) {
                        val updatedSongs = dayData.piesniSugerowane.filter { it?.numer != songToDelete.numerSiedl }
                        val updatedDayData = dayData.copy(piesniSugerowane = updatedSongs)
                        saveDayData(path, updatedDayData).getOrThrow()
                    }
                }
            }
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd podczas usuwania pieśni: ${songToDelete.tytul}", e)
            Result.failure(e)
        }
    }

    fun renameItem(itemPath: String, newName: String): Result<String> {
        return try {
            val oldFile = File(internalStorageRoot, itemPath)
            if (!oldFile.exists()) return Result.failure(FileNotFoundException("Element nie istnieje: $itemPath"))

            val parentDir = oldFile.parentFile ?: return Result.failure(IOException("Brak folderu nadrzędnego."))
            val newFileNameWithExt = if (oldFile.isDirectory) newName else "$newName.json"
            val newFile = File(parentDir, newFileNameWithExt)

            if (newFile.exists()) return Result.failure(IOException("Element o nazwie '$newName' już istnieje."))

            if (oldFile.renameTo(newFile)) {
                if (!newFile.isDirectory && newFile.extension == "json") {
                    try {
                        val dayData = json.decodeFromString<DayData>(newFile.readText())
                        val updatedDayData = dayData.copy(tytulDnia = newName)
                        newFile.writeText(json.encodeToString(updatedDayData))
                    } catch (e: Exception) {
                        Log.w("FileSystemRepo", "Nie udało się zaktualizować tytułu w pliku ${newFile.name}", e)
                    }
                }
                Result.success(newFile.absolutePath.removePrefix(internalStorageRoot.absolutePath + "/"))
            } else {
                Result.failure(IOException("Nie udało się zmienić nazwy."))
            }
        } catch (e: Exception) {
            Log.e("FileSystemRepository", "Błąd zmiany nazwy dla $itemPath", e)
            Result.failure(e)
        }
    }


    fun getMonthlyFileMap(month: Month): Map<Int, List<String>> {
        val monthName = month.getDisplayName(TextStyle.FULL_STANDALONE, Locale("pl"))
            .replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale("pl")) else it.toString() }
        val monthDir = File(internalStorageRoot, "Datowane/$monthName")

        if (!monthDir.exists() || !monthDir.isDirectory) {
            Log.w("FileSystemRepo", "Folder dla miesiąca nie istnieje: ${monthDir.path}")
            return emptyMap()
        }

        val fileMap = mutableMapOf<Int, MutableList<String>>()

        monthDir.listFiles()?.forEach { file ->
            try {
                val nameWithoutExtension = file.nameWithoutExtension
                val dayString = nameWithoutExtension.substringBefore(" ")
                val dayNumber = dayString.toIntOrNull()

                if (dayNumber != null) {
                    val relativePath = "Datowane/$monthName/${file.name}"
                    fileMap.getOrPut(dayNumber) { mutableListOf() }.add(relativePath)
                }
            } catch (e: Exception) {
                Log.w("FileSystemRepo", "Pominięto plik o nieprawidłowej nazwie: ${file.name}", e)
            }
        }
        return fileMap
    }

    fun exportDataToZip(): Result<File> {
        return try {
            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            if (!downloadsDir.exists()) downloadsDir.mkdirs()

            val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
            val zipFile = File(downloadsDir, "Laudate_Export_$timestamp.zip")
            val zip = ZipFile(zipFile)

            val dataDir = File(internalStorageRoot, "data")
            if (dataDir.exists()) zip.addFolder(dataDir)

            val datowaneDir = File(internalStorageRoot, "Datowane")
            if (datowaneDir.exists()) zip.addFolder(datowaneDir)

            val songFile = File(internalStorageRoot, "piesni.json")
            if (songFile.exists()) zip.addFile(songFile)

            val categoryFile = File(internalStorageRoot, "kategorie.json")
            if (categoryFile.exists()) zip.addFile(categoryFile)


            Result.success(zipFile)
        } catch (e: Exception) {
            e.printStackTrace()
            Result.failure(e)
        }
    }

    fun importDataFromZip(uri: Uri): Result<Unit> {
        val tempUnzipDir = File(context.cacheDir, "import_unzip_temp")
        val tempZipFile = File(context.cacheDir, "import.zip")

        try {
            context.contentResolver.openInputStream(uri)?.use { inputStream ->
                FileOutputStream(tempZipFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
            } ?: return Result.failure(IOException("Nie można otworzyć strumienia z URI."))

            if (tempUnzipDir.exists()) tempUnzipDir.deleteRecursively()
            tempUnzipDir.mkdirs()
            ZipFile(tempZipFile).extractAll(tempUnzipDir.absolutePath)

            val foundFiles = findRequiredFiles(tempUnzipDir)
                ?: return Result.failure(IllegalStateException("Plik ZIP nie zawiera wymaganych plików/folderów: 'data', 'Datowane' i 'piesni.json'."))

            if (foundFiles.dataDir.listFiles().isNullOrEmpty()) {
                return Result.failure(IllegalStateException("Folder 'data' w pliku ZIP jest pusty."))
            }
            if (foundFiles.datowaneDir.listFiles().isNullOrEmpty()) {
                return Result.failure(IllegalStateException("Folder 'Datowane' w pliku ZIP jest pusty."))
            }

            File(internalStorageRoot, "data").deleteRecursively()
            File(internalStorageRoot, "Datowane").deleteRecursively()
            File(internalStorageRoot, "piesni.json").delete()
            File(internalStorageRoot, "kategorie.json").delete()

            foundFiles.dataDir.copyRecursively(File(internalStorageRoot, "data"), true)
            foundFiles.datowaneDir.copyRecursively(File(internalStorageRoot, "Datowane"), true)
            foundFiles.songFile.copyTo(File(internalStorageRoot, "piesni.json"), true)

            // Skopiuj plik kategorii, jeśli istnieje w zipie
            val categoryFileInZip = findFileRecursively(tempUnzipDir, "kategorie.json")
            categoryFileInZip?.copyTo(File(internalStorageRoot, "kategorie.json"), true)


            return Result.success(Unit)
        } catch (e: Exception) {
            e.printStackTrace()
            return Result.failure(e)
        } finally {
            if (tempUnzipDir.exists()) tempUnzipDir.deleteRecursively()
            if (tempZipFile.exists()) tempZipFile.delete()
        }
    }

    private fun findFileRecursively(directory: File, fileName: String): File? {
        directory.listFiles()?.forEach { file ->
            if (file.isDirectory) {
                val found = findFileRecursively(file, fileName)
                if (found != null) return found
            } else if (file.name == fileName) {
                return file
            }
        }
        return null
    }

    private fun findRequiredFiles(startDir: File): FoundImportFiles? {
        val queue: Queue<File> = LinkedList()
        queue.add(startDir)

        while (queue.isNotEmpty()) {
            val currentDir = queue.poll()
            val dataDir = File(currentDir, "data")
            val datowaneDir = File(currentDir, "Datowane")
            val songFile = File(currentDir, "piesni.json")

            if (dataDir.exists() && dataDir.isDirectory &&
                datowaneDir.exists() && datowaneDir.isDirectory &&
                songFile.exists() && songFile.isFile
            ) {
                return FoundImportFiles(dataDir, datowaneDir, songFile)
            }

            currentDir.listFiles { file -> file.isDirectory }?.forEach { queue.add(it) }
        }
        return null
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\Song.kt
treść:
package com.qjproject.liturgicalcalendar.data

import kotlinx.serialization.Serializable

@Serializable
data class Song(
    val tytul: String,
    val tekst: String? = null,
    val numerSiedl: String,
    val numerSAK: String,
    val numerDN: String,
    val kategoria: String,
    val kategoriaSkr: String
)

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\data\models\SearchResult.kt
treść:
package com.qjproject.liturgicalcalendar.data.models

import com.qjproject.liturgicalcalendar.data.Song

sealed class SearchResult {
    data class SongResult(
        val song: Song
    ) : SearchResult()
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\navigation\Screen.kt
treść:
package com.qjproject.liturgicalcalendar.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Category
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.List
import androidx.compose.material.icons.filled.MenuBook
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Settings
import androidx.compose.ui.graphics.vector.ImageVector
import java.net.URLDecoder
import java.net.URLEncoder

private object UrlEncoder {
    fun encode(input: String): String = URLEncoder.encode(input, "UTF-8")
    fun decode(input: String): String = URLDecoder.decode(input, "UTF-8")
}

sealed class Screen(val route: String, val label: String, val icon: ImageVector) {
    object Search : Screen("search", "Szukaj", Icons.Default.Search)
    object Browse : Screen("browse", "Przeglądaj", Icons.Default.List)
    object Calendar : Screen("calendar", "Kalendarz", Icons.Default.DateRange)
    object Settings : Screen("settings", "Ustawienia", Icons.Default.Settings)

    object DayDetails : Screen("day_details/{dayId}", "Szczegóły Dnia", Icons.Default.Info) {
        fun createRoute(dayId: String) = "day_details/${UrlEncoder.encode(dayId)}"
    }

    object DateEvents : Screen("date_events/{dateTitle}/{filePaths}", "Wydarzenia Dnia", Icons.Default.List) {
        private const val FILE_PATH_SEPARATOR = "|||"

        fun createRoute(dateTitle: String, filePaths: List<String>): String {
            val encodedTitle = UrlEncoder.encode(dateTitle)
            val encodedPaths = UrlEncoder.encode(filePaths.joinToString(FILE_PATH_SEPARATOR))
            return "date_events/$encodedTitle/$encodedPaths"
        }

        fun decodePaths(encodedPaths: String): List<String> {
            return UrlEncoder.decode(encodedPaths).split(FILE_PATH_SEPARATOR)
        }
    }
    object SongDetails : Screen("song_details/{songTitle}?siedlNum={siedlNum}&sakNum={sakNum}&dnNum={dnNum}", "Szczegóły pieśni", Icons.Default.MenuBook) {
        fun createRoute(song: com.qjproject.liturgicalcalendar.data.Song): String {
            val title = UrlEncoder.encode(song.tytul)
            val siedl = UrlEncoder.encode(song.numerSiedl)
            val sak = UrlEncoder.encode(song.numerSAK)
            val dn = UrlEncoder.encode(song.numerDN)
            return "song_details/$title?siedlNum=$siedl&sakNum=$sak&dnNum=$dn"
        }
    }

    object SongContent : Screen("song_content/{songTitle}?siedlNum={siedlNum}&sakNum={sakNum}&dnNum={dnNum}&editOnStart={editOnStart}", "Treść pieśni", Icons.Default.MenuBook) {
        fun createRoute(song: com.qjproject.liturgicalcalendar.data.Song, editOnStart: Boolean = false): String {
            val title = UrlEncoder.encode(song.tytul)
            val siedl = UrlEncoder.encode(song.numerSiedl)
            val sak = UrlEncoder.encode(song.numerSAK)
            val dn = UrlEncoder.encode(song.numerDN)
            return "song_content/$title?siedlNum=$siedl&sakNum=$sak&dnNum=$dn&editOnStart=$editOnStart"
        }
    }

    // --- POCZĄTEK ZMIANY ---
    object CategoryManagement : Screen("category_management", "Zarządzaj kategoriami", Icons.Default.Category)
    // --- KONIEC ZMIANY ---
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\components\AutoResizingText.kt
treść:
package com.qjproject.liturgicalcalendar.ui.components

import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow

@Composable
fun AutoResizingText(
    modifier: Modifier = Modifier,
    text: String,
    style: TextStyle,
    maxLines: Int = 2,
    textAlign: TextAlign
) {
    var resizedTextStyle by remember(text) {
        mutableStateOf(style)
    }

    var shouldShrink by remember(text) {
        mutableStateOf(true)
    }

    // --- POCZĄTEK ZMIANY ---
    // Odczytujemy minimalny rozmiar czcionki tutaj, w bezpiecznym kontekście @Composable.
    val minFontSize = MaterialTheme.typography.bodySmall.fontSize
    // --- KONIEC ZMIANY ---

    Text(
        text = text,
        modifier = modifier,
        style = resizedTextStyle,
        maxLines = maxLines,
        overflow = TextOverflow.Ellipsis,
        textAlign = textAlign,
        onTextLayout = { textLayoutResult ->
            if (textLayoutResult.didOverflowHeight && shouldShrink) {
                val newFontSize = resizedTextStyle.fontSize * 0.9f

                // --- POCZĄTEK ZMIANY ---
                // Używamy wcześniej odczytanej wartości `minFontSize`.
                if (newFontSize > minFontSize) {
                    resizedTextStyle = resizedTextStyle.copy(fontSize = newFontSize)
                } else {
                    shouldShrink = false
                }
                // --- KONIEC ZMIANY ---
            }
        }
    )
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\components\OptionsListScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.components

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Article
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OptionsListScreen(
    title: String,
    options: List<String>,
    onOptionClick: (String) -> Unit,
    onNavigateBack: () -> Unit
) {
    Scaffold(
        topBar = {
            Column {
                CenterAlignedTopAppBar(
                    title = {
                        AutoResizingText(
                            text = title,
                            style = MaterialTheme.typography.titleLarge,
                            textAlign = TextAlign.Center
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć")
                        }
                    },
                    colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background,
                        titleContentColor = MaterialTheme.colorScheme.primary,
                        navigationIconContentColor = MaterialTheme.colorScheme.primary
                    ),
                    windowInsets = TopAppBarDefaults.windowInsets
                )
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
            }
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(horizontal = 8.dp),
            contentPadding = PaddingValues(vertical = 8.dp)
        ) {
            items(options) { option ->
                OptionItem(
                    text = option.removeSuffix(".json").substringAfter("-").trim(),
                    onClick = { onOptionClick(option) }
                )
            }
        }
    }
}

@Composable
private fun OptionItem(text: String, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Outlined.Article,
                contentDescription = "Opcja",
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.width(16.dp))
            Text(
                text = text,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\browse\BrowseScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.browse

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.DragHandle
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.outlined.Article
import androidx.compose.material.icons.outlined.Folder
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.qjproject.liturgicalcalendar.data.FileSystemItem
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy
import org.burnoutcrew.reorderable.*

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun BrowseScreen(
    viewModel: BrowseViewModel,
    onNavigateToDay: (String) -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()

    HandleDialogs(viewModel, uiState)

    val reorderState = rememberReorderableLazyListState(onMove = { from, to -> viewModel.reorderItems(from, to) })

    LazyColumn(
        state = if (uiState.canReorder) reorderState.listState else rememberLazyListState(),
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 8.dp)
            .then(if (uiState.canReorder) Modifier.reorderable(reorderState) else Modifier),
        contentPadding = PaddingValues(vertical = 8.dp)
    ) {
        itemsIndexed(uiState.items, key = { _, item -> item.path }) { index, item ->
            if (uiState.isEditMode) {
                ReorderableItem(reorderState, key = item.path) { isDragging ->
                    BrowseItemEditable(
                        item = item,
                        isDragging = isDragging,
                        canReorder = uiState.canReorder,
                        onRenameClick = { viewModel.showDialog(BrowseDialogState.RenameItem(item, index)) },
                        onDeleteClick = { viewModel.showDialog(BrowseDialogState.ConfirmDelete(item, index)) },
                        reorderModifier = Modifier.detectReorder(reorderState)
                    )
                }
            } else {
                BrowseItemView(
                    item = item,
                    onClick = {
                        if (item.isDirectory) {
                            viewModel.onDirectoryClick(item.name)
                        } else {
                            onNavigateToDay(item.path)
                        }
                    }
                )
            }
        }

        if (uiState.isEditMode) {
            item {
                AddItemTile(onClick = { viewModel.showDialog(BrowseDialogState.AddOptions) })
            }
        }
    }
}

@Composable
private fun HandleDialogs(viewModel: BrowseViewModel, uiState: BrowseUiState) {
    when (val dialog = uiState.activeDialog) {
        is BrowseDialogState.AddOptions -> AddOptionsDialog(
            onDismiss = { viewModel.dismissDialog() },
            onCreateFolder = { viewModel.showDialog(BrowseDialogState.CreateFolder) },
            onCreateDay = { viewModel.showDialog(BrowseDialogState.CreateDay) }
        )
        is BrowseDialogState.CreateFolder -> CreateItemDialog(
            title = "Utwórz nowy folder",
            label = "Nazwa folderu",
            error = uiState.operationError,
            onDismiss = { viewModel.dismissDialog() },
            onValueChange = { newName -> viewModel.onNewItemNameChange(newName) },
            onConfirm = { name -> viewModel.createFolder(name) }
        )
        is BrowseDialogState.CreateDay -> CreateItemDialog(
            title = "Utwórz nowy dzień",
            label = "Nazwa dnia",
            error = uiState.operationError,
            onDismiss = { viewModel.dismissDialog() },
            onValueChange = { newName -> viewModel.onNewItemNameChange(newName) },
            onConfirm = { name -> viewModel.createDay(name, null) }
        )
        is BrowseDialogState.RenameItem -> RenameItemDialog(
            item = dialog.item,
            error = uiState.operationError,
            onDismiss = { viewModel.dismissDialog() },
            onValueChange = { newName -> viewModel.onNewItemNameChange(newName) },
            onConfirm = { newName -> viewModel.renameItem(dialog.index, newName) }
        )
        is BrowseDialogState.ConfirmDelete -> ConfirmDeleteDialog(
            item = dialog.item,
            onDismiss = { viewModel.dismissDialog() },
            onConfirm = { viewModel.deleteItem(dialog.index) }
        )
        is BrowseDialogState.None -> {}
    }

    if (uiState.showConfirmExitDialog) {
        ConfirmExitEditModeDialog(
            onDismiss = { viewModel.dismissConfirmExitDialog() },
            onDiscard = { viewModel.onCancelEditMode(isFromDialog = true) }
        )
    }
}

@Composable
fun BrowseItemView(item: FileSystemItem, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth().padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = if (item.isDirectory) Icons.Outlined.Folder else Icons.Outlined.Article,
                contentDescription = if (item.isDirectory) "Folder" else "Dzień",
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.width(16.dp))
            Text(
                text = item.name.replace("_", " "),
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}

@Composable
fun BrowseItemEditable(
    item: FileSystemItem,
    isDragging: Boolean,
    canReorder: Boolean,
    onRenameClick: () -> Unit,
    onDeleteClick: () -> Unit,
    reorderModifier: Modifier
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
            .shadow(if (isDragging) 4.dp else 0.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp, vertical = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            if (canReorder) {
                Icon(
                    imageVector = Icons.Default.DragHandle,
                    contentDescription = "Zmień kolejność",
                    modifier = reorderModifier.padding(8.dp)
                )
            } else {
                Spacer(Modifier.width(40.dp)) // Placeholder
            }

            Icon(
                imageVector = if (item.isDirectory) Icons.Outlined.Folder else Icons.Outlined.Article,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.padding(start = 4.dp)
            )
            Spacer(modifier = Modifier.width(12.dp))
            Text(
                text = item.name.replace("_", " "),
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.weight(1f),
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
            IconButton(onClick = onRenameClick) {
                Icon(Icons.Default.Edit, "Zmień nazwę")
            }
            IconButton(onClick = onDeleteClick) {
                Icon(Icons.Default.Delete, "Usuń")
            }
        }
    }
}

@Composable
fun AddItemTile(onClick: () -> Unit) {
    Card(
        onClick = onClick,
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
    ) {
        Box(
            modifier = Modifier
                .height(64.dp)
                .fillMaxWidth(),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.Add,
                contentDescription = "Dodaj nowy element",
                tint = MaterialTheme.colorScheme.primary
            )
        }
    }
}

// --- DIALOGS ---

@Composable
private fun ConfirmExitEditModeDialog(onDismiss: () -> Unit, onDiscard: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Anulować zmiany?",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text("Masz niezapisane zmiany. Czy na pewno chcesz wyjść i je odrzucić?")
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) {
                        Text("Zostań", fontWeight = FontWeight.Bold)
                    }
                    Spacer(Modifier.width(8.dp))
                    TextButton(onClick = onDiscard) {
                        Text("Odrzuć", color = MaterialTheme.colorScheme.error)
                    }
                }
            }
        }
    }
}

@Composable
private fun ConfirmDeleteDialog(item: FileSystemItem, onDismiss: () -> Unit, onConfirm: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Potwierdź usunięcie",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text("Czy na pewno chcesz usunąć '${item.name}'? Ta operacja jest nieodwracalna.")
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = onConfirm,
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                    ) { Text("Usuń") }
                }
            }
        }
    }
}

@Composable
private fun RenameItemDialog(
    item: FileSystemItem,
    error: String?,
    onDismiss: () -> Unit,
    onValueChange: (String) -> Unit,
    onConfirm: (String) -> Unit
) {
    CreateItemDialog(
        title = "Zmień nazwę",
        label = "Nowa nazwa",
        initialValue = item.name,
        error = error,
        onDismiss = onDismiss,
        onValueChange = onValueChange,
        onConfirm = onConfirm
    )
}

@Composable
private fun AddOptionsDialog(onDismiss: () -> Unit, onCreateFolder: () -> Unit, onCreateDay: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(Modifier.padding(24.dp)) {
                Text(
                    "Co chcesz utworzyć?",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(24.dp))
                Button(onClick = onCreateFolder, modifier = Modifier.fillMaxWidth()) {
                    Text("Nowy folder")
                }
                Spacer(Modifier.height(8.dp))
                Button(onClick = onCreateDay, modifier = Modifier.fillMaxWidth()) {
                    Text("Nowy dzień")
                }
                Spacer(Modifier.height(16.dp))
                TextButton(onClick = onDismiss, modifier = Modifier.align(Alignment.End)) {
                    Text("Anuluj")
                }
            }
        }
    }
}

@Composable
private fun CreateItemDialog(
    title: String,
    label: String,
    initialValue: String = "",
    error: String?,
    onDismiss: () -> Unit,
    onValueChange: (String) -> Unit,
    onConfirm: (String) -> Unit
) {
    var name by remember { mutableStateOf(initialValue) }
    LaunchedEffect(Unit) { onValueChange(initialValue) }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    title,
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Column {
                    OutlinedTextField(
                        value = name,
                        onValueChange = {
                            name = it
                            onValueChange(it)
                        },
                        label = { Text(label) },
                        singleLine = true,
                        isError = error != null,
                        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),
                        keyboardActions = KeyboardActions(onDone = {
                            if (name.isNotBlank() && error == null) onConfirm(name)
                        })
                    )
                    if (error != null) {
                        Text(
                            error,
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodySmall,
                            modifier = Modifier.padding(top = 4.dp)
                        )
                    }
                }
                Spacer(Modifier.height(24.dp))
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = { onConfirm(name) },
                        enabled = name.isNotBlank() && error == null
                    ) { Text("Zatwierdź") }
                }
            }
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\browse\BrowseViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.browse

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.FileSystemItem
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import org.burnoutcrew.reorderable.ItemPosition
import java.util.Locale

sealed class BrowseDialogState {
    object None : BrowseDialogState()
    object AddOptions : BrowseDialogState()
    object CreateFolder : BrowseDialogState()
    object CreateDay : BrowseDialogState()
    data class ConfirmDelete(val item: FileSystemItem, val index: Int) : BrowseDialogState()
    data class RenameItem(val item: FileSystemItem, val index: Int) : BrowseDialogState()
}

data class BrowseUiState(
    val currentPath: List<String> = listOf("data"),
    val items: List<FileSystemItem> = emptyList(),
    val screenTitle: String = "Czego szukasz?",
    val isBackArrowVisible: Boolean = false,
    val isEditMode: Boolean = false,
    val showConfirmExitDialog: Boolean = false,
    val hasChanges: Boolean = false,
    val activeDialog: BrowseDialogState = BrowseDialogState.None,
    val operationError: String? = null
) {
    val isRoot: Boolean get() = currentPath.size <= 1
    val canReorder: Boolean get() = isEditMode && items.size > 1
}

class BrowseViewModel(private val repository: FileSystemRepository) : ViewModel() {

    private val _uiState = MutableStateFlow(BrowseUiState())
    val uiState: StateFlow<BrowseUiState> = _uiState.asStateFlow()

    private var originalItemsOnEdit: List<FileSystemItem> = emptyList()

    init {
        loadContentForCurrentPath()
    }

    private fun validateNewItemName(name: String, isFolder: Boolean, originalName: String? = null) {
        val trimmedName = name.trim()
//        if (trimmedName.isBlank()) {
//            _uiState.update { it.copy(operationError = "Nazwa nie może być pusta.") }
//            return
//        }

        val existingNames = _uiState.value.items.map { it.name.lowercase(Locale.getDefault()) }
        val finalName = trimmedName.lowercase(Locale.getDefault())

        if (finalName != originalName?.lowercase(Locale.getDefault()) && existingNames.contains(finalName)) {
            val itemType = if (isFolder) "Folder" else "Plik"
            _uiState.update { it.copy(operationError = "$itemType o tej nazwie już istnieje.") }
        } else {
            _uiState.update { it.copy(operationError = null) }
        }
    }

    fun onNewItemNameChange(name: String) {
        when (val dialog = _uiState.value.activeDialog) {
            is BrowseDialogState.CreateFolder -> validateNewItemName(name, isFolder = true)
            is BrowseDialogState.CreateDay -> validateNewItemName(name, isFolder = false)
            is BrowseDialogState.RenameItem -> validateNewItemName(name, isFolder = dialog.item.isDirectory, originalName = dialog.item.name)
            else -> {}
        }
    }

    fun onResetToRoot() {
        if (_uiState.value.isEditMode) onTryExitEditMode { _onResetToRoot() }
        else _onResetToRoot()
    }

    private fun _onResetToRoot() {
        _uiState.update { it.copy(currentPath = listOf("data")) }
        loadContentForCurrentPath()
    }

    fun onBackPress() {
        if (_uiState.value.isEditMode) onTryExitEditMode { _onBackPress() }
        else _onBackPress()
    }

    private fun _onBackPress() {
        if (!_uiState.value.isRoot) {
            _uiState.update { it.copy(currentPath = it.currentPath.dropLast(1)) }
            loadContentForCurrentPath()
        }
    }

    fun onDirectoryClick(directoryName: String) {
        val action = {
            _uiState.update { it.copy(currentPath = it.currentPath + directoryName) }
            loadContentForCurrentPath()
        }
        if (_uiState.value.isEditMode) onTryExitEditMode(onContinue = action)
        else action()
    }

    private fun loadContentForCurrentPath() {
        viewModelScope.launch {
            val pathString = _uiState.value.currentPath.joinToString("/")
            val items = repository.getItems(pathString).filter { it.name != "piesni" }
            _uiState.update {
                val title = if (it.isRoot) "Czego szukasz?" else it.currentPath.last().replace("_", " ")
                it.copy(
                    items = items,
                    screenTitle = title,
                    isBackArrowVisible = !it.isRoot,
                    hasChanges = false
                )
            }
        }
    }

    fun onEnterEditMode() {
        originalItemsOnEdit = _uiState.value.items
        _uiState.update { it.copy(isEditMode = true, hasChanges = false) }
    }

    fun onTryExitEditMode(onContinue: () -> Unit) {
        if (_uiState.value.hasChanges) {
            _uiState.update { it.copy(showConfirmExitDialog = true) }
        } else {
            exitEditMode(onContinue = onContinue)
        }
    }

    fun onSaveEditMode() {
        viewModelScope.launch {
            val currentItems = _uiState.value.items
            val originalItemsMap = originalItemsOnEdit.associateBy { it.path }
            val currentItemsMapByPath = currentItems.associateBy { it.path }

            // 1. Handle Deletions
            val deletedItems = originalItemsOnEdit.filter { !currentItemsMapByPath.containsKey(it.path) }
            for (item in deletedItems) {
                repository.deleteItem(item.path)
            }

            // 2. Handle Additions and Renames
            val finalItems = currentItems.toMutableList()
            val itemsToUpdate = mutableMapOf<Int, FileSystemItem>()

            for ((index, item) in currentItems.withIndex()) {
                val originalItem = originalItemsMap[item.path]
                if (originalItem == null) { // New item
                    val pathString = _uiState.value.currentPath.joinToString("/")
                    val result = if (item.isDirectory) {
                        repository.createFolder(pathString, item.name)
                    } else {
                        repository.createDayFile(pathString, item.name, null)
                    }
                    // We don't need to do anything with the result here as the final order will be saved later
                } else if (originalItem.name != item.name) { // Renamed item
                    repository.renameItem(item.path, item.name).onSuccess { newPath ->
                        itemsToUpdate[index] = item.copy(path = newPath)
                    }
                }
            }
            itemsToUpdate.forEach { (index, updatedItem) -> finalItems[index] = updatedItem }

            // 3. Save final order
            val finalOrderedNames = finalItems.map { it.name }
            repository.saveOrder(_uiState.value.currentPath.joinToString("/"), finalOrderedNames)

            exitEditMode()
        }
    }

    fun onCancelEditMode(isFromDialog: Boolean = false) {
        val onContinue = if (isFromDialog) {
            {}
        } else null
        _uiState.update { it.copy(items = originalItemsOnEdit) }
        exitEditMode(onContinue = onContinue)
    }

    private fun exitEditMode(onContinue: (() -> Unit)? = null) {
        originalItemsOnEdit = emptyList()
        _uiState.update { it.copy(isEditMode = false, hasChanges = false, showConfirmExitDialog = false) }
        loadContentForCurrentPath()
        onContinue?.invoke()
    }


    fun reorderItems(from: ItemPosition, to: ItemPosition) {
        _uiState.update { state ->
            val updatedList = state.items.toMutableList().apply { add(to.index, removeAt(from.index)) }
            state.copy(
                items = updatedList,
                hasChanges = updatedList != originalItemsOnEdit
            )
        }
    }

    fun showDialog(dialogState: BrowseDialogState) = _uiState.update { it.copy(activeDialog = dialogState, operationError = null) }
    fun dismissDialog() = _uiState.update { it.copy(activeDialog = BrowseDialogState.None, operationError = null) }
    fun dismissConfirmExitDialog() = _uiState.update { it.copy(showConfirmExitDialog = false) }

    fun deleteItem(index: Int) {
        if (index !in _uiState.value.items.indices) return
        val currentItems = _uiState.value.items.toMutableList()
        currentItems.removeAt(index)
        _uiState.update {
            it.copy(
                items = currentItems,
                hasChanges = currentItems != originalItemsOnEdit,
                activeDialog = BrowseDialogState.None
            )
        }
    }

    fun renameItem(index: Int, newName: String) {
        val trimmedName = newName.trim()
        if (trimmedName.isBlank()) {
            _uiState.update { it.copy(operationError = "Nazwa nie może być pusta.") }
            return
        }

        val currentItems = _uiState.value.items.toMutableList()
        if (index !in currentItems.indices) return

        val oldItem = currentItems[index]
        if (trimmedName == oldItem.name) {
            dismissDialog()
            return
        }
        val updatedItem = oldItem.copy(name = trimmedName)
        currentItems[index] = updatedItem

        _uiState.update {
            it.copy(
                items = currentItems,
                hasChanges = currentItems != originalItemsOnEdit,
                activeDialog = BrowseDialogState.None,
                operationError = null
            )
        }
    }

    fun createFolder(name: String) {
        val trimmedName = name.trim()
        if (trimmedName.isBlank()) {
            _uiState.update { it.copy(operationError = "Nazwa folderu nie może być pusta.") }
            return
        }
        val currentItems = _uiState.value.items.toMutableList()
        // Path is temporary, will be properly created on save
        val tempPath = _uiState.value.currentPath.joinToString("/") + "/$trimmedName"
        val newItem = FileSystemItem(name = trimmedName, isDirectory = true, path = tempPath)
        currentItems.add(newItem)

        _uiState.update {
            it.copy(
                items = currentItems,
                hasChanges = currentItems != originalItemsOnEdit,
                activeDialog = BrowseDialogState.None,
                operationError = null
            )
        }
    }

    fun createDay(name: String, url: String?) {
        val trimmedName = name.trim()
        if (trimmedName.isBlank()) {
            _uiState.update { it.copy(operationError = "Nazwa dnia nie może być pusta.") }
            return
        }
        val currentItems = _uiState.value.items.toMutableList()
        // Path is temporary, will be properly created on save
        val tempPath = _uiState.value.currentPath.joinToString("/") + "/$trimmedName.json"
        val newItem = FileSystemItem(name = trimmedName, isDirectory = false, path = tempPath)
        currentItems.add(newItem)

        _uiState.update {
            it.copy(
                items = currentItems,
                hasChanges = currentItems != originalItemsOnEdit,
                activeDialog = BrowseDialogState.None,
                operationError = null
            )
        }
    }
}

class BrowseViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(BrowseViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return BrowseViewModel(FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\calendar\CalendarRepository.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.calendar

import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.encodeToJsonElement
import kotlinx.serialization.json.jsonObject
import java.io.File
import java.io.IOException
import java.net.HttpURLConnection
import java.net.SocketTimeoutException
import java.net.URL
import java.net.UnknownHostException
import java.time.LocalDate
import java.time.YearMonth
import java.time.format.DateTimeFormatter
import java.time.format.TextStyle
import java.util.Locale

sealed class NavigationAction {
    data class NavigateToDay(val path: String) : NavigationAction()
    data class ShowDateEvents(val title: String, val paths: List<String>) : NavigationAction()
}

@Serializable
data class LiturgicalEventDetails(
    val name: String,
    val data: String,
    val rok_litera: String,
    val rok_cyfra: String,
    val typ: String,
    val kolor: String
)

data class LiturgicalYearInfo(
    val mainInfo: String,
    val transitionInfo: String?
)

data class CalendarDay(
    val dayOfMonth: Int,
    val month: YearMonth,
    val isToday: Boolean,
    val events: List<LiturgicalEventDetails>,
    val dominantEventColorName: String?
) {
    val hasEvents: Boolean get() = events.isNotEmpty()
}


class LiturgicalYear(private val events: Map<String, LiturgicalEventDetails>) {
    private val eventsByDate by lazy {
        events.values.groupBy {
            LocalDate.parse(it.data, DateTimeFormatter.ofPattern("dd-MM-yyyy"))
        }
    }

    fun eventsForDate(date: LocalDate): List<LiturgicalEventDetails> {
        return eventsByDate[date] ?: emptyList()
    }
}


class CalendarRepository(private val context: Context) {
    private val json = Json { ignoreUnknownKeys = true }
    private val calendarDir = File(context.filesDir, "kalendarz").apply { mkdirs() }
    private val cache = mutableMapOf<Int, LiturgicalYear>()

    private val eventTypeHierarchy = mapOf(
        "Uroczystość" to 1,
        "Święto" to 2,
        "Wspomnienie obowiązkowe" to 3,
        "" to 4,
        "Wspomnienie dowolne" to 5
    )

    suspend fun getLiturgicalYear(year: Int): LiturgicalYear? = withContext(Dispatchers.IO) {
        if (cache.containsKey(year)) return@withContext cache[year]

        val file = File(calendarDir, "$year.json")
        if (!file.exists()) return@withContext null

        return@withContext try {
            val jsonString = file.readText()
            val jsonObject = Json.parseToJsonElement(jsonString).jsonObject
            val events = jsonObject.mapValues {
                Json.decodeFromJsonElement<LiturgicalEventDetails>(it.value).copy(name = it.key)
            }
            val liturgicalYear = LiturgicalYear(events)
            cache[year] = liturgicalYear
            liturgicalYear
        } catch (e: Exception) {
            null
        }
    }

    fun getAvailableYears(): List<Int> {
        return calendarDir.listFiles { _, name -> name.endsWith(".json") }
            ?.mapNotNull { it.nameWithoutExtension.toIntOrNull() }
            ?.sorted() ?: emptyList()
    }

    fun isYearAvailable(year: Int): Boolean = File(calendarDir, "$year.json").exists()

    suspend fun downloadAndSaveYearIfNeeded(year: Int): Result<Unit> = withContext(Dispatchers.IO) {
        if (isYearAvailable(year)) return@withContext Result.success(Unit)
        if (!isNetworkAvailable()) return@withContext Result.failure(IOException("Brak połączenia z internetem."))

        var connection: HttpURLConnection? = null
        try {
            val url = URL("https://gcatholic.org/calendar/ics/$year-pl-PL.ics?v=3")
            connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 15000
            connection.readTimeout = 15000

            if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                val icsContent = connection.inputStream.bufferedReader().readText()
                val parsedEvents = parseIcsToEvents(icsContent)
                val jsonString = buildJsonString(parsedEvents)
                File(calendarDir, "$year.json").writeText(jsonString)
                cache.remove(year)
                Result.success(Unit)
            } else {
                Result.failure(IOException("Serwer odpowiedział kodem ${connection.responseCode} dla roku $year."))
            }
        } catch (e: Exception) {
            val errorMessage = when (e) {
                is UnknownHostException -> "Brak połączenia z internetem."
                is SocketTimeoutException -> "Przekroczono limit czasu odpowiedzi serwera."
                else -> e.localizedMessage ?: e.javaClass.simpleName
            }
            Result.failure(IOException(errorMessage))
        } finally {
            connection?.disconnect()
        }
    }

    private fun isNetworkAvailable(): Boolean {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) ||
                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)
    }

    fun getDominantEvent(events: List<LiturgicalEventDetails>): LiturgicalEventDetails? {
        if (events.isEmpty()) return null
        return events.minWithOrNull(eventComparator)
    }

    val eventComparator = compareBy<LiturgicalEventDetails>(
        { eventTypeHierarchy[it.typ] ?: 99 },
        { !it.name.any { char -> char.isDigit() } },
        { it.name }
    )

    private fun formatYearId(rok_litera: String?, rok_cyfra: String?): String? {
        if (rok_litera.isNullOrBlank() || rok_litera.equals("null", ignoreCase = true) ||
            rok_cyfra.isNullOrBlank() || rok_cyfra.equals("null", ignoreCase = true)) {
            return null
        }
        return "$rok_litera, $rok_cyfra"
    }

    fun getLiturgicalYearInfoForMonth(yearMonth: YearMonth, yearData: LiturgicalYear): LiturgicalYearInfo {
        val lastDayOfMonth = yearMonth.atEndOfMonth()
        val eventsOnLastDay = yearData.eventsForDate(lastDayOfMonth)
        val dominantEventOnLastDay = getDominantEvent(eventsOnLastDay)

        if (dominantEventOnLastDay == null) {
            return LiturgicalYearInfo("Brak danych o roku liturgicznym", null)
        }

        val finalYearId = formatYearId(dominantEventOnLastDay.rok_litera, dominantEventOnLastDay.rok_cyfra)
        val mainInfo = finalYearId?.let { "Aktualny rok: $it" } ?: "Brak danych o roku liturgicznym"
        var transitionInfo: String? = null

        if (finalYearId != null) {
            for (day in lastDayOfMonth.dayOfMonth - 1 downTo 1) {
                val date = yearMonth.atDay(day)
                val events = yearData.eventsForDate(date)
                val dominantEvent = getDominantEvent(events)
                val currentYearId = formatYearId(dominantEvent?.rok_litera, dominantEvent?.rok_cyfra)

                if (currentYearId != finalYearId) {
                    // Znaleziono punkt przejściowy. Utwórz informację tylko jeśli poprzedni rok jest prawidłowy.
                    currentYearId?.let {
                        val transitionDay = day + 1
                        val monthName = date.month.getDisplayName(TextStyle.FULL, Locale("pl"))
                        transitionInfo = "Rok obowiązujący do ${transitionDay - 1} $monthName: $it"
                    }
                    break // Przerwij pętlę bez względu na wszystko, ponieważ znaleziono pierwszy punkt różnicy.
                }
            }
        }

        return LiturgicalYearInfo(mainInfo, transitionInfo)
    }

    fun deleteAllCalendarFiles() {
        if (calendarDir.exists()) {
            calendarDir.listFiles()?.forEach { it.delete() }
        }
        cache.clear()
    }

    data class LiturgicalCycles(val sundayCycle: String, val weekdayCycle: String)

    private fun calculateLiturgicalCycles(eventDate: LocalDate): LiturgicalCycles {
        val calendarYear = eventDate.year
        val weekdayCycle = if (calendarYear % 2 != 0) "1" else "2"
        val dec3rd = LocalDate.of(calendarYear, 12, 3)
        val dayIndex = dec3rd.dayOfWeek.value % 7
        val firstSundayOfAdvent = dec3rd.minusDays(dayIndex.toLong())
        val referenceYear = if (eventDate.isBefore(firstSundayOfAdvent)) calendarYear - 1 else calendarYear
        val sundayCycle = when (referenceYear % 3) {
            0 -> "A"; 1 -> "B"; 2 -> "C"; else -> "Error"
        }
        return LiturgicalCycles(sundayCycle, weekdayCycle)
    }

    private fun parseIcsToEvents(icsContent: String): List<LiturgicalEventDetails> {
        val events = mutableListOf<LiturgicalEventDetails>()
        val lines = icsContent.lines()
        val dateParser = DateTimeFormatter.ofPattern("yyyyMMdd")
        var i = 0
        while (i < lines.size) {
            if (lines[i] == "BEGIN:VEVENT") {
                var currentSummary = ""
                var currentDtstart = ""
                while (i < lines.size && lines[i] != "END:VEVENT") {
                    val line = lines[i]
                    when {
                        line.startsWith("DTSTART;VALUE=DATE:") -> currentDtstart = line.substringAfter(":")
                        line.startsWith("SUMMARY:") -> {
                            val summaryBuilder = StringBuilder(line.substringAfter(":"))
                            while (i + 1 < lines.size && lines[i + 1].startsWith(" ")) {
                                i++
                                summaryBuilder.append(lines[i].trimStart())
                            }
                            currentSummary = summaryBuilder.toString()
                        }
                    }
                    i++
                }

                if (currentDtstart.isNotEmpty() && currentSummary.isNotEmpty()) {
                    val eventDate = LocalDate.parse(currentDtstart, dateParser)
                    val cycles = calculateLiturgicalCycles(eventDate)
                    val cleanedName = parseName(currentSummary)
                    val finalName = translationMap[cleanedName] ?: cleanedName

                    if (finalName.isNotBlank()) {
                        events.add(
                            LiturgicalEventDetails(
                                name = finalName,
                                data = eventDate.format(DateTimeFormatter.ofPattern("dd-MM-yyyy")),
                                rok_litera = cycles.sundayCycle,
                                rok_cyfra = cycles.weekdayCycle,
                                typ = parseType(currentSummary),
                                kolor = parseColor(currentSummary)
                            )
                        )
                    }
                }
            }
            i++
        }
        return events
    }

    private fun buildJsonString(events: List<LiturgicalEventDetails>): String {
        val eventMap = events.associateBy { it.name }
        return json.encodeToString(MapSerializer(String.serializer(), LiturgicalEventDetails.serializer()), eventMap)
    }

    private fun parseColor(summary: String): String {
        val lowerSummary = summary.lowercase(Locale.getDefault())
        return when {
            "gaudete" in lowerSummary || "iii niedziela adwentu" in lowerSummary || "3 niedziela adwentu" in lowerSummary -> "Różowy"
            "laetare" in lowerSummary || "iv niedziela wielkiego postu" in lowerSummary || "4 niedziela wielkiego postu" in lowerSummary -> "Różowy"
            "⚪" in summary -> "Biały"
            "🔴" in summary -> "Czerwony"
            "🟢" in summary -> "Zielony"
            "🟣" in summary -> "Fioletowy"
            "💗" in summary || "🩷" in summary -> "Różowy"
            else -> "Nieznany"
        }
    }

    private fun parseType(summary: String): String {
        val code = "\\[(.*?)\\]".toRegex().find(summary)?.groupValues?.getOrNull(1) ?: return ""
        return when (code) {
            "U" -> "Uroczystość"; "Ś" -> "Święto"; "W" -> "Wspomnienie obowiązkowe"
            "w", "w*" -> "Wspomnienie dowolne"; else -> ""
        }
    }

    private fun parseName(summary: String): String {
        return summary.replace(Regex("\\[.*?\\]\\s*"), "")
            .replace(Regex("[⚪🔴🟢🟣💗🩷?]"), "")
            .replace("\\", "")
            .replace("/", "")
            .trim()
            .replace(Regex("\\s+"), " ")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\calendar\CalendarScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.calendar

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.lifecycle.viewmodel.compose.viewModel
import com.qjproject.liturgicalcalendar.ui.theme.Gold
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy
import java.time.Month
import java.time.YearMonth
import java.time.format.TextStyle
import java.util.Locale

@Composable
fun CalendarScreen(
    onNavigateToDay: (String) -> Unit,
    onNavigateToDateEvents: (String, List<String>) -> Unit
) {
    val context = LocalContext.current
    val viewModel: CalendarViewModel = viewModel(factory = CalendarViewModelFactory(context))
    val uiState by viewModel.uiState.collectAsState()
    var showEventSelectionDialog by remember { mutableStateOf<List<LiturgicalEventDetails>?>(null) }

    if (showEventSelectionDialog != null) {
        EventSelectionDialog(
            events = showEventSelectionDialog!!,
            viewModel = viewModel,
            onDismiss = { showEventSelectionDialog = null },
            onEventSelected = { event ->
                viewModel.handleEventSelection(event) { navigationAction ->
                    showEventSelectionDialog = null
                    when (navigationAction) {
                        is NavigationAction.NavigateToDay -> onNavigateToDay(navigationAction.path)
                        is NavigationAction.ShowDateEvents -> {
                            onNavigateToDateEvents(navigationAction.title, navigationAction.paths)
                        }
                    }
                }
            }
        )
    }

    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
        when {
            uiState.isLoading && uiState.isDataMissing -> CircularProgressIndicator()
            uiState.isDataMissing -> MissingDataScreen(
                onDownloadClick = { viewModel.forceRefreshData() },
                error = uiState.downloadError,
                isLoading = uiState.isLoading
            )
            else -> Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(top = 16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                MonthYearSelector(
                    yearMonth = uiState.selectedMonth,
                    yearList = uiState.availableYears,
                    onYearSelected = { viewModel.setYear(it) },
                    onMonthSelected = { viewModel.setMonth(it) },
                    onPreviousMonth = { viewModel.changeMonth(-1) },
                    onNextMonth = { viewModel.changeMonth(1) }
                )
                Spacer(modifier = Modifier.height(8.dp))
                DaysOfWeekHeader()
                Divider()
                CalendarGrid(
                    days = uiState.daysInMonth,
                    onDayClick = { day ->
                        if (day.events.isNotEmpty()) {
                            showEventSelectionDialog = day.events
                        }
                    }
                )
                Spacer(modifier = Modifier.height(40.dp))
                LiturgicalYearInfoView(
                    mainInfo = uiState.liturgicalYearInfo,
                    transitionInfo = uiState.liturgicalYearTransitionInfo
                )
            }
        }
    }
}


private fun mapColor(colorName: String?): Color? {
    return when (colorName) {
        "Biały" -> Color.White.copy(alpha = 0.5f)
        "Czerwony" -> Color(0xFFb00024).copy(alpha = 0.8f)
        "Zielony" -> Color.Green.copy(alpha = 0.3f)
        "Fioletowy" -> Color(0xFF8711cf).copy(alpha = 0.7f)
        "Różowy" -> Color(0xFFEF78A1).copy(alpha = 0.8f)
        else -> null
    }
}

@Composable
private fun MissingDataScreen(
    onDownloadClick: () -> Unit,
    error: String?,
    isLoading: Boolean
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(32.dp),
        elevation = CardDefaults.cardElevation(4.dp)
    ) {
        Column(
            modifier = Modifier.padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = "Brak danych kalendarza",
                style = MaterialTheme.typography.titleLarge,
                textAlign = TextAlign.Center
            )
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = "Do poprawnego działania kalendarza wymagane jest pobranie danych. Upewnij się, że masz połączenie z internetem.",
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center
            )
            AnimatedVisibility(visible = error != null) {
                error?.let {
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = it,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }
            Spacer(modifier = Modifier.height(24.dp))
            Button(onClick = onDownloadClick, enabled = !isLoading) {
                if (isLoading) {
                    CircularProgressIndicator(modifier = Modifier.size(24.dp), color = MaterialTheme.colorScheme.onPrimary)
                } else {
                    Text("Pobierz dane")
                }
            }
        }
    }
}

@Composable
private fun LiturgicalYearInfoView(mainInfo: String, transitionInfo: String?) {
    Card(
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = VeryDarkNavy),
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 16.dp, horizontal = 8.dp)
        ) {
            Text(
                text = mainInfo,
                style = MaterialTheme.typography.titleLarge,
                color = SaturatedNavy,
                fontSize = 24.sp,
                textAlign = TextAlign.Center
            )
            AnimatedVisibility(visible = transitionInfo != null) {
                transitionInfo?.let {
                    Text(
                        text = it,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                        modifier = Modifier.padding(top = 8.dp),
                        textAlign = TextAlign.Center
                    )
                }
            }
        }
    }
}

@Composable
private fun MonthYearSelector(
    yearMonth: YearMonth,
    yearList: List<Int>,
    onYearSelected: (Int) -> Unit,
    onMonthSelected: (Int) -> Unit,
    onPreviousMonth: () -> Unit,
    onNextMonth: () -> Unit
) {
    var isYearMenuExpanded by remember { mutableStateOf(false) }
    var isMonthMenuExpanded by remember { mutableStateOf(false) }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp, horizontal = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        IconButton(onClick = onPreviousMonth) {
            Icon(Icons.AutoMirrored.Filled.KeyboardArrowLeft, contentDescription = "Poprzedni miesiąc")
        }
        Row(
            modifier = Modifier.weight(1f),
            horizontalArrangement = Arrangement.Center,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box {
                Text(
                    text = yearMonth.year.toString(),
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier.clickable { isYearMenuExpanded = true }
                )
                DropdownMenu(
                    expanded = isYearMenuExpanded,
                    onDismissRequest = { isYearMenuExpanded = false }
                ) {
                    yearList.forEach { year ->
                        DropdownMenuItem(
                            text = { Text(year.toString()) },
                            onClick = {
                                onYearSelected(year)
                                isYearMenuExpanded = false
                            }
                        )
                    }
                }
            }
            Text(" - ", style = MaterialTheme.typography.titleMedium)
            Box {
                val monthInNominative =
                    yearMonth.month.getDisplayName(TextStyle.FULL_STANDALONE, Locale("pl"))
                Text(
                    text = monthInNominative,
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier.clickable { isMonthMenuExpanded = true }
                )
                DropdownMenu(
                    expanded = isMonthMenuExpanded,
                    onDismissRequest = { isMonthMenuExpanded = false }
                ) {
                    Month.entries.forEachIndexed { index, month ->
                        DropdownMenuItem(
                            text = {
                                Text(
                                    month.getDisplayName(
                                        TextStyle.FULL_STANDALONE,
                                        Locale("pl")
                                    )
                                )
                            },
                            onClick = {
                                onMonthSelected(index)
                                isMonthMenuExpanded = false
                            }
                        )
                    }
                }
            }
        }
        IconButton(onClick = onNextMonth) {
            Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = "Następny miesiąc")
        }
    }
}

@Composable
private fun DaysOfWeekHeader() {
    val daysOfWeek = listOf("Pn", "Wt", "Śr", "Cz", "Pt", "So", "Nd")
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp, horizontal = 16.dp),
        horizontalArrangement = Arrangement.SpaceAround
    ) {
        daysOfWeek.forEach { day ->
            Text(text = day, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center)
        }
    }
}

@Composable
private fun CalendarGrid(days: List<CalendarDay?>, onDayClick: (CalendarDay) -> Unit) {
    LazyVerticalGrid(
        columns = GridCells.Fixed(7),
        modifier = Modifier.padding(horizontal = 16.dp),
        userScrollEnabled = false
    ) {
        items(days) { day ->
            if (day != null) {
                DayCell(day = day, onClick = { onDayClick(day) })
            } else {
                Box(modifier = Modifier.aspectRatio(1f))
            }
        }
    }
}

@Composable
private fun DayCell(day: CalendarDay, onClick: () -> Unit) {
    val textColor = MaterialTheme.colorScheme.onSurface
    var cellModifier = Modifier
        .aspectRatio(1f)
        .padding(4.dp)
        .clip(CircleShape)

    mapColor(day.dominantEventColorName)?.let {
        cellModifier = cellModifier.background(it)
    }

    if (day.isToday) {
        cellModifier = cellModifier.border(2.dp, Gold, CircleShape)
    }
    if (day.hasEvents) {
        cellModifier = cellModifier.clickable(onClick = onClick)
    }
    Box(
        modifier = cellModifier,
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = day.dayOfMonth.toString(),
            color = textColor,
            textAlign = TextAlign.Center
        )
    }
}

@Composable
fun EventSelectionDialog(
    events: List<LiturgicalEventDetails>,
    viewModel: CalendarViewModel,
    onDismiss: () -> Unit,
    onEventSelected: (LiturgicalEventDetails) -> Unit
) {
    val sortedEvents = remember(events) {
        events.sortedWith(viewModel.calendarRepo.eventComparator)
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    text = "Wybierz wydarzenie",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                LazyColumn(modifier = Modifier.heightIn(max = 400.dp)) {
                    items(sortedEvents, key = { it.name }) { event ->
                        Text(
                            text = event.name,
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { onEventSelected(event) }
                                .padding(vertical = 12.dp),
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }
                }

                Spacer(Modifier.height(24.dp))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Anuluj")
                    }
                }
            }
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\calendar\CalendarViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.calendar

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.io.File
import java.time.DayOfWeek
import java.time.LocalDate
import java.time.YearMonth

data class CalendarUiState(
    val selectedMonth: YearMonth = YearMonth.now(),
    val daysInMonth: List<CalendarDay?> = emptyList(),
    val availableYears: List<Int> = emptyList(),
    val isDataMissing: Boolean = true,
    val isLoading: Boolean = false,
    val liturgicalYearInfo: String = "",
    val liturgicalYearTransitionInfo: String? = null,
    val downloadError: String? = null
)

class CalendarViewModel(
    val calendarRepo: CalendarRepository,
    private val fileSystemRepo: FileSystemRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(CalendarUiState())
    val uiState = _uiState.asStateFlow()

    init {
        checkAndLoadInitialData()
    }

    private fun checkAndLoadInitialData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val currentYear = YearMonth.now().year
            val isCurrentYearAvailable = calendarRepo.isYearAvailable(currentYear)

            if (!isCurrentYearAvailable) {
                _uiState.update { it.copy(isDataMissing = true, isLoading = true) }
                forceRefreshData()
            } else {
                val availableYears = calendarRepo.getAvailableYears()
                _uiState.update { it.copy(isDataMissing = false, availableYears = availableYears, isLoading = false) }
                loadDataForMonth(YearMonth.now())
                // Sprawdź w tle przyszły rok bez blokowania UI
                viewModelScope.launch { calendarRepo.downloadAndSaveYearIfNeeded(currentYear + 1) }
            }
        }
    }

    fun forceRefreshData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, downloadError = null) }

            // Krok 1: Usuń stare pliki
            calendarRepo.deleteAllCalendarFiles()

            // Krok 2: Pobierz nowe dane
            val currentYear = YearMonth.now().year
            val nextYear = currentYear + 1
            var firstError: Throwable? = null

            calendarRepo.downloadAndSaveYearIfNeeded(currentYear).onFailure { error ->
                if (firstError == null) firstError = error
            }
            calendarRepo.downloadAndSaveYearIfNeeded(nextYear).onFailure { error ->
                if (firstError == null) firstError = error
            }

            // Krok 3: Zaktualizuj UI
            val availableYears = calendarRepo.getAvailableYears()
            val isCurrentYearNowAvailable = availableYears.contains(currentYear)

            _uiState.update {
                it.copy(
                    isLoading = false,
                    isDataMissing = !isCurrentYearNowAvailable,
                    availableYears = availableYears,
                    downloadError = if (isCurrentYearNowAvailable) null else "Błąd: ${firstError?.message ?: "Nieznany błąd"}"
                )
            }

            if (isCurrentYearNowAvailable) {
                loadDataForMonth(_uiState.value.selectedMonth)
            }
        }
    }

    private suspend fun loadDataForMonth(yearMonth: YearMonth) {
        val liturgicalYearData = calendarRepo.getLiturgicalYear(yearMonth.year)
        if (liturgicalYearData == null) {
            _uiState.update { it.copy(daysInMonth = emptyList()) }
            return
        }

        val today = LocalDate.now()
        val firstDayOfMonth = yearMonth.atDay(1).dayOfWeek
        val firstDayOfMonthOffset = (firstDayOfMonth.value - DayOfWeek.MONDAY.value + 7) % 7
        val daysInMonthCount = yearMonth.lengthOfMonth()

        val calendarDays = mutableListOf<CalendarDay?>()
        repeat(firstDayOfMonthOffset) { calendarDays.add(null) }

        for (day in 1..daysInMonthCount) {
            val date = yearMonth.atDay(day)
            val eventsForDay = liturgicalYearData.eventsForDate(date)
            val dominantEvent = calendarRepo.getDominantEvent(eventsForDay)

            calendarDays.add(
                CalendarDay(
                    dayOfMonth = day,
                    month = yearMonth,
                    isToday = date == today,
                    events = eventsForDay,
                    dominantEventColorName = dominantEvent?.kolor
                )
            )
        }

        val yearInfo = calendarRepo.getLiturgicalYearInfoForMonth(yearMonth, liturgicalYearData)

        _uiState.update {
            it.copy(
                selectedMonth = yearMonth,
                daysInMonth = calendarDays,
                liturgicalYearInfo = yearInfo.mainInfo,
                liturgicalYearTransitionInfo = yearInfo.transitionInfo
            )
        }
    }

    fun handleEventSelection(event: LiturgicalEventDetails, onResult: (NavigationAction) -> Unit) {
        viewModelScope.launch {
            val foundPaths = findFilePathsForEvent(event.name)

            when {
                foundPaths.isEmpty() -> {
                    // Nie znaleziono nic, utwórz nowy plik
                    val result = fileSystemRepo.createDayFile("Datowane/nieznane", event.name, null)
                    result.onSuccess { newFileName ->
                        val newPath = "Datowane/nieznane/$newFileName"
                        onResult(NavigationAction.NavigateToDay(newPath))
                    }
                }
                foundPaths.size == 1 -> {
                    // Znaleziono dokładnie jeden plik, nawiguj bezpośrednio
                    onResult(NavigationAction.NavigateToDay(foundPaths.first()))
                }
                else -> {
                    // Znaleziono wiele plików (w folderze), pokaż ekran wyboru
                    onResult(NavigationAction.ShowDateEvents(event.name, foundPaths))
                }
            }
        }
    }

    private fun findFilePathsForEvent(name: String): List<String> {
        val results = mutableListOf<String>()
        val dataDir = File(fileSystemRepo.context.filesDir, "data")
        val datowaneDir = File(fileSystemRepo.context.filesDir, "Datowane")

        // Przeszukaj oba katalogi i zbierz wszystkie wyniki
        findPathsRecursiveHelper(dataDir, name, results)
        findPathsRecursiveHelper(datowaneDir, name, results)

        // Zwróć unikalne i posortowane ścieżki
        return results.distinct().sorted()
    }

    private fun findPathsRecursiveHelper(directory: File, name: String, results: MutableList<String>) {
        if (!directory.exists() || !directory.isDirectory) return

        val items = directory.listFiles() ?: return

        for (item in items) {
            val itemNameWithoutExt = if (item.isDirectory) item.name else item.nameWithoutExtension
            if (itemNameWithoutExt.equals(name, ignoreCase = true)) {
                if (item.isDirectory) {
                    item.walk()
                        .filter { it.isFile && it.extension.equals("json", ignoreCase = true) }
                        .forEach { file ->
                            results.add(file.absolutePath.removePrefix(fileSystemRepo.context.filesDir.absolutePath + "/"))
                        }
                } else if (item.isFile && item.extension.equals("json", ignoreCase = true)) {
                    results.add(item.absolutePath.removePrefix(fileSystemRepo.context.filesDir.absolutePath + "/"))
                }
            }
        }

        // Kontynuuj rekurencyjnie, aby znaleźć wszystkie dopasowania
        for (item in items) {
            if (item.isDirectory) {
                findPathsRecursiveHelper(item, name, results)
            }
        }
    }


    fun changeMonth(amount: Long) {
        val newMonth = _uiState.value.selectedMonth.plusMonths(amount)
        if (isYearAvailable(newMonth.year)) {
            viewModelScope.launch { loadDataForMonth(newMonth) }
        }
    }

    fun setYear(year: Int) {
        if (isYearAvailable(year)) {
            val newMonth = _uiState.value.selectedMonth.withYear(year)
            viewModelScope.launch { loadDataForMonth(newMonth) }
        }
    }

    fun setMonth(monthIndex: Int) {
        val newMonth = _uiState.value.selectedMonth.withMonth(monthIndex + 1)
        if (isYearAvailable(newMonth.year)) {
            viewModelScope.launch { loadDataForMonth(newMonth) }
        }
    }

    fun resetToCurrentMonth() {
        viewModelScope.launch { loadDataForMonth(YearMonth.now()) }
    }

    private fun isYearAvailable(year: Int): Boolean {
        return _uiState.value.availableYears.contains(year)
    }
}
class CalendarViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(CalendarViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return CalendarViewModel(
                CalendarRepository(context.applicationContext),
                FileSystemRepository(context.applicationContext)
            ) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\calendar\TranslationMap.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.calendar

internal val translationMap: Map<String, String> = mapOf(
    "Czwartek I tygodnia Adwentu" to "1 Czwartek Adwentu",
    "Piątek I tygodnia Adwentu" to "1 Piątek Adwentu",
    "Poniedziałek I tygodnia Adwentu" to "1 Poniedziałek Adwentu",
    "Sobota I tygodnia Adwentu" to "1 Sobota Adwentu",
    "Wtorek I tygodnia Adwentu" to "1 Wtorek Adwentu",
    "Środa I tygodnia Adwentu" to "1 Środa Adwentu",
    "I Niedziela Adwentu" to "1 Niedziela Adwentu",
    "Czwartek II tygodnia Adwentu" to "2 Czwartek Adwentu",
    "Piątek II tygodnia Adwentu" to "2 Piątek Adwentu",
    "Poniedziałek II tygodnia Adwentu" to "2 Poniedziałek Adwentu",
    "Sobota II tygodnia Adwentu" to "2 Sobota Adwentu",
    "Wtorek II tygodnia Adwentu" to "2 Wtorek Adwentu",
    "Środa II tygodnia Adwentu" to "2 Środa Adwentu",
    "II Niedziela Adwentu" to "2 Niedziela Adwentu",
    "Czwartek III tygodnia Adwentu" to "3 Czwartek Adwentu",
    "Piątek III tygodnia Adwentu" to "3 Piątek Adwentu",
    "Poniedziałek III tygodnia Adwentu" to "3 Poniedziałek Adwentu",
    "Wtorek III tygodnia Adwentu" to "3 Wtorek Adwentu",
    "Środa III tygodnia Adwentu" to "3 Środa Adwentu",
    "III Niedziela Adwentu" to "3 Niedziela Adwentu",
    "IV Niedziela Adwentu" to "4 Niedziela Adwentu",
    "Dzień adwentu (17 grudnia)" to "17 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (18 grudnia)" to "18 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (19 grudnia)" to "19 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (20 grudnia)" to "20 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (21 grudnia)" to "21 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (22 grudnia)" to "22 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (23 grudnia)" to "23 grudnia - Dzień powszedni w okresie Adwentu",
    "Dzień adwentu (24 grudnia)" to "24 grudnia - Dzień powszedni w okresie Adwentu",
    "Św. Barnaby, Apostoła" to "11 czerwca - św. Barnaby Apostoła",
    "Narodzenie św. Jana Chrzciciela" to "24 czerwca - Uroczystość Narodzenia św. Jana Chrzciciela",
    "Świętych Apostołów Piotra i Pawła" to "29 czerwca - Uroczystość św. Apostołów Piotra i Pawła",
    "Niepokalane poczęcie Najświętszej Maryi Panny" to "8 grudnia - Uroczystość Niepokalanego Poczęcia NMP",
    "Św. Wojciecha, biskupa i męczennika" to "23 kwietnia - Uroczystość św. Wojciecha, biskupa i męczennika, głównego patrona Polski",
    "Św. Marka, Ewangelisty" to "25 kwietnia - św. Marka Ewangelisty",
    "Św. Katarzyny Sieneńskiej, dziewicy i doktora Kościoła" to "29 kwietnia - św. Katarzyny ze Sieny, dziewicy i doktora Kościoła",
    "Św. Benedykta, opata" to "11 lipca - św. Benedykta, patrona Europy",
    "Św. Marii Magdaleny" to "22 lipca - Święto św. Marii Magdaleny",
    "Św. Brygidy, zakonnicy" to "23 lipca - Święto św. Brygidy, patronki Europy",
    "Św. Jakuba, Apostoła" to "25 lipca - św. Jakuba Apostoła",
    "Świętych Marty, Marii i Łazarza" to "29 lipca - św. Marty",
    "Św. Tomasza, Apostoła" to "3 lipca - św. Tomasza Apostoła",
    "Wszystkich Świętych" to "1 listopada - Uroczystość Wszystkich Świętych",
    "Wspomnienie wszystkich wiernych zmarłych" to "2 listopada - Wspomnienie Wszystkich Wiernych Zmarłych",
    "Ofiarowanie Najświętszej Maryi Panny" to "21 listopada - Ofiarowanie Najświętszej Maryi Panny",
    "Św. Andrzeja, Apostoła" to "30 listopada - św. Andrzeja Apostoła",
    "Rocznica poświęcenia Bazyliki Laterańskiej" to "9 listopada - Rocznica poświęcenia Bazyliki Laterańskiej",
    "Świętych Cyryla, mnicha i Metodego, biskupa" to "14 lutego - św. Cyryla i Metodego, patronów Europy",
    "Ofiarowanie Pańskie" to "2 lutego - Ofiarowanie Pańskie",
    "Św. Józefa, rzemieślnika" to "1 maja - św. Józefa rzemieślnika",
    "Św. Macieja, Apostoła" to "14 maja - św. Macieja Apostoła",
    "Św. Andrzeja Boboli, prezbitera i męczennika" to "16 maja - św. Andrzeja Boboli",
    "Najświętszej Maryi Panny, Królowej Polski" to "3 maja - Uroczystość NMP Królowej Polski",
    "Świętych Apostołów Filipa i Jakuba" to "6 maja - św. Apostołów Filipa i Jakuba",
    "Św. Stanisława, biskupa i męczennika" to "8 maja - Uroczystość św. Stanisława, głównego patrona Polski",
    "Św. Józefa, Oblubieńca Najświętszej Maryi Panny" to "19 marca - Uroczystość św. Józefa, Oblubieńca NMP",
    "Zwiastowanie Pańskie" to "25 marca - Uroczystość Zwiastowania Pańskiego",
    "Św. Kazimierza" to "4 marca - św. Kazimierza królewicza",
    "Świętych Aniołów Stróżów" to "2 października - Świętych Aniołów Stróżów",
    "Najświętszej Maryi Panny Częstochowskiej" to "26 sierpnia - Uroczystość NMP Częstochowskiej",
    "Świętych Apostołów Szymona i Judy Tadeusza" to "28 października - św. Apostołów Szymona i Judy Tadeusza",
    "Męczeństwo św. Jana Chrzciciela" to "29 sierpnia - Męczeństwo św. Jana Chrzciciela",
    "Św. Wawrzyńca, diakona i męczennika" to "10 sierpnia - św. Wawrzyńca",
    "Św. Maksymiliana Marii Kolbego, prezbitera i męczennika" to "14 sierpnia - św. Maksymiliana Marii Kolbego",
    "Wniebowzięcie Najświętszej Maryi Panny" to "15 sierpnia - Uroczystość Wniebowzięcia NMP",
    "Najświętszej Maryi Panny, Królowej" to "22 sierpnia - NMP Królowej Polski",
    "Św. Bartłomieja, Apostoła" to "24 sierpnia - Święto św. Bartłomieja, Apostoła",
    "Przemienienie Pańskie" to "6 sierpnia - Święto Przemienienia Pańskiego",
    "Świętych biskupów Tymoteusza i Tytusa" to "26 stycznia - św. biskupów Tymoteusza i Tytusa",
    "Podwyższenie Krzyża Świętego" to "14 września - Święto Podwyższenia Krzyża Świętego",
    "Najświętszej Maryi Panny Bolesnej" to "15 września - NMP Bolesnej",
    "Św. Stanisława Kostki, zakonnika" to "18 września - św. Stanisława Kostki, zakonnika, patrona Polski",
    "Św. Mateusza, Apostoła i Ewangelisty" to "21 września - Święto św. Mateusza, Apostoła i Ewangelisty",
    "Świętych Archaniołów Michała, Gabriela i Rafała" to "29 września - Święto św. Archaniołów Michała, Gabriela i Rafała",
    "Narodzenie Najświętszej Maryi Panny" to "8 września - Narodzenie NMP",
    "Świętej Bożej Rodzicielki Maryi" to "1 stycznia - Uroczystość Świętej Bożej Rodzicielki Maryi",
    "Chrzest Pański" to "Niedziela Chrztu Pańskiego",
    "II Niedziela po Bożym Narodzeniu" to "2 Niedziela po Narodzeniu Pańskim",
    "Świętych Bazylego Wielkiego i Grzegorza z Nazjanzu, biskupów i doktorów Kościoła" to "2 stycznia - Dzień powszedni w Okresie Narodzenia Pańskiego",
    "Narodzenie Pańskie" to "25 grudnia - Uroczystość Narodzenia Pańskiego",
    "Św. Szczepana, pierwszego męczennika" to "26 grudnia - Święto św. Szczepana, pierwszego męczennika",
    "Świętych Młodziaków, męczenników" to "28 grudnia - Święto Świętych Młodzianków, męczenników",
    "V dzień w oktawie Narodzenia Pańskiego" to "29 grudnia - Piąty dzień w oktawie Narodzenia Pańskiego",
    "VI dzień w oktawie Narodzenia Pańskiego" to "30 grudnia - Szósty dzień w oktawie Narodzenia Pańskiego",
    "VII dzień w oktawie Narodzenia Pańskiego" to "31 grudnia - Siódmy dzień w oktawie Narodzenia Pańskiego",
    "Objawienie Pańskie" to "6 stycznia - Uroczystość Objawienia Pańskiego",
    "Świętej Rodziny Jezusa, Maryi i Józefa" to "Niedziela w oktawie Narodzenia Pańskiego - Święto Świętej Rodziny",
    "Czwartek w Oktawie Wielkanocy" to "Czwartek w Oktawie Wielkanocy",
    "Niedziela Zmartwychwstania Pańskiego" to "Niedziela Zmartwychwstania Pańskiego",
    "Piątek w Oktawie Wielkanocy" to "Piątek w Oktawie Wielkanocy",
    "Poniedziałek w Oktawie Wielkanocy" to "Poniedziałek w Oktawie Wielkanocy",
    "Sobota w Oktawie Wielkanocy" to "Sobota w Oktawie Wielkanocy",
    "Wtorek w Oktawie Wielkanocy" to "Wtorek w Oktawie Wielkanocy",
    "Środa w Oktawie Wielkanocy" to "Środa w Oktawie Wielkanocy",
    "Czwartek II Tygodnia Wielkanocnego" to "2 Czwartek Okresu Wielkanocnego",
    "Piątek II Tygodnia Wielkanocnego" to "2 Piątek Okresu Wielkanocnego",
    "Poniedziałek II Tygodnia Wielkanocnego" to "2 Poniedziałek Okresu Wielkanocnego",
    "Sobota II Tygodnia Wielkanocnego" to "2 Sobota Okresu Wielkanocnego",
    "Wtorek II Tygodnia Wielkanocnego" to "2 Wtorek Okresu Wielkanocnego",
    "Środa II Tygodnia Wielkanocnego" to "2 Środa Okresu Wielkanocnego",
    "II Niedziela Wielkanocna czyli Miłosierdzia Bożego" to "2 Niedziela Okresu Wielkanocnego",
    "Czwartek III Tygodnia Wielkanocnego" to "3 Czwartek Okresu Wielkanocnego",
    "Piątek III Tygodnia Wielkanocnego" to "3 Piątek Okresu Wielkanocnego",
    "Poniedziałek III Tygodnia Wielkanocnego" to "3 Poniedziałek Okresu Wielkanocnego",
    "Sobota III Tygodnia Wielkanocnego" to "3 Sobota Okresu Wielkanocnego",
    "Wtorek III Tygodnia Wielkanocnego" to "3 Wtorek Okresu Wielkanocnego",
    "Środa III Tygodnia Wielkanocnego" to "3 Środa Okresu Wielkanocnego",
    "III Niedziela Wielkanocna" to "3 Niedziela Okresu Wielkanocnego",
    "Czwartek IV Tygodnia Wielkanocnego" to "4 Czwartek Okresu Wielkanocnego",
    "Piątek IV Tygodnia Wielkanocnego" to "4 Piątek Okresu Wielkanocnego",
    "Poniedziałek IV Tygodnia Wielkanocnego" to "4 Poniedziałek Okresu Wielkanocnego",
    "Sobota IV Tygodnia Wielkanocnego" to "4 Sobota Okresu Wielkanocnego",
    "Wtorek IV Tygodnia Wielkanocnego" to "4 Wtorek Okresu Wielkanocnego",
    "Środa IV Tygodnia Wielkanocnego" to "4 Środa Okresu Wielkanocnego",
    "IV Niedziela Wielkanocna" to "4 Niedziela Okresu Wielkanocnego",
    "Czwartek V Tygodnia Wielkanocnego" to "5 Czwartek Okresu Wielkanocnego",
    "Piątek V Tygodnia Wielkanocnego" to "5 Piątek Okresu Wielkanocnego",
    "Poniedziałek V Tygodnia Wielkanocnego" to "5 Poniedziałek Okresu Wielkanocnego",
    "Sobota V Tygodnia Wielkanocnego" to "5 Sobota Okresu Wielkanocnego",
    "Wtorek V Tygodnia Wielkanocnego" to "5 Wtorek Okresu Wielkanocnego",
    "Środa V Tygodnia Wielkanocnego" to "5 Środa Okresu Wielkanocnego",
    "V Niedziela Wielkanocna" to "5 Niedziela Okresu Wielkanocnego",
    "Czwartek VI Tygodnia Wielkanocnego" to "6 Czwartek Okresu Wielkanocnego",
    "Piątek VI Tygodnia Wielkanocnego" to "6 Piątek Okresu Wielkanocnego",
    "Poniedziałek VI Tygodnia Wielkanocnego" to "6 Poniedziałek Okresu Wielkanocnego",
    "Sobota VI Tygodnia Wielkanocnego" to "6 Sobota Okresu Wielkanocnego",
    "Wtorek VI Tygodnia Wielkanocnego" to "6 Wtorek Okresu Wielkanocnego",
    "Środa VI Tygodnia Wielkanocnego" to "6 Środa Okresu Wielkanocnego",
    "VI Niedziela Wielkanocna" to "6 Niedziela Okresu Wielkanocnego",
    "Czwartek VII Tygodnia Wielkanocnego" to "7 Czwartek Okresu Wielkanocnego",
    "Piątek VII Tygodnia Wielkanocnego" to "7 Piątek Okresu Wielkanocnego",
    "Poniedziałek VII Tygodnia Wielkanocnego" to "7 Poniedziałek Okresu Wielkanocnego",
    "Sobota VII Tygodnia Wielkanocnego" to "7 Sobota Okresu Wielkanocnego",
    "Wtorek VII Tygodnia Wielkanocnego" to "7 Wtorek Okresu Wielkanocnego",
    "Środa VII Tygodnia Wielkanocnego" to "7 Środa Okresu Wielkanocnego",
    "VII Niedziela Wielkanocna" to "7 Niedziela Okresu Wielkanocnego",
    "Wniebowstąpienie Pańskie" to "Uroczystość Wniebowstąpienia Pańskiego",
    "Czwartek I tygodnia zwykłego" to "1 Czwartek Okresu Zwykłego",
    "Piątek I tygodnia zwykłego" to "1 Piątek Okresu Zwykłego",
    "Poniedziałek I tygodnia zwykłego" to "1 Poniedziałek Okresu Zwykłego",
    "Sobota I tygodnia zwykłego" to "1 Sobota Okresu Zwykłego",
    "Wtorek I tygodnia zwykłego" to "1 Wtorek Okresu Zwykłego",
    "Środa I tygodnia zwykłego" to "1 Środa Okresu Zwykłego",
    "Czwartek X tygodnia zwykłego" to "10 Czwartek Okresu Zwykłego",
    "X Niedziela Zwykła" to "10 Niedziela Okresu Zwykłego",
    "Piątek X tygodnia zwykłego" to "10 Piątek Okresu Zwykłego",
    "Poniedziałek X tygodnia zwykłego" to "10 Poniedziałek Okresu Zwykłego",
    "Sobota X tygodnia zwykłego" to "10 Sobota Okresu Zwykłego",
    "Wtorek X tygodnia zwykłego" to "10 Wtorek Okresu Zwykłego",
    "Środa X tygodnia zwykłego" to "10 Środa Okresu Zwykłego",
    "Czwartek XI tygodnia zwykłego" to "11 Czwartek Okresu Zwykłego",
    "XI Niedziela Zwykła" to "11 Niedziela Okresu Zwykłego",
    "Piątek XI tygodnia zwykłego" to "11 Piątek Okresu Zwykłego",
    "Poniedziałek XI tygodnia zwykłego" to "11 Poniedziałek Okresu Zwykłego",
    "Sobota XI tygodnia zwykłego" to "11 Sobota Okresu Zwykłego",
    "Wtorek XI tygodnia zwykłego" to "11 Wtorek Okresu Zwykłego",
    "Środa XI tygodnia zwykłego" to "11 Środa Okresu Zwykłego",
    "Czwartek XII tygodnia zwykłego" to "12 Czwartek Okresu Zwykłego",
    "XII Niedziela Zwykła" to "12 Niedziela Okresu Zwykłego",
    "Piątek XII tygodnia zwykłego" to "12 Piątek Okresu Zwykłego",
    "Poniedziałek XII tygodnia zwykłego" to "12 Poniedziałek Okresu Zwykłego",
    "Sobota XII tygodnia zwykłego" to "12 Sobota Okresu Zwykłego",
    "Wtorek XII tygodnia zwykłego" to "12 Wtorek Okresu Zwykłego",
    "Środa XII tygodnia zwykłego" to "12 Środa Okresu Zwykłego",
    "Czwartek XIII tygodnia zwykłego" to "13 Czwartek Okresu Zwykłego",
    "XIII Niedziela Zwykła" to "13 Niedziela Okresu Zwykłego",
    "Piątek XIII tygodnia zwykłego" to "13 Piątek Okresu Zwykłego",
    "Poniedziałek XIII tygodnia zwykłego" to "13 Poniedziałek Okresu Zwykłego",
    "Sobota XIII tygodnia zwykłego" to "13 Sobota Okresu Zwykłego",
    "Wtorek XIII tygodnia zwykłego" to "13 Wtorek Okresu Zwykłego",
    "Środa XIII tygodnia zwykłego" to "13 Środa Okresu Zwykłego",
    "Czwartek XIV tygodnia zwykłego" to "14 Czwartek Okresu Zwykłego",
    "XIV Niedziela Zwykła" to "14 Niedziela Okresu Zwykłego",
    "Piątek XIV tygodnia zwykłego" to "14 Piątek Okresu Zwykłego",
    "Poniedziałek XIV tygodnia zwykłego" to "14 Poniedziałek Okresu Zwykłego",
    "Sobota XIV tygodnia zwykłego" to "14 Sobota Okresu Zwykłego",
    "Wtorek XIV tygodnia zwykłego" to "14 Wtorek Okresu Zwykłego",
    "Środa XIV tygodnia zwykłego" to "14 Środa Okresu Zwykłego",
    "Czwartek XV tygodnia zwykłego" to "15 Czwartek Okresu Zwykłego",
    "XV Niedziela Zwykła" to "15 Niedziela Okresu Zwykłego",
    "Piątek XV tygodnia zwykłego" to "15 Piątek Okresu Zwykłego",
    "Poniedziałek XV tygodnia zwykłego" to "15 Poniedziałek Okresu Zwykłego",
    "Sobota XV tygodnia zwykłego" to "15 Sobota Okresu Zwykłego",
    "Wtorek XV tygodnia zwykłego" to "15 Wtorek Okresu Zwykłego",
    "Środa XV tygodnia zwykłego" to "15 Środa Okresu Zwykłego",
    "Czwartek XVI tygodnia zwykłego" to "16 Czwartek Okresu Zwykłego",
    "XVI Niedziela Zwykła" to "16 Niedziela Okresu Zwykłego",
    "Piątek XVI tygodnia zwykłego" to "16 Piątek Okresu Zwykłego",
    "Poniedziałek XVI tygodnia zwykłego" to "16 Poniedziałek Okresu Zwykłego",
    "Sobota XVI tygodnia zwykłego" to "16 Sobota Okresu Zwykłego",
    "Wtorek XVI tygodnia zwykłego" to "16 Wtorek Okresu Zwykłego",
    "Środa XVI tygodnia zwykłego" to "16 Środa Okresu Zwykłego",
    "Czwartek XVII tygodnia zwykłego" to "17 Czwartek Okresu Zwykłego",
    "XVII Niedziela Zwykła" to "17 Niedziela Okresu Zwykłego",
    "Piątek XVII tygodnia zwykłego" to "17 Piątek Okresu Zwykłego",
    "Poniedziałek XVII tygodnia zwykłego" to "17 Poniedziałek Okresu Zwykłego",
    "Sobota XVII tygodnia zwykłego" to "17 Sobota Okresu Zwykłego",
    "Wtorek XVII tygodnia zwykłego" to "17 Wtorek Okresu Zwykłego",
    "Środa XVII tygodnia zwykłego" to "17 Środa Okresu Zwykłego",
    "Czwartek XVIII tygodnia zwykłego" to "18 Czwartek Okresu Zwykłego",
    "XVIII Niedziela Zwykła" to "18 Niedziela Okresu Zwykłego",
    "Piątek XVIII tygodnia zwykłego" to "18 Piątek Okresu Zwykłego",
    "Poniedziałek XVIII tygodnia zwykłego" to "18 Poniedziałek Okresu Zwykłego",
    "Sobota XVIII tygodnia zwykłego" to "18 Sobota Okresu Zwykłego",
    "Wtorek XVIII tygodnia zwykłego" to "18 Wtorek Okresu Zwykłego",
    "Środa XVIII tygodnia zwykłego" to "18 Środa Okresu Zwykłego",
    "Czwartek XIX tygodnia zwykłego" to "19 Czwartek Okresu Zwykłego",
    "XIX Niedziela Zwykła" to "19 Niedziela Okresu Zwykłego",
    "Piątek XIX tygodnia zwykłego" to "19 Piątek Okresu Zwykłego",
    "Poniedziałek XIX tygodnia zwykłego" to "19 Poniedziałek Okresu Zwykłego",
    "Sobota XIX tygodnia zwykłego" to "19 Sobota Okresu Zwykłego",
    "Wtorek XIX tygodnia zwykłego" to "19 Wtorek Okresu Zwykłego",
    "Środa XIX tygodnia zwykłego" to "19 Środa Okresu Zwykłego",
    "Czwartek II tygodnia zwykłego" to "2 Czwartek Okresu Zwykłego",
    "II Niedziela Zwykła" to "2 Niedziela Okresu Zwykłego",
    "Piątek II tygodnia zwykłego" to "2 Piątek Okresu Zwykłego",
    "Poniedziałek II tygodnia zwykłego" to "2 Poniedziałek Okresu Zwykłego",
    "Sobota II tygodnia zwykłego" to "2 Sobota Okresu Zwykłego",
    "Wtorek II tygodnia zwykłego" to "2 Wtorek Okresu Zwykłego",
    "Środa II tygodnia zwykłego" to "2 Środa Okresu Zwykłego",
    "Czwartek XX tygodnia zwykłego" to "20 Czwartek Okresu Zwykłego",
    "XX Niedziela Zwykła" to "20 Niedziela Okresu Zwykłego",
    "Piątek XX tygodnia zwykłego" to "20 Piątek Okresu Zwykłego",
    "Poniedziałek XX tygodnia zwykłego" to "20 Poniedziałek Okresu Zwykłego",
    "Sobota XX tygodnia zwykłego" to "20 Sobota Okresu Zwykłego",
    "Wtorek XX tygodnia zwykłego" to "20 Wtorek Okresu Zwykłego",
    "Środa XX tygodnia zwykłego" to "20 Środa Okresu Zwykłego",
    "Czwartek XXI tygodnia zwykłego" to "21 Czwartek Okresu Zwykłego",
    "XXI Niedziela Zwykła" to "21 Niedziela Okresu Zwykłego",
    "Piątek XXI tygodnia zwykłego" to "21 Piątek Okresu Zwykłego",
    "Poniedziałek XXI tygodnia zwykłego" to "21 Poniedziałek Okresu Zwykłego",
    "Sobota XXI tygodnia zwykłego" to "21 Sobota Okresu Zwykłego",
    "Wtorek XXI tygodnia zwykłego" to "21 Wtorek Okresu Zwykłego",
    "Środa XXI tygodnia zwykłego" to "21 Środa Okresu Zwykłego",
    "Czwartek XXII tygodnia zwykłego" to "22 Czwartek Okresu Zwykłego",
    "XXII Niedziela Zwykła" to "22 Niedziela Okresu Zwykłego",
    "Piątek XXII tygodnia zwykłego" to "22 Piątek Okresu Zwykłego",
    "Poniedziałek XXII tygodnia zwykłego" to "22 Poniedziałek Okresu Zwykłego",
    "Sobota XXII tygodnia zwykłego" to "22 Sobota Okresu Zwykłego",
    "Wtorek XXII tygodnia zwykłego" to "22 Wtorek Okresu Zwykłego",
    "Środa XXII tygodnia zwykłego" to "22 Środa Okresu Zwykłego",
    "Czwartek XXIII tygodnia zwykłego" to "23 Czwartek Okresu Zwykłego",
    "XXIII Niedziela Zwykła" to "23 Niedziela Okresu Zwykłego",
    "Piątek XXIII tygodnia zwykłego" to "23 Piątek Okresu Zwykłego",
    "Poniedziałek XXIII tygodnia zwykłego" to "23 Poniedziałek Okresu Zwykłego",
    "Sobota XXIII tygodnia zwykłego" to "23 Sobota Okresu Zwykłego",
    "Wtorek XXIII tygodnia zwykłego" to "23 Wtorek Okresu Zwykłego",
    "Środa XXIII tygodnia zwykłego" to "23 Środa Okresu Zwykłego",
    "Czwartek XXIV tygodnia zwykłego" to "24 Czwartek Okresu Zwykłego",
    "XXIV Niedziela Zwykła" to "24 Niedziela Okresu Zwykłego",
    "Piątek XXIV tygodnia zwykłego" to "24 Piątek Okresu Zwykłego",
    "Poniedziałek XXIV tygodnia zwykłego" to "24 Poniedziałek Okresu Zwykłego",
    "Sobota XXIV tygodnia zwykłego" to "24 Sobota Okresu Zwykłego",
    "Wtorek XXIV tygodnia zwykłego" to "24 Wtorek Okresu Zwykłego",
    "Środa XXIV tygodnia zwykłego" to "24 Środa Okresu Zwykłego",
    "Czwartek XXV tygodnia zwykłego" to "25 Czwartek Okresu Zwykłego",
    "XXV Niedziela Zwykła" to "25 Niedziela Okresu Zwykłego",
    "Piątek XXV tygodnia zwykłego" to "25 Piątek Okresu Zwykłego",
    "Poniedziałek XXV tygodnia zwykłego" to "25 Poniedziałek Okresu Zwykłego",
    "Sobota XXV tygodnia zwykłego" to "25 Sobota Okresu Zwykłego",
    "Wtorek XXV tygodnia zwykłego" to "25 Wtorek Okresu Zwykłego",
    "Środa XXV tygodnia zwykłego" to "25 Środa Okresu Zwykłego",
    "Czwartek XXVI tygodnia zwykłego" to "26 Czwartek Okresu Zwykłego",
    "XXVI Niedziela Zwykła" to "26 Niedziela Okresu Zwykłego",
    "Piątek XXVI tygodnia zwykłego" to "26 Piątek Okresu Zwykłego",
    "Poniedziałek XXVI tygodnia zwykłego" to "26 Poniedziałek Okresu Zwykłego",
    "Sobota XXVI tygodnia zwykłego" to "26 Sobota Okresu Zwykłego",
    "Wtorek XXVI tygodnia zwykłego" to "26 Wtorek Okresu Zwykłego",
    "Środa XXVI tygodnia zwykłego" to "26 Środa Okresu Zwykłego",
    "Czwartek XXVII tygodnia zwykłego" to "27 Czwartek Okresu Zwykłego",
    "XXVII Niedziela Zwykła" to "27 Niedziela Okresu Zwykłego",
    "Piątek XXVII tygodnia zwykłego" to "27 Piątek Okresu Zwykłego",
    "Poniedziałek XXVII tygodnia zwykłego" to "27 Poniedziałek Okresu Zwykłego",
    "Sobota XXVII tygodnia zwykłego" to "27 Sobota Okresu Zwykłego",
    "Wtorek XXVII tygodnia zwykłego" to "27 Wtorek Okresu Zwykłego",
    "Środa XXVII tygodnia zwykłego" to "27 Środa Okresu Zwykłego",
    "Czwartek XXVIII tygodnia zwykłego" to "28 Czwartek Okresu Zwykłego",
    "XXVIII Niedziela Zwykła" to "28 Niedziela Okresu Zwykłego",
    "Piątek XXVIII tygodnia zwykłego" to "28 Piątek Okresu Zwykłego",
    "Poniedziałek XXVIII tygodnia zwykłego" to "28 Poniedziałek Okresu Zwykłego",
    "Sobota XXVIII tygodnia zwykłego" to "28 Sobota Okresu Zwykłego",
    "Wtorek XXVIII tygodnia zwykłego" to "28 Wtorek Okresu Zwykłego",
    "Środa XXVIII tygodnia zwykłego" to "28 Środa Okresu Zwykłego",
    "Czwartek XXIX tygodnia zwykłego" to "29 Czwartek Okresu Zwykłego",
    "XXIX Niedziela Zwykła" to "29 Niedziela Okresu Zwykłego",
    "Piątek XXIX tygodnia zwykłego" to "29 Piątek Okresu Zwykłego",
    "Poniedziałek XXIX tygodnia zwykłego" to "29 Poniedziałek Okresu Zwykłego",
    "Sobota XXIX tygodnia zwykłego" to "29 Sobota Okresu Zwykłego",
    "Wtorek XXIX tygodnia zwykłego" to "29 Wtorek Okresu Zwykłego",
    "Środa XXIX tygodnia zwykłego" to "29 Środa Okresu Zwykłego",
    "Czwartek III tygodnia zwykłego" to "3 Czwartek Okresu Zwykłego",
    "III Niedziela Zwykła" to "3 Niedziela Okresu Zwykłego",
    "Piątek III tygodnia zwykłego" to "3 Piątek Okresu Zwykłego",
    "Poniedziałek III tygodnia zwykłego" to "3 Poniedziałek Okresu Zwykłego",
    "Sobota III tygodnia zwykłego" to "3 Sobota Okresu Zwykłego",
    "Wtorek III tygodnia zwykłego" to "3 Wtorek Okresu Zwykłego",
    "Środa III tygodnia zwykłego" to "3 Środa Okresu Zwykłego",
    "Czwartek XXX tygodnia zwykłego" to "30 Czwartek Okresu Zwykłego",
    "XXX Niedziela Zwykła" to "30 Niedziela Okresu Zwykłego",
    "Piątek XXX tygodnia zwykłego" to "30 Piątek Okresu Zwykłego",
    "Poniedziałek XXX tygodnia zwykłego" to "30 Poniedziałek Okresu Zwykłego",
    "Sobota XXX tygodnia zwykłego" to "30 Sobota Okresu Zwykłego",
    "Wtorek XXX tygodnia zwykłego" to "30 Wtorek Okresu Zwykłego",
    "Środa XXX tygodnia zwykłego" to "30 Środa Okresu Zwykłego",
    "Czwartek XXXI tygodnia zwykłego" to "31 Czwartek Okresu Zwykłego",
    "XXXI Niedziela Zwykła" to "31 Niedziela Okresu Zwykłego",
    "Piątek XXXI tygodnia zwykłego" to "31 Piątek Okresu Zwykłego",
    "Poniedziałek XXXI tygodnia zwykłego" to "31 Poniedziałek Okresu Zwykłego",
    "Sobota XXXI tygodnia zwykłego" to "31 Sobota Okresu Zwykłego",
    "Wtorek XXXI tygodnia zwykłego" to "31 Wtorek Okresu Zwykłego",
    "Środa XXXI tygodnia zwykłego" to "31 Środa Okresu Zwykłego",
    "Czwartek XXXII tygodnia zwykłego" to "32 Czwartek Okresu Zwykłego",
    "XXXII Niedziela Zwykła" to "32 Niedziela Okresu Zwykłego",
    "Piątek XXXII tygodnia zwykłego" to "32 Piątek Okresu Zwykłego",
    "Poniedziałek XXXII tygodnia zwykłego" to "32 Poniedziałek Okresu Zwykłego",
    "Sobota XXXII tygodnia zwykłego" to "32 Sobota Okresu Zwykłego",
    "Wtorek XXXII tygodnia zwykłego" to "32 Wtorek Okresu Zwykłego",
    "Środa XXXII tygodnia zwykłego" to "32 Środa Okresu Zwykłego",
    "Czwartek XXXIII tygodnia zwykłego" to "33 Czwartek Okresu Zwykłego",
    "XXXIII Niedziela Zwykła" to "33 Niedziela Okresu Zwykłego",
    "Piątek XXXIII tygodnia zwykłego" to "33 Piątek Okresu Zwykłego",
    "Poniedziałek XXXIII tygodnia zwykłego" to "33 Poniedziałek Okresu Zwykłego",
    "Sobota XXXIII tygodnia zwykłego" to "33 Sobota Okresu Zwykłego",
    "Wtorek XXXIII tygodnia zwykłego" to "33 Wtorek Okresu Zwykłego",
    "Środa XXXIII tygodnia zwykłego" to "33 Środa Okresu Zwykłego",
    "Czwartek XXXIV tygodnia zwykłego" to "34 Czwartek Okresu Zwykłego",
    "Piątek XXXIV tygodnia zwykłego" to "34 Piątek Okresu Zwykłego",
    "Poniedziałek XXXIV tygodnia zwykłego" to "34 Poniedziałek Okresu Zwykłego",
    "Sobota XXXIV tygodnia zwykłego" to "34 Sobota Okresu Zwykłego",
    "Wtorek XXXIV tygodnia zwykłego" to "34 Wtorek Okresu Zwykłego",
    "Środa XXXIV tygodnia zwykłego" to "34 Środa Okresu Zwykłego",
    "Jezusa Chrystusa, Króla Wszechświata" to "Uroczystość Jezusa Chrystusa, Króla Wszechświata",
    "Czwartek IV tygodnia zwykłego" to "4 Czwartek Okresu Zwykłego",
    "IV Niedziela Zwykła" to "4 Niedziela Okresu Zwykłego",
    "Piątek IV tygodnia zwykłego" to "4 Piątek Okresu Zwykłego",
    "Poniedziałek IV tygodnia zwykłego" to "4 Poniedziałek Okresu Zwykłego",
    "Sobota IV tygodnia zwykłego" to "4 Sobota Okresu Zwykłego",
    "Wtorek IV tygodnia zwykłego" to "4 Wtorek Okresu Zwykłego",
    "Środa IV tygodnia zwykłego" to "4 Środa Okresu Zwykłego",
    "Czwartek V tygodnia zwykłego" to "5 Czwartek Okresu Zwykłego",
    "V Niedziela Zwykła" to "5 Niedziela Okresu Zwykłego",
    "Piątek V tygodnia zwykłego" to "5 Piątek Okresu Zwykłego",
    "Poniedziałek V tygodnia zwykłego" to "5 Poniedziałek Okresu Zwykłego",
    "Sobota V tygodnia zwykłego" to "5 Sobota Okresu Zwykłego",
    "Wtorek V tygodnia zwykłego" to "5 Wtorek Okresu Zwykłego",
    "Środa V tygodnia zwykłego" to "5 Środa Okresu Zwykłego",
    "Czwartek VI tygodnia zwykłego" to "6 Czwartek Okresu Zwykłego",
    "VI Niedziela Zwykła" to "6 Niedziela Okresu Zwykłego",
    "Piątek VI tygodnia zwykłego" to "6 Piątek Okresu Zwykłego",
    "Poniedziałek VI tygodnia zwykłego" to "6 Poniedziałek Okresu Zwykłego",
    "Sobota VI tygodnia zwykłego" to "6 Sobota Okresu Zwykłego",
    "Wtorek VI tygodnia zwykłego" to "6 Wtorek Okresu Zwykłego",
    "Środa VI tygodnia zwykłego" to "6 Środa Okresu Zwykłego",
    "Czwartek VII tygodnia zwykłego" to "7 Czwartek Okresu Zwykłego",
    "VII Niedziela Zwykła" to "7 Niedziela Okresu Zwykłego",
    "Piątek VII tygodnia zwykłego" to "7 Piątek Okresu Zwykłego",
    "Poniedziałek VII tygodnia zwykłego" to "7 Poniedziałek Okresu Zwykłego",
    "Sobota VII tygodnia zwykłego" to "7 Sobota Okresu Zwykłego",
    "Wtorek VII tygodnia zwykłego" to "7 Wtorek Okresu Zwykłego",
    "Środa VII tygodnia zwykłego" to "7 Środa Okresu Zwykłego",
    "Czwartek VIII tygodnia zwykłego" to "8 Czwartek Okresu Zwykłego",
    "VIII Niedziela Zwykła" to "8 Niedziela Okresu Zwykłego",
    "Piątek VIII tygodnia zwykłego" to "8 Piątek Okresu Zwykłego",
    "Poniedziałek VIII tygodnia zwykłego" to "8 Poniedziałek Okresu Zwykłego",
    "Sobota VIII tygodnia zwykłego" to "8 Sobota Okresu Zwykłego",
    "Wtorek VIII tygodnia zwykłego" to "8 Wtorek Okresu Zwykłego",
    "Środa VIII tygodnia zwykłego" to "8 Środa Okresu Zwykłego",
    "Czwartek IX tygodnia zwykłego" to "9 Czwartek Okresu Zwykłego",
    "IX Niedziela Zwykła" to "9 Niedziela Okresu Zwykłego",
    "Piątek IX tygodnia zwykłego" to "9 Piątek Okresu Zwykłego",
    "Poniedziałek IX tygodnia zwykłego" to "9 Poniedziałek Okresu Zwykłego",
    "Sobota IX tygodnia zwykłego" to "9 Sobota Okresu Zwykłego",
    "Wtorek IX tygodnia zwykłego" to "9 Wtorek Okresu Zwykłego",
    "Środa IX tygodnia zwykłego" to "9 Środa Okresu Zwykłego",
    "Wielki Czwartek: Wieczerzy Pańskiej" to "Wielki Czwartek",
    "Wielki Piątek: Męki Pańskiej" to "Wielki Piątek Męki Pańskiej",
    "Wielka Sobota" to "Wigilia Paschalna",
    "Czwartek I tygodnia Wielkiego Postu" to "1 Czwartek Wielkiego Postu",
    "Piątek I tygodnia Wielkiego Postu" to "1 Piątek Wielkiego Postu",
    "Poniedziałek I tygodnia Wielkiego Postu" to "1 Poniedziałek Wielkiego Postu",
    "Sobota I tygodnia Wielkiego Postu" to "1 Sobota Wielkiego Postu",
    "Wtorek I tygodnia Wielkiego Postu" to "1 Wtorek Wielkiego Postu",
    "Środa I tygodnia Wielkiego Postu" to "1 Środa Wielkiego Postu",
    "I Niedziela Wielkiego Postu" to "1 Niedziela Wielkiego Postu",
    "Czwartek II tygodnia Wielkiego Postu" to "2 Czwartek Wielkiego Postu",
    "Piątek II tygodnia Wielkiego Postu" to "2 Piątek Wielkiego Postu",
    "Poniedziałek II tygodnia Wielkiego Postu" to "2 Poniedziałek Okresu Zwykłego",
    "Sobota II tygodnia Wielkiego Postu" to "2 Sobota Wielkiego Postu",
    "Wtorek II tygodnia Wielkiego Postu" to "2 Wtorek Wielkiego Postu",
    "Środa II tygodnia Wielkiego Postu" to "2 Środa Wielkiego Postu",
    "II Niedziela Wielkiego Postu" to "2 Niedziela Wielkiego Postu",
    "Czwartek III tygodnia Wielkiego Postu" to "3 Czwartek Wielkiego Postu",
    "Piątek III tygodnia Wielkiego Postu" to "3 Piątek Wielkiego Postu",
    "Poniedziałek III tygodnia Wielkiego Postu" to "3 Poniedziałek Wielkiego Postu",
    "Sobota III tygodnia Wielkiego Postu" to "3 Sobota Wielkiego Postu",
    "Wtorek III tygodnia Wielkiego Postu" to "3 Wtorek Wielkiego Postu",
    "Środa III tygodnia Wielkiego Postu" to "3 Środa Wielkiego Postu",
    "III Niedziela Wielkiego Postu" to "3 Niedziela Wielkiego Postu",
    "Środa IV tygodnia Wielkiego Postu" to "4 Środa Wielkiego Postu",
    "Piątek IV tygodnia Wielkiego Postu" to "4 Piątek Wielkiego Postu",
    "Poniedziałek IV tygodnia Wielkiego Postu" to "4 Poniedziałek Okresu Zwykłego",
    "Sobota IV tygodnia Wielkiego Postu" to "4 Sobota Wielkiego Postu",
    "Wtorek IV tygodnia Wielkiego Postu" to "4 Wtorek Wielkiego Postu",
    "IV Niedziela Wielkiego Postu „Laetare”" to "4 Niedziela Wielkiego Postu",
    "Czwartek V tygodnia Wielkiego Postu" to "5 Czwartek Wielkiego Postu",
    "Piątek V tygodnia Wielkiego Postu" to "5 Piątek Wielkiego Postu",
    "Poniedziałek V tygodnia Wielkiego Postu" to "5 Poniedziałek Okresu Zwykłego",
    "Sobota V tygodnia Wielkiego Postu" to "5 Sobota Wielkiego Postu",
    "Wtorek V tygodnia Wielkiego Postu" to "5 Wtorek Wielkiego Postu",
    "Środa V tygodnia Wielkiego Postu" to "5 Środa Wielkiego Postu",
    "V Niedziela Wielkiego Postu" to "5 Niedziela Wielkiego Postu",
    "Wielka Środa" to "Wielka Środa",
    "Wielki Poniedziałek" to "Wielki Poniedziałek",
    "Wielki Wtorek" to "Wielki Wtorek",
    "Niedziela Palmowa Męki Pańskiej" to "Niedziela Palmowa Męki Pańskiej",
    "Czwartek po Popielcu" to "Czwartek po Popielcu",
    "Piątek po Popielcu" to "Piątek po Popielcu",
    "Sobota po Popielcu" to "Sobota po Popielcu",
    "Środa Popielcowa" to "Środa Popielcowa",
    "Niepokalanego Serca Najświętszej Maryi Panny" to "Wspomnienie Niepokalanego Serca NMP",
    "Najświętszej Maryi Panny, Matki Kościoła" to "Wspomnienie NMP Matki Kościoła",
    "Najświętszego Ciała i Krwi Chrystusa" to "Uroczystość Najświętszego Ciała i Krwi Chrystusa",
    "Najświętszego Serca Pana Jezusa" to "Uroczystość Najświętszego Serca Pana Jezusa",
    "Najświętszej Trójcy" to "Uroczystość Najświętszej Trójcy",
    "Niedziela Zesłania Ducha Świętego" to "Uroczystość Zesłania Ducha Świętego",
    "Jezusa Chrystusa, Najwyższego i Wiecznego Kapłana" to "Święto Jezusa Chrystusa, Najwyższego i Wiecznego Kapłana"
)

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\category\CategoryManagementScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.category

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.qjproject.liturgicalcalendar.data.Category
import com.qjproject.liturgicalcalendar.ui.components.AutoResizingText
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy
import com.qjproject.liturgicalcalendar.ui.theme.VividRed

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CategoryManagementScreen(
    viewModel: CategoryManagementViewModel,
    onNavigateBack: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()

    when (val dialogState = uiState.dialogState) {
        is DialogState.AddEdit -> {
            AddEditCategoryDialog(
                category = dialogState.category,
                error = uiState.error,
                onDismiss = { viewModel.dismissDialog() },
                onConfirm = { name, skrot ->
                    if (dialogState.category == null) {
                        viewModel.addCategory(name, skrot)
                    } else {
                        viewModel.updateCategory(dialogState.category, name, skrot)
                    }
                },
                onValidate = { name, skrot ->
                    viewModel.validateCategory(name, skrot, dialogState.category)
                }
            )
        }
        is DialogState.Delete -> {
            DeleteCategoryDialog(
                category = dialogState.category,
                onDismiss = { viewModel.dismissDialog() },
                onConfirm = { removeFromSongs ->
                    viewModel.deleteCategory(dialogState.category, removeFromSongs)
                }
            )
        }
        DialogState.None -> {}
    }

    Scaffold(
        topBar = {
            Column {
                CenterAlignedTopAppBar(
                    title = {
                        AutoResizingText(
                            text = "Zarządzaj kategoriami",
                            style = MaterialTheme.typography.titleLarge,
                            textAlign = TextAlign.Center
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć")
                        }
                    },
                    colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background,
                        titleContentColor = MaterialTheme.colorScheme.primary,
                        navigationIconContentColor = MaterialTheme.colorScheme.primary
                    ),
                    windowInsets = TopAppBarDefaults.windowInsets
                )
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { viewModel.showAddDialog() }) {
                Icon(Icons.Default.Add, contentDescription = "Dodaj kategorię")
            }
        }
    ) { innerPadding ->
        if (uiState.isLoading) {
            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding)
                    .padding(horizontal = 8.dp),
                contentPadding = PaddingValues(vertical = 8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(uiState.categories, key = { it.nazwa }) { category ->
                    CategoryItem(
                        category = category,
                        onEditClick = { viewModel.showEditDialog(category) },
                        onDeleteClick = { viewModel.showDeleteDialog(category) }
                    )
                }
            }
        }
    }
}

@Composable
fun CategoryItem(
    category: Category,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    Card(
        // --- POCZĄTEK ZMIANY ---
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onEditClick),
        // --- KONIEC ZMIANY ---
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = category.nazwa,
                    style = MaterialTheme.typography.titleMedium,
                    color = SaturatedNavy
                )
                Text(
                    text = category.skrot,
                    style = MaterialTheme.typography.bodyMedium,
                    color = SaturatedNavy.copy(alpha = 0.8f)
                )
            }
            // --- POCZĄTEK ZMIANY ---
            // Usunięto ikonę edycji
            IconButton(onClick = onDeleteClick) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "Usuń",
                    tint = VividRed
                )
            }
            // --- KONIEC ZMIANY ---
        }
    }
}

@Composable
fun AddEditCategoryDialog(
    category: Category?,
    error: String?,
    onDismiss: () -> Unit,
    onConfirm: (String, String) -> Unit,
    onValidate: (String, String) -> Unit
) {
    var name by remember { mutableStateOf(category?.nazwa ?: "") }
    var abbreviation by remember { mutableStateOf(category?.skrot ?: "") }

    LaunchedEffect(name, abbreviation) {
        onValidate(name, abbreviation)
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    text = if (category == null) "Dodaj kategorię" else "Edytuj kategorię",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))

                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Nazwa kategorii") },
                    isError = error != null && error.contains("nazwa", ignoreCase = true),
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(Modifier.height(8.dp))
                OutlinedTextField(
                    value = abbreviation,
                    onValueChange = { abbreviation = it },
                    label = { Text("Skrót") },
                    isError = error != null && error.contains("skrót", ignoreCase = true),
                    modifier = Modifier.fillMaxWidth()
                )

                if (error != null) {
                    Text(
                        text = error,
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodySmall,
                        modifier = Modifier.padding(top = 8.dp)
                    )
                }

                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = { onConfirm(name, abbreviation) },
                        enabled = name.isNotBlank() && abbreviation.isNotBlank() && error == null
                    ) { Text("Zapisz") }
                }
            }
        }
    }
}

@Composable
fun DeleteCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: (Boolean) -> Unit
) {
    var removeFromSongs by remember { mutableStateOf(true) }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    text = "Potwierdź usunięcie",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text(
                    // --- POCZĄTEK ZMIANY ---
                    buildAnnotatedString {
                        append("Czy na pewno chcesz usunąć kategorię ")
                        withStyle(style = SpanStyle(color = SaturatedNavy, fontWeight = FontWeight.Bold)) {
                            append(category.nazwa)
                        }
                        append("?")
                    },
                    color = MaterialTheme.colorScheme.onSurface
                    // --- KONIEC ZMIANY ---
                )
                Spacer(Modifier.height(16.dp))
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier.clickable { removeFromSongs = !removeFromSongs }
                ) {
                    Checkbox(checked = removeFromSongs, onCheckedChange = { removeFromSongs = it })
                    Spacer(Modifier.width(8.dp))
                    // --- POCZĄTEK ZMIANY ---
                    Text(
                        "Usuń wystąpienia tej kategorii z pieśni",
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    // --- KONIEC ZMIANY ---
                }
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = { onConfirm(removeFromSongs) },
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                    ) { Text("Usuń") }
                }
            }
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\category\CategoryManagementViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.category

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.Category
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

sealed class DialogState {
    object None : DialogState()
    data class AddEdit(val category: Category? = null) : DialogState()
    data class Delete(val category: Category) : DialogState()
}

data class CategoryManagementUiState(
    val categories: List<Category> = emptyList(),
    val isLoading: Boolean = true,
    val dialogState: DialogState = DialogState.None,
    val error: String? = null
)

class CategoryManagementViewModel(private val repository: FileSystemRepository) : ViewModel() {

    private val _uiState = MutableStateFlow(CategoryManagementUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadCategories()
    }

    private fun loadCategories() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            repository.invalidateCategoryCache() // Zawsze pobieraj świeżą listę
            val categories = repository.getCategoryList().sortedBy { it.nazwa }
            _uiState.update { it.copy(isLoading = false, categories = categories) }
        }
    }

    fun showAddDialog() = _uiState.update { it.copy(dialogState = DialogState.AddEdit(null), error = null) }
    fun showEditDialog(category: Category) = _uiState.update { it.copy(dialogState = DialogState.AddEdit(category), error = null) }
    fun showDeleteDialog(category: Category) = _uiState.update { it.copy(dialogState = DialogState.Delete(category)) }
    fun dismissDialog() = _uiState.update { it.copy(dialogState = DialogState.None, error = null) }

    fun validateCategory(name: String, abbreviation: String, originalCategory: Category?) {
        val trimmedName = name.trim()
        val trimmedAbbreviation = abbreviation.trim()
        val categories = _uiState.value.categories

        if (trimmedName.isNotBlank() && categories.any { it.nazwa.equals(trimmedName, ignoreCase = true) && it.nazwa != originalCategory?.nazwa }) {
            _uiState.update { it.copy(error = "Kategoria o tej nazwie już istnieje.") }
            return
        }
        if (trimmedAbbreviation.isNotBlank() && categories.any { it.skrot.equals(trimmedAbbreviation, ignoreCase = true) && it.skrot != originalCategory?.skrot }) {
            _uiState.update { it.copy(error = "Kategoria o tym skrócie już istnieje.") }
            return
        }
        _uiState.update { it.copy(error = null) }
    }

    fun addCategory(name: String, abbreviation: String) {
        viewModelScope.launch {
            val newCategory = Category(nazwa = name.trim(), skrot = abbreviation.trim())
            val updatedList = (_uiState.value.categories + newCategory).sortedBy { it.nazwa }
            repository.saveCategoryList(updatedList).onSuccess {
                _uiState.update { it.copy(categories = updatedList) }
                dismissDialog()
            }
        }
    }

    fun updateCategory(originalCategory: Category, newName: String, newAbbreviation: String) {
        viewModelScope.launch {
            val trimmedName = newName.trim()
            val trimmedAbbreviation = newAbbreviation.trim()
            val updatedCategory = Category(nazwa = trimmedName, skrot = trimmedAbbreviation)

            // Krok 1: Zaktualizuj wszystkie pieśni używające starej kategorii
            repository.updateCategoryInSongs(originalCategory, updatedCategory).onSuccess {
                // Krok 2: Zaktualizuj listę kategorii
                val updatedList = _uiState.value.categories.map {
                    if (it == originalCategory) updatedCategory else it
                }.sortedBy { it.nazwa }
                repository.saveCategoryList(updatedList).onSuccess {
                    _uiState.update { it.copy(categories = updatedList) }
                    dismissDialog()
                }
            }
        }
    }

    fun deleteCategory(category: Category, removeFromSongs: Boolean) {
        viewModelScope.launch {
            if (removeFromSongs) {
                repository.removeCategoryFromSongs(category).onSuccess {
                    deleteCategoryFromList(category)
                }
            } else {
                deleteCategoryFromList(category)
            }
        }
    }

    private fun deleteCategoryFromList(category: Category) {
        val updatedList = _uiState.value.categories.filter { it != category }.sortedBy { it.nazwa }
        repository.saveCategoryList(updatedList).onSuccess {
            _uiState.update { it.copy(categories = updatedList) }
            dismissDialog()
        }
    }
}

class CategoryManagementViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(CategoryManagementViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return CategoryManagementViewModel(FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\dateevents\DateEventsScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.dateevents

import androidx.activity.compose.BackHandler
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Article
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.qjproject.liturgicalcalendar.ui.components.AutoResizingText
import java.io.File

data class EventItem(
    val fullPath: String,
    val displayName: String
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DateEventsScreen(
    dateTitle: String,
    filePaths: List<String>,
    onNavigateToDay: (String) -> Unit,
    onNavigateBack: () -> Unit
) {
    val eventItems = filePaths.map { path ->
        val displayName = File(path).nameWithoutExtension
        EventItem(fullPath = path, displayName = displayName)
    }

    BackHandler(onBack = onNavigateBack)

    Scaffold(
        topBar = {
            Column {
                CenterAlignedTopAppBar(
                    title = {
                        AutoResizingText(
                            text = dateTitle,
                            style = MaterialTheme.typography.titleLarge,
                            textAlign = TextAlign.Center
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć")
                        }
                    },
                    actions = {
                        Spacer(Modifier.width(68.dp))
                    },
                    colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background,
                        titleContentColor = MaterialTheme.colorScheme.primary,
                        navigationIconContentColor = MaterialTheme.colorScheme.primary
                    )
                )
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
            }
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(horizontal = 8.dp),
            contentPadding = PaddingValues(vertical = 8.dp)
        ) {
            items(eventItems, key = { it.fullPath }) { item ->
                EventListItem(
                    item = item,
                    onClick = { onNavigateToDay(item.fullPath) }
                )
            }
        }
    }
}

@Composable
private fun EventListItem(
    item: EventItem,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Outlined.Article,
                contentDescription = "Wydarzenie",
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.width(16.dp))
            Text(
                text = item.displayName.replace("_", " "),
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\daydetails\DayDetailsScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.daydetails

import androidx.activity.compose.BackHandler
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.*
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.PressInteraction
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material.ripple.rememberRipple
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.LayoutCoordinates
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.layout.positionInRoot
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import androidx.lifecycle.viewmodel.compose.viewModel
import com.qjproject.liturgicalcalendar.data.Reading
import com.qjproject.liturgicalcalendar.data.Song
import com.qjproject.liturgicalcalendar.data.SuggestedSong
import com.qjproject.liturgicalcalendar.ui.components.AutoResizingText
import com.qjproject.liturgicalcalendar.ui.theme.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.burnoutcrew.reorderable.*

@Composable
fun DayDetailsScreen(
    dayId: String?,
    onNavigateBack: () -> Unit,
    onNavigateToSongContent: (song: Song, startInEdit: Boolean) -> Unit
) {
    if (dayId.isNullOrBlank()) {
        Scaffold { padding -> Box(Modifier.fillMaxSize().padding(padding), contentAlignment = Alignment.Center) { Text("Błąd krytyczny: Brak identyfikatora dnia.") } }
        return
    }

    val context = LocalContext.current
    val viewModel: DayDetailsViewModel = viewModel(factory = DayDetailsViewModelFactory(context, dayId))
    val uiState by viewModel.uiState.collectAsState()

    BackHandler(enabled = uiState.isEditMode) { viewModel.onTryExitEditMode() }
    BackHandler(enabled = !uiState.isEditMode, onBack = onNavigateBack)

    if (uiState.showConfirmExitDialog) {
        ConfirmExitDialog(
            onDismiss = { viewModel.dismissConfirmExitDialog() },
            onDiscard = { viewModel.onExitEditMode(save = false) }
        )
    }

    when (val dialog = uiState.activeDialog) {
        is DialogState.ConfirmDelete -> ConfirmDeleteDialog(
            description = dialog.description,
            onDismiss = { viewModel.dismissDialog() },
            onConfirm = { viewModel.deleteItem(dialog.item) }
        )
        is DialogState.AddEditSong -> AddEditSongDialog(
            moment = dialog.moment,
            existingSong = dialog.existingSong,
            viewModel = viewModel,
            onDismiss = { viewModel.dismissDialog() },
            onConfirm = { song, moment, originalSong -> viewModel.addOrUpdateSong(song, moment, originalSong) }
        )
        else -> {}
    }

    Scaffold(
        topBar = {
            if (uiState.isEditMode) {
                EditModeTopAppBar(
                    title = uiState.dayData?.tytulDnia ?: "Edycja",
                    onCancelClick = { viewModel.onTryExitEditMode() },
                    onSaveClick = { viewModel.onExitEditMode(save = true) },
                    isSaveEnabled = uiState.hasChanges
                )
            } else {
                ViewModeTopAppBar(
                    title = uiState.dayData?.tytulDnia ?: "Ładowanie...",
                    onNavigateBack = onNavigateBack,
                    onEditClick = { viewModel.onEnterEditMode() }
                )
            }
        }
    ) { innerPadding ->
        when {
            uiState.isLoading -> Box(Modifier.fillMaxSize().padding(innerPadding), contentAlignment = Alignment.Center) { CircularProgressIndicator() }
            uiState.error != null -> Box(Modifier.fillMaxSize().padding(innerPadding), contentAlignment = Alignment.Center) { Text("Błąd: ${uiState.error}") }
            uiState.isEditMode -> DayDetailsEditModeContent(modifier = Modifier.padding(innerPadding), viewModel = viewModel)
            else -> DayDetailsViewModeContent(
                modifier = Modifier.padding(innerPadding),
                viewModel = viewModel,
                onNavigateToSongContent = onNavigateToSongContent
            )
        }
    }
}

// =================================================================================
// WIDOK STANDARDOWY (VIEW MODE)
// =================================================================================
@Composable
private fun DayDetailsViewModeContent(
    modifier: Modifier = Modifier,
    viewModel: DayDetailsViewModel,
    onNavigateToSongContent: (song: Song, startInEdit: Boolean) -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    var showSongModal by remember { mutableStateOf(false) }
    var selectedSong by remember { mutableStateOf<SuggestedSong?>(null) }
    var fullSelectedSong by remember { mutableStateOf<Song?>(null) }

    val scrollState = rememberScrollState()
    val coroutineScope = rememberCoroutineScope()
    val readingOffsetsY = remember { mutableStateMapOf<Int, Int>() }
    val interactionSources = remember { mutableStateMapOf<Int, MutableInteractionSource>() }
    var contentStartY by remember { mutableStateOf(0f) }
    var scrollAnchorCoordinates by remember { mutableStateOf<LayoutCoordinates?>(null) }

    if (showSongModal && selectedSong != null && fullSelectedSong != null) {
        SongDetailsModal(
            suggestedSong = selectedSong!!,
            fullSong = fullSelectedSong!!,
            onDismiss = { showSongModal = false },
            onShowContent = onNavigateToSongContent
        )
    }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 16.dp)
            .verticalScroll(scrollState)
            .onGloballyPositioned { contentStartY = it.positionInRoot().y }
    ) {
        Spacer(
            modifier = Modifier
                .height(0.dp)
                .onGloballyPositioned { scrollAnchorCoordinates = it }
        )

        Spacer(modifier = Modifier.height(16.dp))
        HierarchicalCollapsibleSection(
            title = "Czytania",
            isExpanded = uiState.isReadingsSectionExpanded,
            onToggle = { viewModel.toggleReadingsSection() }
        ) {
            uiState.dayData?.czytania?.forEachIndexed { index, reading ->
                ReadingItemView(
                    reading = reading,
                    isExpanded = uiState.expandedReadings.contains(index),
                    onToggle = { viewModel.toggleReading(index) },
                    onContentDoubleTap = {
                        handleReadingCollapse(index, readingOffsetsY, viewModel, coroutineScope, scrollState, interactionSources)
                    },
                    onGloballyPositioned = { itemCoordinates ->
                        scrollAnchorCoordinates?.let { anchor ->
                            val offsetY = (itemCoordinates.positionInRoot().y - anchor.positionInRoot().y).toInt()
                            readingOffsetsY[index] = offsetY
                        }
                    },
                    interactionSource = interactionSources.getOrPut(index) { MutableInteractionSource() }
                )
            }
        }
        Spacer(modifier = Modifier.height(24.dp))
        HierarchicalCollapsibleSection(
            title = "Sugerowane pieśni",
            isExpanded = uiState.isSongsSectionExpanded,
            onToggle = { viewModel.toggleSongsSection() }
        ) {
            val groupedSongs by viewModel.groupedSongs.collectAsState()
            songMomentOrderMap.forEach { (momentKey, momentName) ->
                SongGroupView(
                    momentName = momentName,
                    songs = groupedSongs[momentKey].orEmpty(),
                    isExpanded = uiState.expandedSongMoments.contains(momentKey),
                    onToggle = { viewModel.toggleSongMoment(momentKey) },
                    onSongClick = { suggested ->
                        viewModel.getFullSong(suggested) { fullSong ->
                            if (fullSong != null) {
                                selectedSong = suggested
                                fullSelectedSong = fullSong
                                showSongModal = true
                            }
                        }
                    }
                )
            }
        }
        Spacer(modifier = Modifier.height(16.dp))
    }
}

private fun handleReadingCollapse(
    index: Int,
    readingOffsets: Map<Int, Int>,
    viewModel: DayDetailsViewModel,
    coroutineScope: CoroutineScope,
    scrollState: ScrollState,
    interactionSources: Map<Int, MutableInteractionSource>
) {
    val targetScrollPosition = readingOffsets[index] ?: return

    viewModel.collapseReading(index)

    coroutineScope.launch {
        scrollState.animateScrollTo(targetScrollPosition)

        delay(50)
        interactionSources[index]?.let { source ->
            val press = PressInteraction.Press(Offset.Zero)
            source.emit(press)
            delay(150)
            source.emit(PressInteraction.Release(press))
        }
    }
}

// =================================================================================
// WIDOK EDYCJI (EDIT MODE)
// =================================================================================
@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun DayDetailsEditModeContent(modifier: Modifier = Modifier, viewModel: DayDetailsViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    val editableData by viewModel.editableDayData
    var readingToEdit by remember { mutableStateOf<Pair<Reading, Int>?>(null) }
    var showAddReadingDialog by remember { mutableStateOf(false) }

    if (showAddReadingDialog) {
        AddEditReadingDialog(
            onDismiss = { showAddReadingDialog = false },
            onConfirm = { reading -> viewModel.addOrUpdateReading(reading, null) }
        )
    }
    readingToEdit?.let { (reading, index) ->
        AddEditReadingDialog(
            existingReading = reading,
            onDismiss = { readingToEdit = null },
            onConfirm = { updatedReading -> viewModel.addOrUpdateReading(updatedReading, index) }
        )
    }

    LazyColumn(
        modifier = modifier
            .fillMaxSize()
            .padding(horizontal = 16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
        contentPadding = PaddingValues(vertical = 16.dp)
    ) {
        item {
            HierarchicalCollapsibleSection(
                title = "Czytania",
                isExpanded = uiState.isReadingsSectionExpanded,
                onToggle = { viewModel.toggleReadingsSection() }
            ) {
                val reorderState = rememberReorderableLazyListState(
                    onMove = { from, to -> viewModel.reorderReadings(from.index, to.index) }
                )
                LazyColumn(
                    state = reorderState.listState,
                    modifier = Modifier
                        .reorderable(reorderState)
                        .heightIn(max = 500.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    itemsIndexed(
                        items = editableData?.czytania ?: emptyList(),
                        key = { index, item -> "${item.hashCode()}-$index" }
                    ) { index, reading ->
                        ReorderableItem(reorderState, key = "${reading.hashCode()}-$index") { isDragging ->
                            EditableReadingItem(
                                reading = reading,
                                isDragging = isDragging,
                                onEditClick = { readingToEdit = reading to index },
                                onDeleteClick = { viewModel.showDialog(DialogState.ConfirmDelete(reading, "czytanie: ${reading.typ}")) },
                                reorderModifier = Modifier.detectReorder(reorderState)
                            )
                        }
                    }
                }
                AddItemButton(text = "Dodaj czytanie", onClick = { showAddReadingDialog = true })
            }
        }

        item {
            HierarchicalCollapsibleSection(
                title = "Sugerowane pieśni",
                isExpanded = uiState.isSongsSectionExpanded,
                onToggle = { viewModel.toggleSongsSection() }
            ) {
                val songsByMoment = editableData?.piesniSugerowane.orEmpty().filterNotNull().groupBy { it.moment }
                songMomentOrderMap.forEach { (momentKey, momentName) ->
                    EditableSongCategoryHeader(categoryName = momentName)
                    val songsInMoment = songsByMoment[momentKey].orEmpty()
                    val isReorderEnabled = songsInMoment.size > 1

                    val songReorderState = rememberReorderableLazyListState(
                        onMove = { from, to -> viewModel.reorderSongs(momentKey, from.index, to.index) }
                    )
                    LazyColumn(
                        state = songReorderState.listState,
                        modifier = Modifier
                            .then(if (isReorderEnabled) Modifier.reorderable(songReorderState) else Modifier)
                            .heightIn(max = 500.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        itemsIndexed(
                            items = songsInMoment,
                            key = { index, song -> "${song.hashCode()}-$index" }
                        ) { index, song ->
                            ReorderableItem(songReorderState, key = "${song.hashCode()}-$index") { isDragging ->
                                EditableSongItem(
                                    song = song,
                                    isDragging = isDragging,
                                    onEditClick = { viewModel.showDialog(DialogState.AddEditSong(momentKey, song)) },
                                    onDeleteClick = { viewModel.showDialog(DialogState.ConfirmDelete(song, "pieśń: ${song.piesn}")) },
                                    reorderModifier = if (isReorderEnabled) Modifier.detectReorder(songReorderState) else Modifier,
                                    isReorderEnabled = isReorderEnabled
                                )
                            }
                        }
                    }
                    AddItemButton(text = "Dodaj pieśń do '$momentName'", onClick = { viewModel.showDialog(DialogState.AddEditSong(momentKey)) })
                    if (momentKey != songMomentOrderMap.keys.last()) {
                        Divider(Modifier.padding(vertical = 8.dp))
                    }
                }
            }
        }
    }
}


// =================================================================================
// Komponenty reużywalne i pomocnicze
// =================================================================================
@Composable
private fun HierarchicalCollapsibleSection(
    title: String, isExpanded: Boolean, onToggle: () -> Unit, level: Int = 0,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    modifier: Modifier = Modifier, content: @Composable ColumnScope.() -> Unit
) {
    Column(
        modifier = modifier.then(
            if (level > 0) Modifier
                .clip(MaterialTheme.shapes.medium)
                .background(SubtleGrayBackground) else Modifier
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(interactionSource = interactionSource, indication = rememberRipple(), onClick = onToggle)
                .padding(horizontal = if (level > 0) 12.dp else 0.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = title,
                style = if (level == 0) MaterialTheme.typography.titleLarge else MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.weight(1f)
            )
            Icon(
                imageVector = if (isExpanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                contentDescription = if (isExpanded) "Zwiń" else "Rozwiń"
            )
        }
        if (level == 0 && isExpanded) Divider(color = DividerColor)
        AnimatedVisibility(visible = isExpanded, enter = expandVertically(tween(300)), exit = shrinkVertically(tween(300))) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(start = if (level > 0) 12.dp else 0.dp, end = if (level > 0) 12.dp else 0.dp, bottom = if (level > 0) 8.dp else 0.dp)
                    .padding(top = 4.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) { content() }
        }
    }
}

@Composable
private fun ReadingItemView(
    reading: Reading, isExpanded: Boolean, onToggle: () -> Unit, onContentDoubleTap: () -> Unit,
    onGloballyPositioned: (LayoutCoordinates) -> Unit, interactionSource: MutableInteractionSource
) {
    HierarchicalCollapsibleSection(
        title = reading.typ, isExpanded = isExpanded, onToggle = onToggle, level = 1,
        modifier = Modifier.onGloballyPositioned(onGloballyPositioned), interactionSource = interactionSource
    ) {
        Column(
            modifier = Modifier
                .padding(vertical = 8.dp)
                .pointerInput(Unit) { detectTapGestures(onDoubleTap = { onContentDoubleTap() }) },
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            if (!reading.sigla.isNullOrBlank()) Text(buildAnnotatedString {
                withStyle(SpanStyle(fontWeight = FontWeight.Bold)) { append("Sigla: ") }; append(
                reading.sigla
            )
            })
            if (!reading.opis.isNullOrBlank()) Text(buildAnnotatedString {
                withStyle(SpanStyle(fontWeight = FontWeight.Bold)) { append("Opis: ") }; append(
                reading.opis
            )
            })
            Text(reading.tekst, style = MaterialTheme.typography.bodyMedium)
        }
    }
}

@Composable
private fun SongGroupView(momentName: String, songs: List<SuggestedSong>, isExpanded: Boolean, onToggle: () -> Unit, onSongClick: (SuggestedSong) -> Unit) {
    HierarchicalCollapsibleSection(title = momentName, isExpanded = isExpanded, onToggle = onToggle, level = 1) {
        if (songs.isEmpty()) {
            Text("Brak sugerowanych pieśni.", Modifier.padding(vertical = 8.dp, horizontal = 12.dp), style = MaterialTheme.typography.bodyMedium, fontStyle = FontStyle.Italic)
        } else {
            songs.forEach { song -> SongItemView(song = song, onClick = { onSongClick(song) }) }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun SongItemView(song: SuggestedSong, onClick: () -> Unit) {
    Card(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        shape = MaterialTheme.shapes.small,
        colors = CardDefaults.cardColors(containerColor = SongItemBackground)
    ) {
        Row(Modifier.padding(horizontal = 12.dp, vertical = 8.dp), verticalAlignment = Alignment.CenterVertically) {
            Text(song.piesn, Modifier.weight(1f), style = MaterialTheme.typography.bodyMedium.copy(fontStyle = FontStyle.Italic))
        }
    }
}

// =================================================================================
// Komponenty trybu edycji
// =================================================================================
@Composable fun SectionHeaderEditable(title: String) { Row(Modifier.fillMaxWidth().padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically) { Text(title, style = MaterialTheme.typography.titleLarge, fontWeight = FontWeight.Bold) } }
@Composable fun EditableSongCategoryHeader(categoryName: String) { Row(Modifier.fillMaxWidth().padding(vertical = 4.dp), verticalAlignment = Alignment.CenterVertically) { Text(categoryName, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold) } }

@Composable
fun EditableReadingItem(reading: Reading, isDragging: Boolean, onEditClick: () -> Unit, onDeleteClick: () -> Unit, reorderModifier: Modifier) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .shadow(if (isDragging) 4.dp else 0.dp)
            .clickable(onClick = onEditClick),
        elevation = CardDefaults.cardElevation(2.dp),
        colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
    ) {
        Row(Modifier.padding(horizontal = 12.dp, vertical = 8.dp), verticalAlignment = Alignment.CenterVertically) {
            Icon(Icons.Default.DragHandle, "Zmień kolejność", modifier = reorderModifier)
            Spacer(Modifier.width(8.dp))
            Column(Modifier.weight(1f)) {
                Text(reading.typ, fontWeight = FontWeight.Bold)
                Text(reading.sigla ?: "", style = MaterialTheme.typography.bodySmall, fontStyle = FontStyle.Italic)
            }
            IconButton(onClick = onDeleteClick) { Icon(Icons.Default.Delete, "Usuń", tint = MaterialTheme.colorScheme.error) }
        }
    }
}

@Composable
fun EditableSongItem(song: SuggestedSong, isDragging: Boolean, onEditClick: () -> Unit, onDeleteClick: () -> Unit, reorderModifier: Modifier, isReorderEnabled: Boolean) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .shadow(if (isDragging) 4.dp else 0.dp)
            .clickable(onClick = onEditClick),
        colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
    ) {
        Row(Modifier.padding(start = 8.dp), verticalAlignment = Alignment.CenterVertically) {
            if (isReorderEnabled) {
                Icon(Icons.Default.DragHandle, "Zmień kolejność", modifier = reorderModifier)
                Spacer(Modifier.width(8.dp))
            } else {
                Spacer(Modifier.width(32.dp)) // Placeholder to keep alignment
            }
            Text(song.piesn, modifier = Modifier.weight(1f), style = MaterialTheme.typography.bodyLarge)
            IconButton(onClick = onDeleteClick) { Icon(Icons.Default.Delete, "Usuń", tint = MaterialTheme.colorScheme.error) }
        }
    }
}

@Composable fun AddItemButton(text: String, onClick: () -> Unit) { Button(onClick, Modifier.fillMaxWidth().padding(vertical = 8.dp), shape = MaterialTheme.shapes.medium) { Icon(Icons.Default.Add, null); Spacer(Modifier.width(8.dp)); Text(text) } }

// =================================================================================
// Okna Dialogowe
// =================================================================================
@Composable
private fun ConfirmExitDialog(onDismiss: () -> Unit, onDiscard: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Odrzucić zmiany?",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text("Czy na pewno chcesz wyjść bez zapisywania zmian?", color = Color.White)
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDiscard) {
                        Text("Odrzuć", color = MaterialTheme.colorScheme.error)
                    }
                    Spacer(Modifier.width(8.dp))
                    Button(onClick = onDismiss) { Text("Anuluj") }
                }
            }
        }
    }
}

@Composable
private fun ConfirmDeleteDialog(description: String, onDismiss: () -> Unit, onConfirm: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Potwierdź usunięcie",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))

                val (prefix, itemName) = remember(description) {
                    val parts: List<String> = description.split(":", limit = 2)
                    if (parts.size == 2) {
                        // Poprawka: Wywołaj .trim() na elementach listy (parts[0] i parts[1]), a nie na samej liście.
                        Pair(parts[0].trim() + ":", parts[1].trim())
                    } else {
                        Pair("", description.trim())
                    }
                }

                Text(
                    buildAnnotatedString {
                        append("Czy na pewno chcesz usunąć ")
                        append(prefix)
                        if (prefix.isNotEmpty()) {
                            append(" ")
                        }
                        withStyle(style = SpanStyle(color = SaturatedNavy, fontWeight = FontWeight.Bold)) {
                            append(itemName)
                        }
                        append("?")
                    },
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = onConfirm,
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                    ) { Text("Usuń") }
                }
            }
        }
    }
}

@Composable
private fun AddEditReadingDialog(existingReading: Reading? = null, onDismiss: () -> Unit, onConfirm: (Reading) -> Unit) {
    var typ by remember { mutableStateOf(existingReading?.typ ?: "") }
    var sigla by remember { mutableStateOf(existingReading?.sigla ?: "") }
    var opis by remember { mutableStateOf(existingReading?.opis ?: "") }
    var tekst by remember { mutableStateOf(existingReading?.tekst ?: "") }
    val isTypValid by remember { derivedStateOf { typ.isNotBlank() } }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(Modifier.padding(16.dp).verticalScroll(rememberScrollState())) {
                Text(
                    if (existingReading == null) "Dodaj nowe czytanie" else "Edytuj czytanie",
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.padding(bottom = 16.dp),
                    color = SaturatedNavy
                )
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                OutlinedTextField(typ, { typ = it }, label = { Text("Typ*") }, isError = !isTypValid, modifier = Modifier.fillMaxWidth())
                Spacer(Modifier.height(8.dp))
                OutlinedTextField(sigla, { sigla = it }, label = { Text("Sigla") }, modifier = Modifier.fillMaxWidth())
                Spacer(Modifier.height(8.dp))
                OutlinedTextField(opis, { opis = it }, label = { Text("Opis") }, modifier = Modifier.fillMaxWidth())
                Spacer(Modifier.height(8.dp))
                OutlinedTextField(tekst, { tekst = it }, label = { Text("Tekst") }, modifier = Modifier.fillMaxWidth())
                Spacer(Modifier.height(16.dp))
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }; Spacer(Modifier.width(8.dp))
                    Button(onClick = { onConfirm(existingReading?.copy(typ = typ, sigla = sigla, opis = opis, tekst = tekst) ?: Reading(typ, sigla, opis, tekst)); onDismiss() }, enabled = isTypValid) { Text("Zapisz") }
                }
            }
        }
    }
}

@Composable
private fun AddEditSongDialog(
    moment: String,
    existingSong: SuggestedSong? = null,
    viewModel: DayDetailsViewModel,
    onDismiss: () -> Unit,
    onConfirm: (SuggestedSong, String, SuggestedSong?) -> Unit
) {
    var piesn by remember { mutableStateOf(existingSong?.piesn ?: "") }
    var numer by remember { mutableStateOf(existingSong?.numer ?: "") }
    var opis by remember { mutableStateOf(existingSong?.opis ?: "") }
    val isPiesnValid by remember { derivedStateOf { piesn.isNotBlank() } }

    val titleSearchResults by viewModel.songTitleSearchResults.collectAsState()
    val numberSearchResults by viewModel.songNumberSearchResults.collectAsState()
    val focusRequester = remember { FocusRequester() }

    LaunchedEffect(Unit) {
        viewModel.clearAllSearchResults()
        focusRequester.requestFocus()
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(Modifier.padding(16.dp)) {
                Text(
                    if (existingSong == null) "Dodaj nową pieśń" else "Edytuj pieśń",
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.padding(bottom = 16.dp),
                    color = SaturatedNavy
                )
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))

                Column {
                    OutlinedTextField(
                        value = piesn,
                        onValueChange = {
                            piesn = it
                            viewModel.searchSongsByTitle(it)
                        },
                        label = { Text("Tytuł pieśni*") },
                        isError = !isPiesnValid,
                        modifier = Modifier
                            .fillMaxWidth()
                            .focusRequester(focusRequester)
                    )
                    AnimatedVisibility(visible = titleSearchResults.isNotEmpty()) {
                        LazyColumn(
                            modifier = Modifier
                                .heightIn(max = 240.dp)
                                .fillMaxWidth()
                                .border(1.dp, MaterialTheme.colorScheme.outline)
                        ) {
                            items(
                                items = titleSearchResults,
                                key = { song -> "${song.tytul}-${song.numerSiedl}" }
                            ) { song ->
                                Text(
                                    text = viewModel.formatSongSuggestion(song),
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .clickable {
                                            piesn = song.tytul
                                            numer = song.numerSiedl
                                            viewModel.clearAllSearchResults()
                                        }
                                        .padding(12.dp),
                                    color = Color.LightGray
                                )
                            }
                        }
                    }
                }

                Spacer(Modifier.height(8.dp))

                Column {
                    OutlinedTextField(
                        value = numer,
                        onValueChange = {
                            numer = it
                            viewModel.searchSongsByNumber(it)
                        },
                        label = { Text("Numer") },
                        modifier = Modifier.fillMaxWidth()
                    )
                    AnimatedVisibility(visible = numberSearchResults.isNotEmpty()) {
                        LazyColumn(
                            modifier = Modifier
                                .heightIn(max = 240.dp)
                                .fillMaxWidth()
                                .border(1.dp, MaterialTheme.colorScheme.outline)
                        ) {
                            items(
                                items = numberSearchResults,
                                key = { song -> "${song.tytul}-${song.numerSiedl}" }
                            ) { song ->
                                Text(
                                    text = viewModel.formatSongSuggestion(song),
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .clickable {
                                            piesn = song.tytul
                                            numer = song.numerSiedl
                                            viewModel.clearAllSearchResults()
                                        }
                                        .padding(12.dp),
                                    color = Color.LightGray
                                )
                            }
                        }
                    }
                }

                Spacer(Modifier.height(8.dp))
                OutlinedTextField(opis, { opis = it }, label = { Text("Opis") }, modifier = Modifier.fillMaxWidth())
                Spacer(Modifier.height(16.dp))
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = {
                        viewModel.clearAllSearchResults()
                        onDismiss()
                    }) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = {
                            onConfirm(SuggestedSong(numer, piesn, opis, moment), moment, existingSong)
                            onDismiss()
                        },
                        enabled = isPiesnValid
                    ) { Text("Zapisz") }
                }
            }
        }
    }
}


@Composable
private fun SongDetailsModal(
    suggestedSong: SuggestedSong,
    fullSong: Song,
    onDismiss: () -> Unit,
    onShowContent: (song: Song, startInEdit: Boolean) -> Unit
) {
    Dialog(onDismissRequest = onDismiss, properties = DialogProperties(usePlatformDefaultWidth = false)) {
        Card(
            Modifier.fillMaxWidth().padding(horizontal = 24.dp, vertical = 48.dp),
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(Modifier.padding(24.dp)) {
                Row(Modifier.fillMaxWidth(), Arrangement.SpaceBetween, Alignment.CenterVertically) {
                    Text(
                        suggestedSong.piesn,
                        style = MaterialTheme.typography.titleLarge,
                        modifier = Modifier.weight(1f),
                        color = SaturatedNavy
                    )
                    IconButton(onClick = onDismiss, Modifier.size(24.dp)) { Icon(Icons.Default.Close, "Zamknij") }
                }
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Column(
                    Modifier
                        .verticalScroll(rememberScrollState())
                        .weight(1f, fill = false)
                ) {
                    SongNumberInfo("Siedlecki:", fullSong.numerSiedl)
                    SongNumberInfo("ŚAK:", fullSong.numerSAK)
                    SongNumberInfo("DN:", fullSong.numerDN)

                    if (suggestedSong.opis.isNotBlank()) {
                        Spacer(Modifier.height(16.dp))
                        Text(
                            buildAnnotatedString {
                                withStyle(SpanStyle(fontWeight = FontWeight.Bold)) { append("Opis:\n") }
                                append(suggestedSong.opis)
                            },
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
                Spacer(Modifier.height(24.dp))
                Button(
                    onClick = {
                        onShowContent(fullSong, false)
                        onDismiss()
                    },
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                ) {
                    Text("Treść")
                }
            }
        }
    }
}

@Composable
private fun SongNumberInfo(label: String, number: String) {
    val displayValue = number.ifBlank { "-" }
    Row {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Bold),
            modifier = Modifier.width(80.dp)
        )
        Text(
            text = displayValue,
            style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.Bold)
        )
    }
}


// =================================================================================
// Paski nawigacyjne (Top App Bars)
// =================================================================================
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun ViewModeTopAppBar(title: String, onNavigateBack: () -> Unit, onEditClick: () -> Unit) {
    Column {
        CenterAlignedTopAppBar(
            title = { AutoResizingText(text = title, style = MaterialTheme.typography.titleLarge, textAlign = TextAlign.Center) },
            navigationIcon = { IconButton(onClick = onNavigateBack) { Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć") } },
            actions = { IconButton(onClick = onEditClick) { Icon(Icons.Default.Edit, "Edytuj dzień") } },
            colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = MaterialTheme.colorScheme.background, titleContentColor = MaterialTheme.colorScheme.primary, navigationIconContentColor = MaterialTheme.colorScheme.primary)
        ); Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun EditModeTopAppBar(title: String, onCancelClick: () -> Unit, onSaveClick: () -> Unit, isSaveEnabled: Boolean) {
    Column {
        CenterAlignedTopAppBar(
            title = { AutoResizingText(text = title, style = MaterialTheme.typography.titleLarge, textAlign = TextAlign.Center) },
            navigationIcon = { IconButton(onClick = onCancelClick) { Icon(Icons.Default.Close, "Anuluj edycję") } },
            actions = { IconButton(onClick = onSaveClick, enabled = isSaveEnabled) { Icon(Icons.Default.Check, "Zapisz zmiany", tint = if (isSaveEnabled) MaterialTheme.colorScheme.primary else Color.Gray) } },
            colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = MaterialTheme.colorScheme.background, titleContentColor = MaterialTheme.colorScheme.primary, navigationIconContentColor = MaterialTheme.colorScheme.primary)
        ); Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\daydetails\DayDetailsViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.daydetails

import android.content.Context
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.DayData
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import com.qjproject.liturgicalcalendar.data.Reading
import com.qjproject.liturgicalcalendar.data.Song
import com.qjproject.liturgicalcalendar.data.SuggestedSong
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

sealed class DialogState {
    object None : DialogState()
    data class ConfirmDelete(val item: Any, val description: String) : DialogState()
    data class AddEditSong(val moment: String, val existingSong: SuggestedSong? = null) : DialogState()
}

data class DayDetailsUiState(
    val isLoading: Boolean = true,
    val dayData: DayData? = null,
    val error: String? = null,
    val isEditMode: Boolean = false,
    val hasChanges: Boolean = false,
    val showConfirmExitDialog: Boolean = false,
    val activeDialog: DialogState = DialogState.None,
    val isReadingsSectionExpanded: Boolean = true,
    val isSongsSectionExpanded: Boolean = true,
    val expandedReadings: Set<Int> = emptySet(),
    val expandedSongMoments: Set<String> = songMomentOrderMap.keys
)

val songMomentOrderMap: LinkedHashMap<String, String> = linkedMapOf(
    "wejscie" to "Wejście",
    "ofiarowanie" to "Ofiarowanie",
    "komunia" to "Komunia",
    "uwielbienie" to "Uwielbienie",
    "rozeslanie" to "Rozesłanie",
    "ogolne" to "Ogólne"
)

class DayDetailsViewModel(
    private val dayId: String,
    private val repository: FileSystemRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(DayDetailsUiState())
    val uiState: StateFlow<DayDetailsUiState> = _uiState.asStateFlow()

    private val _songTitleSearchQuery = MutableStateFlow("")
    val songTitleSearchResults = MutableStateFlow<List<Song>>(emptyList())

    private val _songNumberSearchQuery = MutableStateFlow("")
    val songNumberSearchResults = MutableStateFlow<List<Song>>(emptyList())

    var editableDayData: MutableState<DayData?> = mutableStateOf(null)
        private set

    val groupedSongs: StateFlow<Map<String, List<SuggestedSong>>> = _uiState.map { state ->
        state.dayData?.piesniSugerowane
            .orEmpty()
            .filterNotNull()
            .groupBy { it.moment }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyMap())

    init {
        loadDayData()
        observeSearchQueries()
    }

    private fun observeSearchQueries() {
        viewModelScope.launch {
            _songTitleSearchQuery.debounce(300).distinctUntilChanged().collectLatest { query ->
                if (query.length < 2) {
                    songTitleSearchResults.value = emptyList()
                } else {
                    songTitleSearchResults.value = repository.getSongList().filter {
                        it.tytul.contains(query, ignoreCase = true)
                    }.take(10)
                }
            }
        }
        viewModelScope.launch {
            _songNumberSearchQuery.debounce(300).distinctUntilChanged().collectLatest { query ->
                if (query.isBlank()) {
                    songNumberSearchResults.value = emptyList()
                } else {
                    songNumberSearchResults.value = repository.getSongList().filter {
                        it.numerSiedl.startsWith(query, ignoreCase = true)
                    }.take(10)
                }
            }
        }
    }

    private fun loadDayData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val data = repository.getDayData(dayId)
            if (data != null) {
                _uiState.update { it.copy(isLoading = false, dayData = data) }
            } else {
                _uiState.update { it.copy(isLoading = false, error = "Nie udało się wczytać danych dla tego dnia.") }
            }
        }
    }

    fun onEnterEditMode() {
        editableDayData.value = _uiState.value.dayData?.copy()
        _uiState.update { it.copy(isEditMode = true, hasChanges = false) }
    }

    fun onTryExitEditMode() {
        if (_uiState.value.hasChanges) {
            _uiState.update { it.copy(showConfirmExitDialog = true) }
        } else {
            onExitEditMode(save = false)
        }
    }

    fun onExitEditMode(save: Boolean) {
        viewModelScope.launch {
            if (save && _uiState.value.hasChanges) {
                val dataToSave = editableDayData.value
                if (dataToSave != null) {
                    repository.saveDayData(dayId, dataToSave).onSuccess {
                        _uiState.update { currentState -> currentState.copy(dayData = dataToSave) }
                    }
                }
            }
            _uiState.update { it.copy(isEditMode = false, hasChanges = false, showConfirmExitDialog = false) }
            editableDayData.value = null
            loadDayData()
        }
    }

    fun dismissConfirmExitDialog() {
        _uiState.update { it.copy(showConfirmExitDialog = false) }
    }

    fun showDialog(dialogState: DialogState) { _uiState.update { it.copy(activeDialog = dialogState) } }
    fun dismissDialog() { _uiState.update { it.copy(activeDialog = DialogState.None) } }

    fun toggleReadingsSection() { _uiState.update { it.copy(isReadingsSectionExpanded = !it.isReadingsSectionExpanded) } }
    fun toggleSongsSection() { _uiState.update { it.copy(isSongsSectionExpanded = !it.isSongsSectionExpanded) } }

    fun toggleReading(index: Int) {
        _uiState.update {
            val updatedSet = it.expandedReadings.toMutableSet()
            if (updatedSet.contains(index)) updatedSet.remove(index) else updatedSet.add(index)
            it.copy(expandedReadings = updatedSet)
        }
    }

    fun collapseReading(index: Int) {
        _uiState.update {
            val updatedSet = it.expandedReadings.toMutableSet()
            updatedSet.remove(index)
            it.copy(expandedReadings = updatedSet)
        }
    }

    fun toggleSongMoment(moment: String) {
        _uiState.update {
            val updatedSet = it.expandedSongMoments.toMutableSet()
            if (updatedSet.contains(moment)) updatedSet.remove(moment) else updatedSet.add(moment)
            it.copy(expandedSongMoments = updatedSet)
        }
    }

    fun getFullSong(suggestedSong: SuggestedSong, onResult: (Song?) -> Unit) {
        viewModelScope.launch {
            val song = repository.getSong(suggestedSong.piesn, suggestedSong.numer, null, null)
            onResult(song)
        }
    }

    private fun updateEditableData(transform: (DayData) -> DayData) {
        editableDayData.value?.let {
            editableDayData.value = transform(it)
            _uiState.update { state -> state.copy(hasChanges = true) }
        }
    }

    fun addOrUpdateReading(reading: Reading, index: Int?) {
        updateEditableData { currentData ->
            val readings = currentData.czytania.toMutableList()
            if (index != null && index in readings.indices) {
                readings[index] = reading
            } else {
                readings.add(reading)
            }
            currentData.copy(czytania = readings)
        }
    }

    fun deleteItem(item: Any) {
        when (item) {
            is Reading -> {
                updateEditableData { currentData ->
                    currentData.copy(czytania = currentData.czytania - item)
                }
            }
            is SuggestedSong -> {
                updateEditableData { currentData ->
                    currentData.copy(piesniSugerowane = currentData.piesniSugerowane.orEmpty() - item)
                }
            }
        }
        dismissDialog()
    }

    fun reorderReadings(from: Int, to: Int) {
        updateEditableData { currentData ->
            val reorderedList = currentData.czytania.toMutableList().apply {
                add(to, removeAt(from))
            }
            currentData.copy(czytania = reorderedList)
        }
    }

    fun reorderSongs(moment: String, from: Int, to: Int) {
        updateEditableData { currentData ->
            val allSongs = currentData.piesniSugerowane.orEmpty().filterNotNull().toMutableList()
            val songsInMoment = allSongs.filter { it.moment == moment }.toMutableList()

            if (from in songsInMoment.indices && to in songsInMoment.indices) {
                val movedItem = songsInMoment.removeAt(from)
                songsInMoment.add(to, movedItem)

                val otherSongs = allSongs.filter { it.moment != moment }
                val newFullList = (otherSongs + songsInMoment).sortedWith(
                    compareBy { songMomentOrderMap.keys.indexOf(it.moment) }
                )
                currentData.copy(piesniSugerowane = newFullList)
            } else {
                currentData
            }
        }
    }

    fun addOrUpdateSong(song: SuggestedSong, moment: String, originalSong: SuggestedSong?) {
        updateEditableData { currentData ->
            val songs = currentData.piesniSugerowane.orEmpty().filterNotNull().toMutableList()
            if (originalSong != null) {
                val index = songs.indexOf(originalSong)
                if (index != -1) {
                    songs[index] = song
                }
            } else {
                songs.add(song)
            }
            currentData.copy(piesniSugerowane = songs)
        }
        dismissDialog()
    }

    fun searchSongsByTitle(query: String) {
        _songTitleSearchQuery.value = query
        if (query.length < 2) songTitleSearchResults.value = emptyList()
    }

    fun searchSongsByNumber(query: String) {
        _songNumberSearchQuery.value = query
        if (query.isBlank()) songNumberSearchResults.value = emptyList()
    }

    fun formatSongSuggestion(song: Song): String {
        val numberInfo = buildList {
            if (song.numerSiedl.isNotBlank()) add("Siedl: ${song.numerSiedl}")
            if (song.numerSAK.isNotBlank()) add("ŚAK: ${song.numerSAK}")
            if (song.numerDN.isNotBlank()) add("DN: ${song.numerDN}")
        }.joinToString(", ")

        return if (numberInfo.isNotEmpty()) {
            "${song.tytul} ($numberInfo)"
        } else {
            song.tytul
        }
    }

    fun clearAllSearchResults() {
        songTitleSearchResults.value = emptyList()
        songNumberSearchResults.value = emptyList()
        _songTitleSearchQuery.value = ""
        _songNumberSearchQuery.value = ""
    }
}

class DayDetailsViewModelFactory(
    private val context: Context,
    private val dayId: String
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(DayDetailsViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return DayDetailsViewModel(dayId, FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\search\SearchScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.search

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.clickable
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.outlined.Article
import androidx.compose.material.icons.outlined.MusicNote
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.viewmodel.compose.viewModel
import com.qjproject.liturgicalcalendar.data.Song
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy

@Composable
fun SearchScreen(
    viewModel: SearchViewModel,
    onNavigateToSong: (Song) -> Unit,
) {
    val uiState by viewModel.uiState.collectAsState()
    // --- POCZĄTEK ZMIANY ---
    val lifecycleOwner = LocalLifecycleOwner.current

    // Odświeża wyniki wyszukiwania po powrocie na ekran, aby odzwierciedlić zmiany
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_RESUME) {
                viewModel.triggerSearch()
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
    // --- KONIEC ZMIANY ---

    if (uiState.showAddSongDialog) {
        AddSongDialog(
            error = uiState.addSongError,
            onDismiss = { viewModel.onDismissAddSongDialog() },
            onConfirm = { title, siedl, sak, dn, text ->
                viewModel.saveNewSong(title, siedl, sak, dn, text)
            },
            onValidate = { title, siedl, sak, dn ->
                viewModel.validateSongInput(title, siedl, sak, dn)
            }
        )
    }

    when(val dialogState = uiState.deleteDialogState) {
        is DeleteDialogState.ConfirmInitial -> {
            ConfirmDeleteDialog(
                song = dialogState.song,
                onConfirm = { viewModel.onConfirmInitialDelete() },
                onDismiss = { viewModel.onDismissDeleteDialog() }
            )
        }
        is DeleteDialogState.ConfirmOccurrences -> {
            ConfirmDeleteOccurrencesDialog(
                song = dialogState.song,
                onConfirmDeleteAll = { viewModel.onFinalDelete(true) },
                onConfirmDeleteOne = { viewModel.onFinalDelete(false) },
                onDismiss = { viewModel.onDismissDeleteDialog() }
            )
        }
        is DeleteDialogState.None -> {}
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            SearchBar(
                query = uiState.query,
                onQueryChange = viewModel::onQueryChange
            )

            Divider()

            when {
                uiState.isLoading -> {
                    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        CircularProgressIndicator()
                    }
                }

                uiState.searchPerformed && uiState.results.isEmpty() -> {
                    NoResults()
                }

                else -> {
                    ResultsList(
                        results = uiState.results,
                        onNavigateToSong = onNavigateToSong,
                        onSongLongClick = { song -> viewModel.onSongLongPress(song) }
                    )
                }
            }
        }
        FloatingActionButton(
            onClick = { viewModel.onAddSongClicked() },
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .padding(16.dp)
        ) {
            Icon(Icons.Default.Add, contentDescription = "Dodaj pieśń")
        }
    }
}

@Composable
fun SearchBar(query: String, onQueryChange: (String) -> Unit) {
    OutlinedTextField(
        value = query,
        onValueChange = onQueryChange,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        placeholder = { Text("Wyszukaj...") },
        leadingIcon = { Icon(Icons.Default.Search, contentDescription = "Ikona wyszukiwania") },
        trailingIcon = {
            if (query.isNotEmpty()) {
                IconButton(onClick = { onQueryChange("") }) {
                    Icon(Icons.Default.Clear, contentDescription = "Wyczyść")
                }
            }
        },
        singleLine = true,
        shape = MaterialTheme.shapes.extraLarge,
        textStyle = MaterialTheme.typography.bodyLarge
    )
}

@Composable
fun NoResults() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = "Dla tej frazy nie znaleziono żadnego dopasowania.",
            textAlign = TextAlign.Center,
            style = MaterialTheme.typography.bodyLarge
        )
    }
}

@Composable
fun ResultsList(
    results: List<Song>,
    onNavigateToSong: (Song) -> Unit,
    onSongLongClick: (Song) -> Unit
) {
    LazyColumn(
        contentPadding = PaddingValues(
            start = 8.dp,
            end = 8.dp,
            top = 8.dp,
            bottom = 80.dp
        ),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(results, key = { song ->
            "song_${song.numerSiedl}_${song.tytul.hashCode()}"
        }) { song ->
            SongResultItem(
                song = song,
                onClick = { onNavigateToSong(song) },
                onLongClick = { onSongLongClick(song) }
            )
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun SongResultItem(
    song: Song,
    onClick: () -> Unit,
    onLongClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .combinedClickable(
                onClick = onClick,
                onLongClick = onLongClick
            ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(Icons.Outlined.MusicNote, contentDescription = "Pieśń", tint = MaterialTheme.colorScheme.primary)
            Spacer(Modifier.width(16.dp))
            Text(song.tytul, modifier = Modifier.weight(1f), maxLines = 1, overflow = TextOverflow.Ellipsis)
            Spacer(Modifier.width(8.dp))
            Text(song.kategoriaSkr, fontWeight = FontWeight.Bold)
        }
    }
}

@Composable
private fun AddSongDialog(
    error: String?,
    onDismiss: () -> Unit,
    onConfirm: (title: String, siedl: String, sak: String, dn: String, text: String) -> Unit,
    onValidate: (title: String, siedl: String, sak: String, dn: String) -> Unit
) {
    var title by remember { mutableStateOf("") }
    var numerSiedl by remember { mutableStateOf("") }
    var numerSak by remember { mutableStateOf("") }
    var numerDn by remember { mutableStateOf("") }
    var text by remember { mutableStateOf("") }
    val isAnyNumberPresent by remember { derivedStateOf { numerSiedl.isNotBlank() || numerSak.isNotBlank() || numerDn.isNotBlank() } }


    LaunchedEffect(title, numerSiedl, numerSak, numerDn) {
        onValidate(title, numerSiedl, numerSak, numerDn)
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(
                modifier = Modifier
                    .padding(24.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    "Dodaj nową pieśń",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))

                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    OutlinedTextField(
                        value = title,
                        onValueChange = { title = it },
                        label = { Text("Tytuł") },
                        isError = error != null,
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth()
                    )
                    OutlinedTextField(
                        value = numerSiedl,
                        onValueChange = { numerSiedl = it },
                        label = { Text("Numer Siedlecki") },
                        isError = error != null,
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth()
                    )
                    OutlinedTextField(
                        value = numerSak,
                        onValueChange = { numerSak = it },
                        label = { Text("Numer ŚAK") },
                        isError = error != null,
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth()
                    )
                    OutlinedTextField(
                        value = numerDn,
                        onValueChange = { numerDn = it },
                        label = { Text("Numer DN") },
                        isError = error != null,
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth()
                    )
                    OutlinedTextField(
                        value = text,
                        onValueChange = { text = it },
                        label = { Text("Tekst") },
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(150.dp)
                    )
                    if (error != null) {
                        Text(
                            text = error,
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodySmall,
                            modifier = Modifier.padding(top = 4.dp)
                        )
                    }
                }

                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) {
                        Text("Anuluj")
                    }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = { onConfirm(title, numerSiedl, numerSak, numerDn, text) },
                        enabled = title.isNotBlank() && isAnyNumberPresent && error == null
                    ) {
                        Text("Zapisz")
                    }
                }
            }
        }
    }
}

@Composable
private fun ConfirmDeleteDialog(
    song: Song,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Usunąć pieśń?",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text(
                    buildAnnotatedString {
                        append("Czy na pewno chcesz usunąć pieśń ")
                        withStyle(style = SpanStyle(color = SaturatedNavy, fontWeight = FontWeight.Bold)) {
                            append(song.tytul)
                        }
                        append("?")
                    }
                )
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) { Text("Anuluj") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = onConfirm,
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                    ) {
                        Text("Usuń")
                    }
                }
            }
        }
    }
}

@Composable
private fun ConfirmDeleteOccurrencesDialog(
    song: Song,
    onConfirmDeleteAll: () -> Unit,
    onConfirmDeleteOne: () -> Unit,
    onDismiss: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Usunąć powiązania?",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text(
                    buildAnnotatedString {
                        append("Czy chcesz również usunąć pieśń ")
                        withStyle(style = SpanStyle(color = SaturatedNavy, fontWeight = FontWeight.Bold)) {
                            append(song.tytul)
                        }
                        append(" ze wszystkich list sugerowanych pieśni w dniach liturgicznych?")
                    }
                )
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(
                        onClick = onConfirmDeleteOne,
                    ) {
                        Text("Nie, dziękuję")
                    }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = onConfirmDeleteAll,
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                    ) {
                        Text("Tak, usuń")
                    }
                }
            }
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\search\SearchViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.search

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import com.qjproject.liturgicalcalendar.data.Song
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.util.Locale

enum class SongSortMode { Alfabetycznie, Kategoria }

sealed class DeleteDialogState {
    object None : DeleteDialogState()
    data class ConfirmInitial(val song: Song) : DeleteDialogState()
    data class ConfirmOccurrences(val song: Song) : DeleteDialogState()
}

data class SearchUiState(
    val query: String = "",
    val results: List<Song> = emptyList(),
    val searchPerformed: Boolean = false,
    val isLoading: Boolean = false,
    // Song-specific options
    val searchInTitle: Boolean = true,
    val searchInContent: Boolean = false,
    val sortMode: SongSortMode = SongSortMode.Alfabetycznie,
    val showAddSongDialog: Boolean = false,
    val addSongError: String? = null,
    val deleteDialogState: DeleteDialogState = DeleteDialogState.None
)

class SearchViewModel(private val repository: FileSystemRepository) : ViewModel() {

    private val _uiState = MutableStateFlow(SearchUiState())
    val uiState = _uiState.asStateFlow()

    private val _queryFlow = MutableStateFlow("")
    private var searchJob: Job? = null

    // Cache for song list to avoid reading from disk on every validation
    private var allSongsCache: List<Song>? = null

    init {
        _queryFlow
            .debounce(500)
            .distinctUntilChanged()
            .onEach { triggerSearch() }
            .launchIn(viewModelScope)
    }

    // --- POCZĄTEK ZMIANY ---
    fun triggerSearch() {
        searchJob?.cancel()
        repository.invalidateSongCache() // Unieważnij pamięć podręczną, aby pobrać świeże dane
        performSearch(_uiState.value.query)
    }
    // --- KONIEC ZMIANY ---

    fun onQueryChange(newQuery: String) {
        _uiState.update { it.copy(query = newQuery) }
        _queryFlow.value = newQuery
    }

    fun onSearchInTitleChange(isChecked: Boolean) {
        if (_uiState.value.searchInTitle == isChecked || (!isChecked && !_uiState.value.searchInContent)) return
        _uiState.update { it.copy(searchInTitle = isChecked) }
        triggerSearch()
    }

    fun onSearchInContentChange(isChecked: Boolean) {
        if (_uiState.value.searchInContent == isChecked || (!isChecked && !_uiState.value.searchInTitle)) return
        _uiState.update { it.copy(searchInContent = isChecked) }
        triggerSearch()
    }

    fun onSortModeChange(newSortMode: SongSortMode) {
        if (_uiState.value.sortMode == newSortMode) return
        _uiState.update { it.copy(sortMode = newSortMode) }
        val sortedResults = sortSongs(_uiState.value.results)
        _uiState.update { it.copy(results = sortedResults) }
    }


    private fun normalize(text: String?): String {
        if (text == null) return ""
        val withoutSpecialChars = text.replace(Regex("[^\\p{L}\\p{N}\\s]"), "")
        return withoutSpecialChars.lowercase(Locale.getDefault())
    }

    private fun performSearch(query: String) {
        searchJob = viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val results = searchSongs(query)
            _uiState.update { it.copy(results = results, searchPerformed = true, isLoading = false) }
        }
    }

    private fun searchSongs(query: String): List<Song> {
        val allSongs = repository.getSongList()
        val normalizedQuery = normalize(query)
        val trimmedQuery = query.trim()
        val state = _uiState.value

        if (trimmedQuery.isBlank()) {
            return sortSongs(allSongs)
        }

        val bySiedlecki = allSongs.filter { it.numerSiedl.equals(trimmedQuery, ignoreCase = true) }
        if (bySiedlecki.isNotEmpty()) return sortSongs(bySiedlecki)

        val bySak = allSongs.filter { it.numerSAK.equals(trimmedQuery, ignoreCase = true) }
        if (bySak.isNotEmpty()) return sortSongs(bySak)

        val byDn = allSongs.filter { it.numerDN.equals(trimmedQuery, ignoreCase = true) }
        if (byDn.isNotEmpty()) return sortSongs(byDn)

        // Filter by other criteria
        val filteredSongs = allSongs.filter { song ->
            val matchesTitle = state.searchInTitle && normalize(song.tytul).contains(normalizedQuery)
            val matchesContent = state.searchInContent && normalize(song.tekst ?: "").contains(normalizedQuery)
            matchesTitle || matchesContent
        }

        return sortSongs(filteredSongs)
    }

    private fun sortSongs(songs: List<Song>): List<Song> {
        return when (_uiState.value.sortMode) {
            SongSortMode.Alfabetycznie -> songs.sortedBy { it.tytul }
            SongSortMode.Kategoria -> songs.sortedWith(
                compareBy<Song> { it.kategoria }.thenBy { it.tytul }
            )
        }
    }

    fun onAddSongClicked() {
        viewModelScope.launch {
            allSongsCache = repository.getSongList() // Load song list when dialog is about to be shown
            _uiState.update { it.copy(showAddSongDialog = true, addSongError = null) }
        }
    }

    fun onDismissAddSongDialog() {
        _uiState.update { it.copy(showAddSongDialog = false, addSongError = null) }
        allSongsCache = null // Clear cache
    }

    fun validateSongInput(title: String, siedl: String, sak: String, dn: String) {
        val songs = allSongsCache ?: return
        val trimmedTitle = title.trim()
        val trimmedSiedl = siedl.trim()
        val trimmedSak = sak.trim()
        val trimmedDn = dn.trim()

        if (trimmedTitle.isNotBlank() && songs.any { it.tytul.equals(trimmedTitle, ignoreCase = true) }) {
            _uiState.update { it.copy(addSongError = "Pieśń o tym tytule już istnieje.") }
            return
        }

        if (trimmedSiedl.isNotBlank() && songs.any { it.numerSiedl.equals(trimmedSiedl, ignoreCase = true) }) {
            _uiState.update { it.copy(addSongError = "Pieśń o tym numerze (Siedlecki) już istnieje.") }
            return
        }

        if (trimmedSak.isNotBlank() && songs.any { it.numerSAK.equals(trimmedSak, ignoreCase = true) }) {
            _uiState.update { it.copy(addSongError = "Pieśń o tym numerze (ŚAK) już istnieje.") }
            return
        }

        if (trimmedDn.isNotBlank() && songs.any { it.numerDN.equals(trimmedDn, ignoreCase = true) }) {
            _uiState.update { it.copy(addSongError = "Pieśń o tym numerze (DN) już istnieje.") }
            return
        }

        _uiState.update { it.copy(addSongError = null) }
    }

    fun saveNewSong(title: String, siedl: String, sak: String, dn: String, text: String) {
        val trimmedTitle = title.trim()
        val trimmedSiedl = siedl.trim()
        val trimmedSak = sak.trim()
        val trimmedDn = dn.trim()
        val trimmedText = text.trim()

        if (trimmedTitle.isBlank()) {
            _uiState.update { it.copy(addSongError = "Tytuł jest wymagany.") }
            return
        }

        if (trimmedSiedl.isBlank() && trimmedSak.isBlank() && trimmedDn.isBlank()) {
            _uiState.update { it.copy(addSongError = "Przynajmniej jeden numer jest wymagany.") }
            return
        }

        validateSongInput(trimmedTitle, trimmedSiedl, trimmedSak, trimmedDn)
        if (_uiState.value.addSongError != null) {
            return
        }

        viewModelScope.launch {
            val songs = (allSongsCache ?: repository.getSongList()).toMutableList()
            val newSong = Song(
                tytul = trimmedTitle,
                tekst = trimmedText.ifBlank { null },
                numerSiedl = trimmedSiedl,
                numerSAK = trimmedSak,
                numerDN = trimmedDn,
                kategoria = "",
                kategoriaSkr = ""
            )
            songs.add(newSong)

            repository.saveSongList(songs).fold(
                onSuccess = {
                    onDismissAddSongDialog()
                    triggerSearch() // Refresh the list
                },
                onFailure = { error ->
                    _uiState.update {
                        it.copy(
                            addSongError = "Błąd zapisu: ${error.localizedMessage}"
                        )
                    }
                }
            )
        }
    }

    fun onSongLongPress(song: Song) {
        _uiState.update { it.copy(deleteDialogState = DeleteDialogState.ConfirmInitial(song)) }
    }

    fun onDismissDeleteDialog() {
        _uiState.update { it.copy(deleteDialogState = DeleteDialogState.None) }
    }

    fun onConfirmInitialDelete() {
        val currentState = _uiState.value.deleteDialogState
        if (currentState is DeleteDialogState.ConfirmInitial) {
            _uiState.update { it.copy(deleteDialogState = DeleteDialogState.ConfirmOccurrences(currentState.song)) }
        }
    }

    fun onFinalDelete(deleteOccurrences: Boolean) {
        val currentState = _uiState.value.deleteDialogState
        if (currentState is DeleteDialogState.ConfirmOccurrences) {
            viewModelScope.launch {
                repository.deleteSong(currentState.song, deleteOccurrences).onSuccess {
                    allSongsCache = null // Invalidate cache after deletion
                    triggerSearch() // Refresh list on success
                }
                // Dismiss dialog regardless of success or failure
                onDismissDeleteDialog()
            }
        }
    }
}

class SearchViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SearchViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return SearchViewModel(FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\settings\SettingsScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.settings

import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Category
import androidx.compose.material.icons.filled.Download
import androidx.compose.material.icons.filled.Upload
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy

@Composable
fun SettingsScreen(
    viewModel: SettingsViewModel,
    onRestartApp: () -> Unit,
    onNavigateToCategoryManagement: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    val importLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent(),
        onResult = { uri ->
            uri?.let { viewModel.importData(it) }
        }
    )

    LaunchedEffect(uiState.message) {
        uiState.message?.let {
            snackbarHostState.showSnackbar(it)
            viewModel.clearMessage()
        }
    }

    if (uiState.showRestartPrompt) {
        RestartPromptDialog(
            onDismiss = { viewModel.dismissRestartPrompt() },
            onConfirm = onRestartApp
        )
    }

    Scaffold(
        snackbarHost = {
            SnackbarHost(hostState = snackbarHostState) { data ->
                Snackbar(
                    snackbarData = data,
                    containerColor = MaterialTheme.colorScheme.inverseSurface,
                    contentColor = MaterialTheme.colorScheme.inverseOnSurface
                )
            }
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
        ) {
            SettingsTile(
                title = "Eksportuj dane",
                subtitle = "Zapisz kopię zapasową swoich danych",
                icon = Icons.Default.Upload,
                isLoading = uiState.isExporting,
                onClick = { viewModel.exportData() },
                enabled = !uiState.isImporting && !uiState.isExporting
            )
            SettingsTile(
                title = "Importuj dane",
                subtitle = "Przywróć dane z kopii zapasowej",
                icon = Icons.Default.Download,
                isLoading = uiState.isImporting,
                onClick = { importLauncher.launch("application/zip") },
                enabled = !uiState.isImporting && !uiState.isExporting
            )
            Divider(modifier = Modifier.padding(vertical = 8.dp))
            SettingsTile(
                title = "Zarządzaj kategoriami",
                subtitle = "Dodawaj, edytuj i usuwaj kategorie pieśni",
                icon = Icons.Default.Category,
                onClick = onNavigateToCategoryManagement,
                enabled = !uiState.isImporting && !uiState.isExporting
            )
        }
    }
}

@Composable
fun SettingsTile(
    title: String,
    subtitle: String,
    icon: ImageVector,
    onClick: () -> Unit,
    isLoading: Boolean = false,
    enabled: Boolean = true
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick, enabled = enabled),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        // --- POCZĄTEK ZMIANY ---
        colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        // --- KONIEC ZMIANY ---
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                modifier = Modifier.size(32.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(text = title, style = MaterialTheme.typography.titleMedium)
                Text(text = subtitle, style = MaterialTheme.typography.bodySmall)
            }
            if (isLoading) {
                Spacer(Modifier.width(16.dp))
                CircularProgressIndicator(modifier = Modifier.size(24.dp))
            }
        }
    }
}

@Composable
fun RestartPromptDialog(onDismiss: () -> Unit, onConfirm: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(Modifier.padding(24.dp)) {
                Text(
                    "Import zakończony",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text("Dane zostały pomyślnie zaimportowane. Aby zmiany były widoczne, aplikacja musi zostać uruchomiona ponownie.")
                Spacer(Modifier.height(24.dp))
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDismiss) {
                        Text("Później")
                    }
                    Spacer(Modifier.width(8.dp))
                    Button(onClick = onConfirm) {
                        Text("Uruchom ponownie")
                    }
                }
            }
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\settings\SettingsViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.settings

import android.content.Context
import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

data class SettingsUiState(
    val isExporting: Boolean = false,
    val isImporting: Boolean = false,
    val message: String? = null,
    val showRestartPrompt: Boolean = false
)

class SettingsViewModel(private val repository: FileSystemRepository) : ViewModel() {
    private val _uiState = MutableStateFlow(SettingsUiState())
    val uiState = _uiState.asStateFlow()

    fun exportData() {
        _uiState.update { it.copy(isExporting = true, message = null) }
        val result = repository.exportDataToZip()
        result.fold(
            onSuccess = { file ->
                _uiState.update { it.copy(isExporting = false, message = "Eksport udany! Zapisano jako ${file.name} w folderze Pobrane.") }
            },
            onFailure = { error ->
                _uiState.update { it.copy(isExporting = false, message = "Błąd eksportu: ${error.localizedMessage}") }
            }
        )
    }

    fun importData(uri: Uri) {
        viewModelScope.launch {
            _uiState.update { it.copy(isImporting = true, message = null) }
            val result = repository.importDataFromZip(uri)
            result.fold(
                onSuccess = {
                    _uiState.update { it.copy(isImporting = false, showRestartPrompt = true) }
                },
                onFailure = { error ->
                    _uiState.update { it.copy(isImporting = false, message = "Błąd importu: ${error.localizedMessage}") }
                }
            )
        }
    }

    fun clearMessage() {
        _uiState.update { it.copy(message = null) }
    }

    fun dismissRestartPrompt() {
        _uiState.update { it.copy(showRestartPrompt = false) }
    }
}

class SettingsViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SettingsViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return SettingsViewModel(FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\songcontent\SongContentScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.songcontent

import androidx.activity.compose.BackHandler
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.qjproject.liturgicalcalendar.ui.components.AutoResizingText
import com.qjproject.liturgicalcalendar.ui.theme.SaturatedNavy
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SongContentScreen(
    viewModel: SongContentViewModel,
    onNavigateBack: () -> Unit,
    startInEditMode: Boolean = false
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(startInEditMode) {
        if (startInEditMode) {
            viewModel.onEnterEditMode()
        }
    }

    BackHandler(enabled = uiState.isEditMode) {
        viewModel.onTryExitEditMode()
    }
    BackHandler(enabled = !uiState.isEditMode, onBack = onNavigateBack)

    if (uiState.showConfirmExitDialog) {
        ConfirmExitDialog(
            onDismiss = { viewModel.dismissConfirmExitDialog() },
            onDiscard = { viewModel.onDiscardChanges() }
        )
    }

    Scaffold(
        topBar = {
            if (uiState.isEditMode) {
                EditModeTopAppBar(
                    title = uiState.song?.tytul ?: "Edycja",
                    onCancelClick = { viewModel.onTryExitEditMode() },
                    onSaveClick = { viewModel.onSaveChanges() },
                    isSaveEnabled = uiState.hasChanges
                )
            } else {
                ViewModeTopAppBar(
                    title = uiState.song?.tytul ?: "Ładowanie...",
                    onNavigateBack = onNavigateBack,
                    onEditClick = { viewModel.onEnterEditMode() }
                )
            }
        }
    ) { innerPadding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .imePadding()
        ) {
            when {
                uiState.isLoading -> {
                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
                }
                uiState.error != null -> {
                    Text(
                        text = "Błąd: ${uiState.error}",
                        modifier = Modifier.align(Alignment.Center),
                        color = MaterialTheme.colorScheme.error
                    )
                }
                uiState.isEditMode -> {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .verticalScroll(rememberScrollState())
                            .padding(horizontal = 16.dp, vertical = 8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        OutlinedTextField(
                            value = viewModel.editableTitle.value,
                            onValueChange = { viewModel.onEditableFieldChange(title = it) },
                            label = { Text("Tytuł") },
                            modifier = Modifier.fillMaxWidth()
                        )
                        OutlinedTextField(
                            value = viewModel.editableNumerSiedl.value,
                            onValueChange = { viewModel.onEditableFieldChange(siedl = it) },
                            label = { Text("Numer Siedlecki") },
                            modifier = Modifier.fillMaxWidth()
                        )
                        OutlinedTextField(
                            value = viewModel.editableNumerSak.value,
                            onValueChange = { viewModel.onEditableFieldChange(sak = it) },
                            label = { Text("Numer ŚAK") },
                            modifier = Modifier.fillMaxWidth()
                        )
                        OutlinedTextField(
                            value = viewModel.editableNumerDn.value,
                            onValueChange = { viewModel.onEditableFieldChange(dn = it) },
                            label = { Text("Numer DN") },
                            modifier = Modifier.fillMaxWidth()
                        )

                        var expanded by remember { mutableStateOf(false) }
                        ExposedDropdownMenuBox(
                            expanded = expanded,
                            onExpandedChange = { expanded = !expanded }
                        ) {
                            OutlinedTextField(
                                value = viewModel.editableCategory.value,
                                onValueChange = { viewModel.onEditableFieldChange(category = it) },
                                label = { Text("Kategoria") },
                                readOnly = true,
                                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                                modifier = Modifier
                                    .menuAnchor()
                                    .fillMaxWidth()
                            )
                            ExposedDropdownMenu(
                                expanded = expanded,
                                onDismissRequest = { expanded = false }
                            ) {
                                uiState.allCategories.forEach { category ->
                                    DropdownMenuItem(
                                        text = { Text(category.nazwa) },
                                        onClick = {
                                            viewModel.onEditableFieldChange(category = category.nazwa)
                                            expanded = false
                                        }
                                    )
                                }
                            }
                        }

                        OutlinedTextField(
                            value = viewModel.editableText.value,
                            onValueChange = { viewModel.onEditableFieldChange(text = it) },
                            label = { Text("Tekst pieśni") },
                            placeholder = { Text("Brak tekstu") },
                            modifier = Modifier.fillMaxWidth(),
                            textStyle = MaterialTheme.typography.bodyLarge.copy(
                                lineHeight = MaterialTheme.typography.bodyLarge.fontSize * 1.5
                            )
                        )
                    }
                }
                uiState.song != null -> {
                    val song = uiState.song!!
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .verticalScroll(rememberScrollState())
                            .padding(PaddingValues(horizontal = 16.dp, vertical = 24.dp))
                    ) {
                        val formattedText = song.tekst
                            ?.replace("*", "\n")
                            ?.replace(Regex("(?<!^)(\\d+\\.)"), "\n\n$1")
                            ?.replace(Regex("\\b(ref(en)?\\b[\\s.:;]*)", RegexOption.IGNORE_CASE), "\n\n$1\n")
                            ?.trim()
                            ?.takeIf { it.isNotBlank() }
                            ?: "Brak tekstu"

                        Text(
                            text = formattedText,
                            style = MaterialTheme.typography.bodyLarge,
                            lineHeight = MaterialTheme.typography.bodyLarge.fontSize * 1.5
                        )
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun ViewModeTopAppBar(title: String, onNavigateBack: () -> Unit, onEditClick: () -> Unit) {
    Column {
        CenterAlignedTopAppBar(
            title = { AutoResizingText(text = title, style = MaterialTheme.typography.titleLarge, textAlign = TextAlign.Center) },
            navigationIcon = { IconButton(onClick = onNavigateBack) { Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć") } },
            actions = { IconButton(onClick = onEditClick) { Icon(Icons.Default.Edit, "Edytuj treść") } },
            colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = MaterialTheme.colorScheme.background, titleContentColor = MaterialTheme.colorScheme.primary, navigationIconContentColor = MaterialTheme.colorScheme.primary)
        )
        Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun EditModeTopAppBar(title: String, onCancelClick: () -> Unit, onSaveClick: () -> Unit, isSaveEnabled: Boolean) {
    Column {
        CenterAlignedTopAppBar(
            title = { AutoResizingText(text = title, style = MaterialTheme.typography.titleLarge, textAlign = TextAlign.Center) },
            navigationIcon = { IconButton(onClick = onCancelClick) { Icon(Icons.Default.Close, "Anuluj edycję") } },
            actions = { IconButton(onClick = onSaveClick, enabled = isSaveEnabled) { Icon(Icons.Default.Check, "Zapisz zmiany", tint = if (isSaveEnabled) MaterialTheme.colorScheme.primary else Color.Gray) } },
            colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = MaterialTheme.colorScheme.background, titleContentColor = MaterialTheme.colorScheme.primary, navigationIconContentColor = MaterialTheme.colorScheme.primary)
        )
        Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
    }
}

@Composable
private fun ConfirmExitDialog(onDismiss: () -> Unit, onDiscard: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = MaterialTheme.shapes.large,
            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text(
                    "Odrzucić zmiany?",
                    style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),
                    color = SaturatedNavy
                )
                Spacer(Modifier.height(16.dp))
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                Spacer(Modifier.height(16.dp))
                Text("Czy na pewno chcesz wyjść bez zapisywania zmian?")
                Spacer(Modifier.height(24.dp))
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    TextButton(onClick = onDiscard) {
                        Text("Odrzuć")
                    }
                    Spacer(Modifier.width(8.dp))
                    Button(onClick = onDismiss) {
                        Text("Anuluj")
                    }
                }
            }
        }
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\songcontent\SongContentViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.songcontent

import android.content.Context
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.Category
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import com.qjproject.liturgicalcalendar.data.Song
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.net.URLDecoder

data class SongContentUiState(
    val isLoading: Boolean = true,
    val song: Song? = null,
    val error: String? = null,
    val isEditMode: Boolean = false,
    val hasChanges: Boolean = false,
    val showConfirmExitDialog: Boolean = false,
    val allCategories: List<Category> = emptyList()
)

class SongContentViewModel(
    savedStateHandle: SavedStateHandle,
    private val repository: FileSystemRepository
) : ViewModel() {

    private val songTitle: String? = savedStateHandle.get<String>("songTitle")?.let { URLDecoder.decode(it, "UTF-8") }
    private val siedlNum: String? = savedStateHandle.get<String>("siedlNum")?.let { URLDecoder.decode(it, "UTF-8") }
    private val sakNum: String? = savedStateHandle.get<String>("sakNum")?.let { URLDecoder.decode(it, "UTF-8") }
    private val dnNum: String? = savedStateHandle.get<String>("dnNum")?.let { URLDecoder.decode(it, "UTF-8") }

    private val _uiState = MutableStateFlow(SongContentUiState())
    val uiState = _uiState.asStateFlow()

    var editableTitle = mutableStateOf("")
        private set
    var editableNumerSiedl = mutableStateOf("")
        private set
    var editableNumerSak = mutableStateOf("")
        private set
    var editableNumerDn = mutableStateOf("")
        private set
    var editableCategory = mutableStateOf("")
        private set
    var editableText = mutableStateOf("")
        private set

    init {
        loadSong()
    }

    private fun loadSong() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            if (songTitle.isNullOrBlank()) {
                _uiState.update { it.copy(isLoading = false, error = "Brak tytułu pieśni.") }
                return@launch
            }
            val foundSong = repository.getSong(songTitle, siedlNum, sakNum, dnNum)
            val categories = repository.getCategoryList()
            if (foundSong != null) {
                _uiState.update { it.copy(isLoading = false, song = foundSong, allCategories = categories) }
            } else {
                _uiState.update { it.copy(isLoading = false, error = "Nie znaleziono pieśni o tytule: $songTitle", allCategories = categories) }
            }
        }
    }

    fun onEnterEditMode() {
        _uiState.value.song?.let { song ->
            editableTitle.value = song.tytul
            editableNumerSiedl.value = song.numerSiedl
            editableNumerSak.value = song.numerSAK
            editableNumerDn.value = song.numerDN
            editableCategory.value = song.kategoria
            editableText.value = song.tekst ?: ""
            _uiState.update { it.copy(isEditMode = true, hasChanges = false) }
        }
    }

    fun onTryExitEditMode() {
        if (_uiState.value.hasChanges) {
            _uiState.update { it.copy(showConfirmExitDialog = true) }
        } else {
            onDiscardChanges()
        }
    }

    fun onDiscardChanges() {
        _uiState.update { it.copy(isEditMode = false, hasChanges = false, showConfirmExitDialog = false) }
    }

    fun dismissConfirmExitDialog() {
        _uiState.update { it.copy(showConfirmExitDialog = false) }
    }


    fun onEditableFieldChange(
        title: String = editableTitle.value,
        siedl: String = editableNumerSiedl.value,
        sak: String = editableNumerSak.value,
        dn: String = editableNumerDn.value,
        category: String = editableCategory.value,
        text: String = editableText.value
    ) {
        val originalSong = _uiState.value.song
        editableTitle.value = title
        editableNumerSiedl.value = siedl
        editableNumerSak.value = sak
        editableNumerDn.value = dn
        editableCategory.value = category
        editableText.value = text

        val changed = originalSong?.tytul != title ||
                originalSong.numerSiedl != siedl ||
                originalSong.numerSAK != sak ||
                originalSong.numerDN != dn ||
                originalSong.kategoria != category ||
                originalSong.tekst != text

        _uiState.update { it.copy(hasChanges = changed) }
    }

    fun onSaveChanges() {
        val songToUpdate = _uiState.value.song ?: return
        viewModelScope.launch {
            val allSongs = repository.getSongList().toMutableList()
            val allCategories = repository.getCategoryList()
            val songIndex = allSongs.indexOfFirst { it.tytul == songToUpdate.tytul && it.numerSiedl == songToUpdate.numerSiedl }

            if (songIndex != -1) {
                // --- POCZĄTEK ZMIANY ---
                val selectedCategory = allCategories.find { it.nazwa.equals(editableCategory.value, ignoreCase = true) }
                val newSkr = selectedCategory?.skrot ?: ""

                val updatedSong = songToUpdate.copy(
                    tytul = editableTitle.value.trim(),
                    tekst = editableText.value.trim(),
                    numerSiedl = editableNumerSiedl.value.trim(),
                    numerSAK = editableNumerSak.value.trim(),
                    numerDN = editableNumerDn.value.trim(),
                    kategoria = editableCategory.value,
                    kategoriaSkr = newSkr
                )
                // --- KONIEC ZMIANY ---
                allSongs[songIndex] = updatedSong
                repository.saveSongList(allSongs).onSuccess {
                    _uiState.update { it.copy(isEditMode = false, hasChanges = false, song = allSongs[songIndex]) }
                }.onFailure { error ->
                    _uiState.update { it.copy(error = "Błąd zapisu: ${error.localizedMessage}") }
                }
            } else {
                _uiState.update { it.copy(error = "Nie można znaleźć pieśni do zaktualizowania.") }
            }
        }
    }
}

class SongContentViewModelFactory(
    private val context: Context,
    private val savedStateHandle: SavedStateHandle
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SongContentViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return SongContentViewModel(savedStateHandle, FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\songdetails\SongDetailsScreen.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.songdetails

import androidx.activity.compose.BackHandler
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import com.qjproject.liturgicalcalendar.ui.components.AutoResizingText
import com.qjproject.liturgicalcalendar.ui.theme.VeryDarkNavy

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SongDetailsScreen(
    viewModel: SongDetailsViewModel,
    onNavigateBack: () -> Unit,
    onNavigateToContent: (song: com.qjproject.liturgicalcalendar.data.Song, startInEditMode: Boolean) -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val song = uiState.song
    val lifecycleOwner = LocalLifecycleOwner.current

    BackHandler(onBack = onNavigateBack)

    // Ten efekt obserwuje cykl życia ekranu.
    // Gdy ekran jest wznawiany (ON_RESUME), np. po powrocie z edycji,
    // wywołuje funkcję reloadData(), aby pobrać najświeższe dane.
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_RESUME) {
                viewModel.reloadData()
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    Scaffold(
        topBar = {
            Column {
                CenterAlignedTopAppBar(
                    title = {
                        AutoResizingText(
                            text = uiState.song?.tytul ?: "Ładowanie...",
                            style = MaterialTheme.typography.titleLarge,
                            textAlign = TextAlign.Center
                        )
                    },
                    navigationIcon = {
                        IconButton(onClick = onNavigateBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Wróć")
                        }
                    },
                    actions = { Spacer(Modifier.width(48.dp)) },
                    colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                        containerColor = MaterialTheme.colorScheme.background,
                        titleContentColor = MaterialTheme.colorScheme.primary,
                        navigationIconContentColor = MaterialTheme.colorScheme.primary
                    )
                )
                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
            }
        }
    ) { innerPadding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
        ) {
            when {
                uiState.isLoading -> {
                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
                }
                uiState.error != null -> {
                    Text(
                        text = "Błąd: ${uiState.error}",
                        modifier = Modifier
                            .align(Alignment.Center)
                            .padding(16.dp),
                        color = MaterialTheme.colorScheme.error
                    )
                }
                song != null -> {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.Start
                    ) {
                        InfoRow(label = "Siedlecki:", value = song.numerSiedl)
                        InfoRow(label = "ŚAK:", value = song.numerSAK)
                        InfoRow(label = "DN:", value = song.numerDN)
                        InfoRow(label = "Kategoria:", value = song.kategoria)

                        Spacer(modifier = Modifier.height(16.dp))
                        Divider()
                        Spacer(modifier = Modifier.height(16.dp))
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable {
                                    val startInEdit = song.tekst.isNullOrBlank()
                                    onNavigateToContent(song, startInEdit)
                                },
                            colors = CardDefaults.cardColors(containerColor = VeryDarkNavy)
                        ) {
                            Column(Modifier.padding(16.dp)) {
                                Text(
                                    text = viewModel.getSongTextPreview(song.tekst),
                                    style = MaterialTheme.typography.bodyLarge,
                                    lineHeight = MaterialTheme.typography.bodyLarge.lineHeight * 1.2
                                )
                                if ((song.tekst?.lines()?.size ?: 0) > 6) {
                                    Spacer(modifier = Modifier.height(8.dp))
                                    Text(
                                        "...kliknij, aby zobaczyć więcej",
                                        style = MaterialTheme.typography.labelSmall,
                                        color = MaterialTheme.colorScheme.primary,
                                        modifier = Modifier.align(Alignment.End)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun InfoRow(label: String, value: String) {
    val displayValue = value.ifBlank { "-" }
    if (label == "Kategoria:" && displayValue == "-") {
        return
    }
    Row(modifier = Modifier.padding(vertical = 4.dp), verticalAlignment = Alignment.CenterVertically) {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyLarge,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.width(120.dp)
        )
        Text(
            text = displayValue,
            style = MaterialTheme.typography.bodyLarge
        )
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\screens\songdetails\SongDetailsViewModel.kt
treść:
package com.qjproject.liturgicalcalendar.ui.screens.songdetails

import android.content.Context
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.qjproject.liturgicalcalendar.data.FileSystemRepository
import com.qjproject.liturgicalcalendar.data.Song
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.net.URLDecoder

data class SongDetailsUiState(
    val isLoading: Boolean = true,
    val song: Song? = null,
    val error: String? = null
)

class SongDetailsViewModel(
    savedStateHandle: SavedStateHandle,
    private val repository: FileSystemRepository
) : ViewModel() {

    private val songTitle: String? = savedStateHandle.get<String>("songTitle")?.let { URLDecoder.decode(it, "UTF-8") }
    private val siedlNum: String? = savedStateHandle.get<String>("siedlNum")?.let { URLDecoder.decode(it, "UTF-8") }
    private val sakNum: String? = savedStateHandle.get<String>("sakNum")?.let { URLDecoder.decode(it, "UTF-8") }
    private val dnNum: String? = savedStateHandle.get<String>("dnNum")?.let { URLDecoder.decode(it, "UTF-8") }

    private val _uiState = MutableStateFlow(SongDetailsUiState())
    val uiState = _uiState.asStateFlow()

    init {
        // Wstępne ładowanie jest teraz obsługiwane przez obserwatora cyklu życia w ekranie,
        // ale zostawiamy je tutaj dla pierwszej kompozycji.
        if (_uiState.value.song == null) {
            reloadData()
        }
    }

    fun reloadData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }

            // Unieważnij pamięć podręczną przed pobraniem danych, aby mieć pewność, że są świeże
            repository.invalidateSongCache()

            if (songTitle.isNullOrBlank()) {
                _uiState.update { it.copy(isLoading = false, error = "Nieprawidłowy tytuł pieśni.") }
                return@launch
            }
            val foundSong = repository.getSong(songTitle, siedlNum, sakNum, dnNum)
            if (foundSong != null) {
                _uiState.update { it.copy(isLoading = false, song = foundSong) }
            } else {
                _uiState.update { it.copy(isLoading = false, error = "Nie znaleziono pieśni o tytule: $songTitle") }
            }
        }
    }

    fun getSongTextPreview(text: String?): String {
        if (text.isNullOrBlank()) return "Brak tekstu"
        return text.lines().take(6).joinToString(separator = "\n")
    }
}

class SongDetailsViewModelFactory(
    private val context: Context,
    private val savedStateHandle: SavedStateHandle
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SongDetailsViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return SongDetailsViewModel(savedStateHandle, FileSystemRepository(context.applicationContext)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\theme\Color.kt
treść:
package com.qjproject.liturgicalcalendar.ui.theme
import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)
val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

val DividerColor = Color.Gray.copy(alpha = 0.3f)
val SubtleGrayBackground = Color.Gray.copy(alpha = 0.12f)
val SongItemBackground = Color.Gray.copy(alpha = 0.1f)
val NavyDark = Color(0xFF16182D)
val DarkerNavy = Color(0xFF2C2E4A)
val VeryDarkNavy = Color(0xFF1A1D36)
val SaturatedNavy = Color(0xFF81A0D3)
val NavyLight = Color(0xFF4E5079)
val Cream = Color(0xFFF1DAC2)
val OffWhite = Color(0xFFEDE7E0)
val LightBlue = Color(0xFFBCCBEB)

val Gold = Color(0xFFFFD700)
val VividRed = Color(0xFFA22B27)

val NavBarBackground = Color(0xFF1F213A)


-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\theme\Theme.kt
treść:
package com.qjproject.liturgicalcalendar.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat

private val CustomDarkColorScheme = darkColorScheme(
    primary = LightBlue,
    secondary = NavyLight,
    background = NavyDark,
    surface = DarkerNavy, // ZMIANA: Użycie nowego, bardziej niebieskiego koloru dla powierzchni (modali, kart)
    onPrimary = NavyDark,
    onSecondary = OffWhite,
    onBackground = OffWhite,
    onSurface = OffWhite
)

private val CustomLightColorScheme = lightColorScheme(
    primary = LightBlue,
    secondary = NavyLight,
    background = OffWhite,
    surface = Cream,
    onPrimary = NavyDark,
    onSecondary = OffWhite,
    onBackground = NavyDark,
    onSurface = NavyDark
)

@Composable
fun LiturgicalCalendarTheme(
    darkTheme: Boolean = true,
    dynamicColor: Boolean = false,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> CustomDarkColorScheme
        else -> CustomLightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            // Ustawienie przezroczystości dla obu pasków systemowych
            window.statusBarColor = Color.Transparent.toArgb()
            window.navigationBarColor = Color.Transparent.toArgb()

            // Umożliwia aplikacji rysowanie treści "od krawędzi do krawędzi" (edge-to-edge)
            WindowCompat.setDecorFitsSystemWindows(window, false)

            val insetsController = WindowCompat.getInsetsController(window, view)

            // --- POCZĄTEK ZMIANY ---
            // Upewnij się, że pasek nawigacji jest widoczny.
            insetsController.show(WindowInsetsCompat.Type.navigationBars())
            // Usunięto ustawienie 'systemBarsBehavior', ponieważ pasek jest teraz zawsze widoczny,
            // a nie tymczasowo pokazywany gestem.
            // --- KONIEC ZMIANY ---

            // Ustawienie wyglądu ikon na paskach systemowych (dla momentu, gdy są widoczne)
            insetsController.isAppearanceLightStatusBars = !darkTheme
            insetsController.isAppearanceLightNavigationBars = !darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\java\com\qjproject\liturgicalcalendar\ui\theme\Type.kt
treść:
package com.qjproject.liturgicalcalendar.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    headlineMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 20.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    titleMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 18.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp
    ),
    // Definicja stylu dla tytułów pieśni
    headlineSmall = TextStyle(
        fontFamily = FontFamily.Serif,
        fontWeight = FontWeight.Normal,
        fontStyle = FontStyle.Italic,
        fontSize = 16.sp,
        lineHeight = 22.sp,
        letterSpacing = 0.sp
    )
)

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\res\values\colors.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="splash_background_color">#1F1E37</color>
</resources>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\res\values\themes.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Motyw dla wersji starszych niż Android 12 -->
    <style name="Theme.LiturgicalCalendar.Starting" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/splash_background_color</item>

        <!-- POPRAWKA: Jawnie wskazujemy na nasz plik PNG w folderze drawable -->
        <item name="windowSplashScreenAnimatedIcon">@drawable/splash_icon</item>
    </style>

    <style name="Theme.LiturgicalCalendar" parent="android:Theme.Material.Light.NoActionBar">
        <item name="android:windowBackground">@color/splash_background_color</item>
    </style>
</resources>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\main\res\values-v31\themes.xml
treść:
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Motyw dla Android 12 (API 31) i nowszych -->
    <style name="Theme.LiturgicalCalendar.Starting" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/splash_background_color</item>

        <!-- POPRAWKA: Jawnie wskazujemy na nasz plik PNG w folderze drawable -->
        <item name="windowSplashScreenAnimatedIcon">@drawable/splash_icon</item>

        <item name="postSplashScreenTheme">@style/Theme.LiturgicalCalendar</item>
    </style>

    <style name="Theme.LiturgicalCalendar" parent="android:Theme.Material.Light.NoActionBar">
        <item name="android:windowBackground">@color/splash_background_color</item>
    </style>
</resources>

-
nazwa pliku: C:\Users\blzej\Desktop\Aplikacja dla studenta\Aplikacja-dla-Konrada\app\src\test\java\com\qjproject\liturgicalcalendar\ExampleUnitTest.kt
treść:
package com.qjproject.liturgicalcalendar

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}

